// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cyberprobe.proto

#ifndef PROTOBUF_INCLUDED_cyberprobe_2eproto
#define PROTOBUF_INCLUDED_cyberprobe_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_cyberprobe_2eproto 

namespace protobuf_cyberprobe_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[67];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_cyberprobe_2eproto
namespace cyberprobe {
class Answer;
class AnswerDefaultTypeInternal;
extern AnswerDefaultTypeInternal _Answer_default_instance_;
class DnsMessage;
class DnsMessageDefaultTypeInternal;
extern DnsMessageDefaultTypeInternal _DnsMessage_default_instance_;
class Empty;
class EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class Esp;
class EspDefaultTypeInternal;
extern EspDefaultTypeInternal _Esp_default_instance_;
class Event;
class EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class FtpCommand;
class FtpCommandDefaultTypeInternal;
extern FtpCommandDefaultTypeInternal _FtpCommand_default_instance_;
class FtpResponse;
class FtpResponseDefaultTypeInternal;
extern FtpResponseDefaultTypeInternal _FtpResponse_default_instance_;
class Gre;
class GreDefaultTypeInternal;
extern GreDefaultTypeInternal _Gre_default_instance_;
class GrePptp;
class GrePptpDefaultTypeInternal;
extern GrePptpDefaultTypeInternal _GrePptp_default_instance_;
class HttpRequest;
class HttpRequestDefaultTypeInternal;
extern HttpRequestDefaultTypeInternal _HttpRequest_default_instance_;
class HttpRequest_HeaderEntry_DoNotUse;
class HttpRequest_HeaderEntry_DoNotUseDefaultTypeInternal;
extern HttpRequest_HeaderEntry_DoNotUseDefaultTypeInternal _HttpRequest_HeaderEntry_DoNotUse_default_instance_;
class HttpResponse;
class HttpResponseDefaultTypeInternal;
extern HttpResponseDefaultTypeInternal _HttpResponse_default_instance_;
class HttpResponse_HeaderEntry_DoNotUse;
class HttpResponse_HeaderEntry_DoNotUseDefaultTypeInternal;
extern HttpResponse_HeaderEntry_DoNotUseDefaultTypeInternal _HttpResponse_HeaderEntry_DoNotUse_default_instance_;
class Icmp;
class IcmpDefaultTypeInternal;
extern IcmpDefaultTypeInternal _Icmp_default_instance_;
class Imap;
class ImapDefaultTypeInternal;
extern ImapDefaultTypeInternal _Imap_default_instance_;
class Indicator;
class IndicatorDefaultTypeInternal;
extern IndicatorDefaultTypeInternal _Indicator_default_instance_;
class Locations;
class LocationsDefaultTypeInternal;
extern LocationsDefaultTypeInternal _Locations_default_instance_;
class Locations_Location;
class Locations_LocationDefaultTypeInternal;
extern Locations_LocationDefaultTypeInternal _Locations_Location_default_instance_;
class Ntp;
class NtpDefaultTypeInternal;
extern NtpDefaultTypeInternal _Ntp_default_instance_;
class Pop3;
class Pop3DefaultTypeInternal;
extern Pop3DefaultTypeInternal _Pop3_default_instance_;
class Pop3Ssl;
class Pop3SslDefaultTypeInternal;
extern Pop3SslDefaultTypeInternal _Pop3Ssl_default_instance_;
class Query;
class QueryDefaultTypeInternal;
extern QueryDefaultTypeInternal _Query_default_instance_;
class SipRequest;
class SipRequestDefaultTypeInternal;
extern SipRequestDefaultTypeInternal _SipRequest_default_instance_;
class SipResponse;
class SipResponseDefaultTypeInternal;
extern SipResponseDefaultTypeInternal _SipResponse_default_instance_;
class SipSsl;
class SipSslDefaultTypeInternal;
extern SipSslDefaultTypeInternal _SipSsl_default_instance_;
class SmtpCommand;
class SmtpCommandDefaultTypeInternal;
extern SmtpCommandDefaultTypeInternal _SmtpCommand_default_instance_;
class SmtpData;
class SmtpDataDefaultTypeInternal;
extern SmtpDataDefaultTypeInternal _SmtpData_default_instance_;
class SmtpResponse;
class SmtpResponseDefaultTypeInternal;
extern SmtpResponseDefaultTypeInternal _SmtpResponse_default_instance_;
class TlsApplicationData;
class TlsApplicationDataDefaultTypeInternal;
extern TlsApplicationDataDefaultTypeInternal _TlsApplicationData_default_instance_;
class TlsApplicationData_Tls;
class TlsApplicationData_TlsDefaultTypeInternal;
extern TlsApplicationData_TlsDefaultTypeInternal _TlsApplicationData_Tls_default_instance_;
class TlsCertificateRequest;
class TlsCertificateRequestDefaultTypeInternal;
extern TlsCertificateRequestDefaultTypeInternal _TlsCertificateRequest_default_instance_;
class TlsCertificateRequest_Tls;
class TlsCertificateRequest_TlsDefaultTypeInternal;
extern TlsCertificateRequest_TlsDefaultTypeInternal _TlsCertificateRequest_Tls_default_instance_;
class TlsCertificateRequest_Tls_SignatureAlgorithm;
class TlsCertificateRequest_Tls_SignatureAlgorithmDefaultTypeInternal;
extern TlsCertificateRequest_Tls_SignatureAlgorithmDefaultTypeInternal _TlsCertificateRequest_Tls_SignatureAlgorithm_default_instance_;
class TlsCertificateVerify;
class TlsCertificateVerifyDefaultTypeInternal;
extern TlsCertificateVerifyDefaultTypeInternal _TlsCertificateVerify_default_instance_;
class TlsCertificateVerify_Tls;
class TlsCertificateVerify_TlsDefaultTypeInternal;
extern TlsCertificateVerify_TlsDefaultTypeInternal _TlsCertificateVerify_Tls_default_instance_;
class TlsCertificateVerify_Tls_SignatureAlgorithm;
class TlsCertificateVerify_Tls_SignatureAlgorithmDefaultTypeInternal;
extern TlsCertificateVerify_Tls_SignatureAlgorithmDefaultTypeInternal _TlsCertificateVerify_Tls_SignatureAlgorithm_default_instance_;
class TlsCertificates;
class TlsCertificatesDefaultTypeInternal;
extern TlsCertificatesDefaultTypeInternal _TlsCertificates_default_instance_;
class TlsCertificates_Tls;
class TlsCertificates_TlsDefaultTypeInternal;
extern TlsCertificates_TlsDefaultTypeInternal _TlsCertificates_Tls_default_instance_;
class TlsChangeCipherSpec;
class TlsChangeCipherSpecDefaultTypeInternal;
extern TlsChangeCipherSpecDefaultTypeInternal _TlsChangeCipherSpec_default_instance_;
class TlsChangeCipherSpec_Tls;
class TlsChangeCipherSpec_TlsDefaultTypeInternal;
extern TlsChangeCipherSpec_TlsDefaultTypeInternal _TlsChangeCipherSpec_Tls_default_instance_;
class TlsClientHello;
class TlsClientHelloDefaultTypeInternal;
extern TlsClientHelloDefaultTypeInternal _TlsClientHello_default_instance_;
class TlsClientHello_Tls;
class TlsClientHello_TlsDefaultTypeInternal;
extern TlsClientHello_TlsDefaultTypeInternal _TlsClientHello_Tls_default_instance_;
class TlsClientHello_Tls_Extension;
class TlsClientHello_Tls_ExtensionDefaultTypeInternal;
extern TlsClientHello_Tls_ExtensionDefaultTypeInternal _TlsClientHello_Tls_Extension_default_instance_;
class TlsClientHello_Tls_Random;
class TlsClientHello_Tls_RandomDefaultTypeInternal;
extern TlsClientHello_Tls_RandomDefaultTypeInternal _TlsClientHello_Tls_Random_default_instance_;
class TlsClientKeyExchange;
class TlsClientKeyExchangeDefaultTypeInternal;
extern TlsClientKeyExchangeDefaultTypeInternal _TlsClientKeyExchange_default_instance_;
class TlsClientKeyExchange_Tls;
class TlsClientKeyExchange_TlsDefaultTypeInternal;
extern TlsClientKeyExchange_TlsDefaultTypeInternal _TlsClientKeyExchange_Tls_default_instance_;
class TlsHandshakeComplete;
class TlsHandshakeCompleteDefaultTypeInternal;
extern TlsHandshakeCompleteDefaultTypeInternal _TlsHandshakeComplete_default_instance_;
class TlsHandshakeComplete_Tls;
class TlsHandshakeComplete_TlsDefaultTypeInternal;
extern TlsHandshakeComplete_TlsDefaultTypeInternal _TlsHandshakeComplete_Tls_default_instance_;
class TlsHandshakeFinished;
class TlsHandshakeFinishedDefaultTypeInternal;
extern TlsHandshakeFinishedDefaultTypeInternal _TlsHandshakeFinished_default_instance_;
class TlsHandshakeFinished_Tls;
class TlsHandshakeFinished_TlsDefaultTypeInternal;
extern TlsHandshakeFinished_TlsDefaultTypeInternal _TlsHandshakeFinished_Tls_default_instance_;
class TlsHandshakeUnknown;
class TlsHandshakeUnknownDefaultTypeInternal;
extern TlsHandshakeUnknownDefaultTypeInternal _TlsHandshakeUnknown_default_instance_;
class TlsHandshakeUnknown_Tls;
class TlsHandshakeUnknown_TlsDefaultTypeInternal;
extern TlsHandshakeUnknown_TlsDefaultTypeInternal _TlsHandshakeUnknown_Tls_default_instance_;
class TlsServerHello;
class TlsServerHelloDefaultTypeInternal;
extern TlsServerHelloDefaultTypeInternal _TlsServerHello_default_instance_;
class TlsServerHelloDone;
class TlsServerHelloDoneDefaultTypeInternal;
extern TlsServerHelloDoneDefaultTypeInternal _TlsServerHelloDone_default_instance_;
class TlsServerHelloDone_Tls;
class TlsServerHelloDone_TlsDefaultTypeInternal;
extern TlsServerHelloDone_TlsDefaultTypeInternal _TlsServerHelloDone_Tls_default_instance_;
class TlsServerHello_Tls;
class TlsServerHello_TlsDefaultTypeInternal;
extern TlsServerHello_TlsDefaultTypeInternal _TlsServerHello_Tls_default_instance_;
class TlsServerHello_Tls_Extension;
class TlsServerHello_Tls_ExtensionDefaultTypeInternal;
extern TlsServerHello_Tls_ExtensionDefaultTypeInternal _TlsServerHello_Tls_Extension_default_instance_;
class TlsServerHello_Tls_Random;
class TlsServerHello_Tls_RandomDefaultTypeInternal;
extern TlsServerHello_Tls_RandomDefaultTypeInternal _TlsServerHello_Tls_Random_default_instance_;
class TlsServerKeyExchange;
class TlsServerKeyExchangeDefaultTypeInternal;
extern TlsServerKeyExchangeDefaultTypeInternal _TlsServerKeyExchange_default_instance_;
class TlsServerKeyExchange_Tls;
class TlsServerKeyExchange_TlsDefaultTypeInternal;
extern TlsServerKeyExchange_TlsDefaultTypeInternal _TlsServerKeyExchange_Tls_default_instance_;
class TlsServerKeyExchange_Tls_CurveMetadataEntry_DoNotUse;
class TlsServerKeyExchange_Tls_CurveMetadataEntry_DoNotUseDefaultTypeInternal;
extern TlsServerKeyExchange_Tls_CurveMetadataEntry_DoNotUseDefaultTypeInternal _TlsServerKeyExchange_Tls_CurveMetadataEntry_DoNotUse_default_instance_;
class TlsUnknown;
class TlsUnknownDefaultTypeInternal;
extern TlsUnknownDefaultTypeInternal _TlsUnknown_default_instance_;
class TlsUnknown_Tls;
class TlsUnknown_TlsDefaultTypeInternal;
extern TlsUnknown_TlsDefaultTypeInternal _TlsUnknown_Tls_default_instance_;
class UnrecognisedDatagram;
class UnrecognisedDatagramDefaultTypeInternal;
extern UnrecognisedDatagramDefaultTypeInternal _UnrecognisedDatagram_default_instance_;
class UnrecognisedIpProtocol;
class UnrecognisedIpProtocolDefaultTypeInternal;
extern UnrecognisedIpProtocolDefaultTypeInternal _UnrecognisedIpProtocol_default_instance_;
class UnrecognisedStream;
class UnrecognisedStreamDefaultTypeInternal;
extern UnrecognisedStreamDefaultTypeInternal _UnrecognisedStream_default_instance_;
class Wlan;
class WlanDefaultTypeInternal;
extern WlanDefaultTypeInternal _Wlan_default_instance_;
}  // namespace cyberprobe
namespace google {
namespace protobuf {
template<> ::cyberprobe::Answer* Arena::CreateMaybeMessage<::cyberprobe::Answer>(Arena*);
template<> ::cyberprobe::DnsMessage* Arena::CreateMaybeMessage<::cyberprobe::DnsMessage>(Arena*);
template<> ::cyberprobe::Empty* Arena::CreateMaybeMessage<::cyberprobe::Empty>(Arena*);
template<> ::cyberprobe::Esp* Arena::CreateMaybeMessage<::cyberprobe::Esp>(Arena*);
template<> ::cyberprobe::Event* Arena::CreateMaybeMessage<::cyberprobe::Event>(Arena*);
template<> ::cyberprobe::FtpCommand* Arena::CreateMaybeMessage<::cyberprobe::FtpCommand>(Arena*);
template<> ::cyberprobe::FtpResponse* Arena::CreateMaybeMessage<::cyberprobe::FtpResponse>(Arena*);
template<> ::cyberprobe::Gre* Arena::CreateMaybeMessage<::cyberprobe::Gre>(Arena*);
template<> ::cyberprobe::GrePptp* Arena::CreateMaybeMessage<::cyberprobe::GrePptp>(Arena*);
template<> ::cyberprobe::HttpRequest* Arena::CreateMaybeMessage<::cyberprobe::HttpRequest>(Arena*);
template<> ::cyberprobe::HttpRequest_HeaderEntry_DoNotUse* Arena::CreateMaybeMessage<::cyberprobe::HttpRequest_HeaderEntry_DoNotUse>(Arena*);
template<> ::cyberprobe::HttpResponse* Arena::CreateMaybeMessage<::cyberprobe::HttpResponse>(Arena*);
template<> ::cyberprobe::HttpResponse_HeaderEntry_DoNotUse* Arena::CreateMaybeMessage<::cyberprobe::HttpResponse_HeaderEntry_DoNotUse>(Arena*);
template<> ::cyberprobe::Icmp* Arena::CreateMaybeMessage<::cyberprobe::Icmp>(Arena*);
template<> ::cyberprobe::Imap* Arena::CreateMaybeMessage<::cyberprobe::Imap>(Arena*);
template<> ::cyberprobe::Indicator* Arena::CreateMaybeMessage<::cyberprobe::Indicator>(Arena*);
template<> ::cyberprobe::Locations* Arena::CreateMaybeMessage<::cyberprobe::Locations>(Arena*);
template<> ::cyberprobe::Locations_Location* Arena::CreateMaybeMessage<::cyberprobe::Locations_Location>(Arena*);
template<> ::cyberprobe::Ntp* Arena::CreateMaybeMessage<::cyberprobe::Ntp>(Arena*);
template<> ::cyberprobe::Pop3* Arena::CreateMaybeMessage<::cyberprobe::Pop3>(Arena*);
template<> ::cyberprobe::Pop3Ssl* Arena::CreateMaybeMessage<::cyberprobe::Pop3Ssl>(Arena*);
template<> ::cyberprobe::Query* Arena::CreateMaybeMessage<::cyberprobe::Query>(Arena*);
template<> ::cyberprobe::SipRequest* Arena::CreateMaybeMessage<::cyberprobe::SipRequest>(Arena*);
template<> ::cyberprobe::SipResponse* Arena::CreateMaybeMessage<::cyberprobe::SipResponse>(Arena*);
template<> ::cyberprobe::SipSsl* Arena::CreateMaybeMessage<::cyberprobe::SipSsl>(Arena*);
template<> ::cyberprobe::SmtpCommand* Arena::CreateMaybeMessage<::cyberprobe::SmtpCommand>(Arena*);
template<> ::cyberprobe::SmtpData* Arena::CreateMaybeMessage<::cyberprobe::SmtpData>(Arena*);
template<> ::cyberprobe::SmtpResponse* Arena::CreateMaybeMessage<::cyberprobe::SmtpResponse>(Arena*);
template<> ::cyberprobe::TlsApplicationData* Arena::CreateMaybeMessage<::cyberprobe::TlsApplicationData>(Arena*);
template<> ::cyberprobe::TlsApplicationData_Tls* Arena::CreateMaybeMessage<::cyberprobe::TlsApplicationData_Tls>(Arena*);
template<> ::cyberprobe::TlsCertificateRequest* Arena::CreateMaybeMessage<::cyberprobe::TlsCertificateRequest>(Arena*);
template<> ::cyberprobe::TlsCertificateRequest_Tls* Arena::CreateMaybeMessage<::cyberprobe::TlsCertificateRequest_Tls>(Arena*);
template<> ::cyberprobe::TlsCertificateRequest_Tls_SignatureAlgorithm* Arena::CreateMaybeMessage<::cyberprobe::TlsCertificateRequest_Tls_SignatureAlgorithm>(Arena*);
template<> ::cyberprobe::TlsCertificateVerify* Arena::CreateMaybeMessage<::cyberprobe::TlsCertificateVerify>(Arena*);
template<> ::cyberprobe::TlsCertificateVerify_Tls* Arena::CreateMaybeMessage<::cyberprobe::TlsCertificateVerify_Tls>(Arena*);
template<> ::cyberprobe::TlsCertificateVerify_Tls_SignatureAlgorithm* Arena::CreateMaybeMessage<::cyberprobe::TlsCertificateVerify_Tls_SignatureAlgorithm>(Arena*);
template<> ::cyberprobe::TlsCertificates* Arena::CreateMaybeMessage<::cyberprobe::TlsCertificates>(Arena*);
template<> ::cyberprobe::TlsCertificates_Tls* Arena::CreateMaybeMessage<::cyberprobe::TlsCertificates_Tls>(Arena*);
template<> ::cyberprobe::TlsChangeCipherSpec* Arena::CreateMaybeMessage<::cyberprobe::TlsChangeCipherSpec>(Arena*);
template<> ::cyberprobe::TlsChangeCipherSpec_Tls* Arena::CreateMaybeMessage<::cyberprobe::TlsChangeCipherSpec_Tls>(Arena*);
template<> ::cyberprobe::TlsClientHello* Arena::CreateMaybeMessage<::cyberprobe::TlsClientHello>(Arena*);
template<> ::cyberprobe::TlsClientHello_Tls* Arena::CreateMaybeMessage<::cyberprobe::TlsClientHello_Tls>(Arena*);
template<> ::cyberprobe::TlsClientHello_Tls_Extension* Arena::CreateMaybeMessage<::cyberprobe::TlsClientHello_Tls_Extension>(Arena*);
template<> ::cyberprobe::TlsClientHello_Tls_Random* Arena::CreateMaybeMessage<::cyberprobe::TlsClientHello_Tls_Random>(Arena*);
template<> ::cyberprobe::TlsClientKeyExchange* Arena::CreateMaybeMessage<::cyberprobe::TlsClientKeyExchange>(Arena*);
template<> ::cyberprobe::TlsClientKeyExchange_Tls* Arena::CreateMaybeMessage<::cyberprobe::TlsClientKeyExchange_Tls>(Arena*);
template<> ::cyberprobe::TlsHandshakeComplete* Arena::CreateMaybeMessage<::cyberprobe::TlsHandshakeComplete>(Arena*);
template<> ::cyberprobe::TlsHandshakeComplete_Tls* Arena::CreateMaybeMessage<::cyberprobe::TlsHandshakeComplete_Tls>(Arena*);
template<> ::cyberprobe::TlsHandshakeFinished* Arena::CreateMaybeMessage<::cyberprobe::TlsHandshakeFinished>(Arena*);
template<> ::cyberprobe::TlsHandshakeFinished_Tls* Arena::CreateMaybeMessage<::cyberprobe::TlsHandshakeFinished_Tls>(Arena*);
template<> ::cyberprobe::TlsHandshakeUnknown* Arena::CreateMaybeMessage<::cyberprobe::TlsHandshakeUnknown>(Arena*);
template<> ::cyberprobe::TlsHandshakeUnknown_Tls* Arena::CreateMaybeMessage<::cyberprobe::TlsHandshakeUnknown_Tls>(Arena*);
template<> ::cyberprobe::TlsServerHello* Arena::CreateMaybeMessage<::cyberprobe::TlsServerHello>(Arena*);
template<> ::cyberprobe::TlsServerHelloDone* Arena::CreateMaybeMessage<::cyberprobe::TlsServerHelloDone>(Arena*);
template<> ::cyberprobe::TlsServerHelloDone_Tls* Arena::CreateMaybeMessage<::cyberprobe::TlsServerHelloDone_Tls>(Arena*);
template<> ::cyberprobe::TlsServerHello_Tls* Arena::CreateMaybeMessage<::cyberprobe::TlsServerHello_Tls>(Arena*);
template<> ::cyberprobe::TlsServerHello_Tls_Extension* Arena::CreateMaybeMessage<::cyberprobe::TlsServerHello_Tls_Extension>(Arena*);
template<> ::cyberprobe::TlsServerHello_Tls_Random* Arena::CreateMaybeMessage<::cyberprobe::TlsServerHello_Tls_Random>(Arena*);
template<> ::cyberprobe::TlsServerKeyExchange* Arena::CreateMaybeMessage<::cyberprobe::TlsServerKeyExchange>(Arena*);
template<> ::cyberprobe::TlsServerKeyExchange_Tls* Arena::CreateMaybeMessage<::cyberprobe::TlsServerKeyExchange_Tls>(Arena*);
template<> ::cyberprobe::TlsServerKeyExchange_Tls_CurveMetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::cyberprobe::TlsServerKeyExchange_Tls_CurveMetadataEntry_DoNotUse>(Arena*);
template<> ::cyberprobe::TlsUnknown* Arena::CreateMaybeMessage<::cyberprobe::TlsUnknown>(Arena*);
template<> ::cyberprobe::TlsUnknown_Tls* Arena::CreateMaybeMessage<::cyberprobe::TlsUnknown_Tls>(Arena*);
template<> ::cyberprobe::UnrecognisedDatagram* Arena::CreateMaybeMessage<::cyberprobe::UnrecognisedDatagram>(Arena*);
template<> ::cyberprobe::UnrecognisedIpProtocol* Arena::CreateMaybeMessage<::cyberprobe::UnrecognisedIpProtocol>(Arena*);
template<> ::cyberprobe::UnrecognisedStream* Arena::CreateMaybeMessage<::cyberprobe::UnrecognisedStream>(Arena*);
template<> ::cyberprobe::Wlan* Arena::CreateMaybeMessage<::cyberprobe::Wlan>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace cyberprobe {

enum Action {
  dns_message = 0,
  unrecognised_datagram = 2,
  unrecognised_stream = 3,
  icmp = 4,
  http_request = 5,
  http_response = 6,
  sip_request = 7,
  sip_response = 8,
  sip_ssl = 9,
  imap = 10,
  pop3 = 11,
  pop3_ssl = 12,
  ntp_timestamp = 13,
  ntp_control = 14,
  ntp_private = 15,
  ftp_command = 16,
  ftp_response = 17,
  smtp_command = 18,
  smtp_response = 19,
  smtp_data = 20,
  gre = 21,
  gre_pptp = 22,
  esp = 23,
  unrecognised_ip_protocol = 24,
  wlan = 25,
  tls_unknown = 26,
  tls_client_hello = 27,
  tls_server_hello = 28,
  tls_certificates = 29,
  tls_server_key_exchange = 30,
  tls_server_hello_done = 31,
  tls_handshake_unknown = 32,
  tls_certificate_request = 33,
  tls_client_key_exchange = 34,
  tls_certificate_verify = 35,
  tls_change_cipher_spec = 36,
  tls_handshake_finished = 37,
  tls_handshake_complete = 38,
  tls_application_data = 39,
  Action_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Action_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Action_IsValid(int value);
const Action Action_MIN = dns_message;
const Action Action_MAX = tls_application_data;
const int Action_ARRAYSIZE = Action_MAX + 1;

const ::google::protobuf::EnumDescriptor* Action_descriptor();
inline const ::std::string& Action_Name(Action value) {
  return ::google::protobuf::internal::NameOfEnum(
    Action_descriptor(), value);
}
inline bool Action_Parse(
    const ::std::string& name, Action* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Action>(
    Action_descriptor(), name, value);
}
// ===================================================================

class Query : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.Query) */ {
 public:
  Query();
  virtual ~Query();

  Query(const Query& from);

  inline Query& operator=(const Query& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Query(Query&& from) noexcept
    : Query() {
    *this = ::std::move(from);
  }

  inline Query& operator=(Query&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Query& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Query* internal_default_instance() {
    return reinterpret_cast<const Query*>(
               &_Query_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Query* other);
  friend void swap(Query& a, Query& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Query* New() const final {
    return CreateMaybeMessage<Query>(NULL);
  }

  Query* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Query>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Query& from);
  void MergeFrom(const Query& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Query* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // string class = 3;
  void clear_class_();
  static const int kClassFieldNumber = 3;
  const ::std::string& class_() const;
  void set_class_(const ::std::string& value);
  #if LANG_CXX11
  void set_class_(::std::string&& value);
  #endif
  void set_class_(const char* value);
  void set_class_(const char* value, size_t size);
  ::std::string* mutable_class_();
  ::std::string* release_class_();
  void set_allocated_class_(::std::string* class_);

  // @@protoc_insertion_point(class_scope:cyberprobe.Query)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr class__;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Answer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.Answer) */ {
 public:
  Answer();
  virtual ~Answer();

  Answer(const Answer& from);

  inline Answer& operator=(const Answer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Answer(Answer&& from) noexcept
    : Answer() {
    *this = ::std::move(from);
  }

  inline Answer& operator=(Answer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Answer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Answer* internal_default_instance() {
    return reinterpret_cast<const Answer*>(
               &_Answer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Answer* other);
  friend void swap(Answer& a, Answer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Answer* New() const final {
    return CreateMaybeMessage<Answer>(NULL);
  }

  Answer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Answer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Answer& from);
  void MergeFrom(const Answer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Answer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // string class = 3;
  void clear_class_();
  static const int kClassFieldNumber = 3;
  const ::std::string& class_() const;
  void set_class_(const ::std::string& value);
  #if LANG_CXX11
  void set_class_(::std::string&& value);
  #endif
  void set_class_(const char* value);
  void set_class_(const char* value, size_t size);
  ::std::string* mutable_class_();
  ::std::string* release_class_();
  void set_allocated_class_(::std::string* class_);

  // string address = 4;
  void clear_address();
  static const int kAddressFieldNumber = 4;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // @@protoc_insertion_point(class_scope:cyberprobe.Answer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr class__;
  ::google::protobuf::internal::ArenaStringPtr address_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DnsMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.DnsMessage) */ {
 public:
  DnsMessage();
  virtual ~DnsMessage();

  DnsMessage(const DnsMessage& from);

  inline DnsMessage& operator=(const DnsMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DnsMessage(DnsMessage&& from) noexcept
    : DnsMessage() {
    *this = ::std::move(from);
  }

  inline DnsMessage& operator=(DnsMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DnsMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DnsMessage* internal_default_instance() {
    return reinterpret_cast<const DnsMessage*>(
               &_DnsMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(DnsMessage* other);
  friend void swap(DnsMessage& a, DnsMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DnsMessage* New() const final {
    return CreateMaybeMessage<DnsMessage>(NULL);
  }

  DnsMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DnsMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DnsMessage& from);
  void MergeFrom(const DnsMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DnsMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .cyberprobe.Query query = 1;
  int query_size() const;
  void clear_query();
  static const int kQueryFieldNumber = 1;
  ::cyberprobe::Query* mutable_query(int index);
  ::google::protobuf::RepeatedPtrField< ::cyberprobe::Query >*
      mutable_query();
  const ::cyberprobe::Query& query(int index) const;
  ::cyberprobe::Query* add_query();
  const ::google::protobuf::RepeatedPtrField< ::cyberprobe::Query >&
      query() const;

  // repeated .cyberprobe.Answer answer = 2;
  int answer_size() const;
  void clear_answer();
  static const int kAnswerFieldNumber = 2;
  ::cyberprobe::Answer* mutable_answer(int index);
  ::google::protobuf::RepeatedPtrField< ::cyberprobe::Answer >*
      mutable_answer();
  const ::cyberprobe::Answer& answer(int index) const;
  ::cyberprobe::Answer* add_answer();
  const ::google::protobuf::RepeatedPtrField< ::cyberprobe::Answer >&
      answer() const;

  // string type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:cyberprobe.DnsMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::cyberprobe::Query > query_;
  ::google::protobuf::RepeatedPtrField< ::cyberprobe::Answer > answer_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UnrecognisedDatagram : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.UnrecognisedDatagram) */ {
 public:
  UnrecognisedDatagram();
  virtual ~UnrecognisedDatagram();

  UnrecognisedDatagram(const UnrecognisedDatagram& from);

  inline UnrecognisedDatagram& operator=(const UnrecognisedDatagram& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnrecognisedDatagram(UnrecognisedDatagram&& from) noexcept
    : UnrecognisedDatagram() {
    *this = ::std::move(from);
  }

  inline UnrecognisedDatagram& operator=(UnrecognisedDatagram&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UnrecognisedDatagram& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnrecognisedDatagram* internal_default_instance() {
    return reinterpret_cast<const UnrecognisedDatagram*>(
               &_UnrecognisedDatagram_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(UnrecognisedDatagram* other);
  friend void swap(UnrecognisedDatagram& a, UnrecognisedDatagram& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnrecognisedDatagram* New() const final {
    return CreateMaybeMessage<UnrecognisedDatagram>(NULL);
  }

  UnrecognisedDatagram* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UnrecognisedDatagram>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UnrecognisedDatagram& from);
  void MergeFrom(const UnrecognisedDatagram& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnrecognisedDatagram* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes payload = 1;
  void clear_payload();
  static const int kPayloadFieldNumber = 1;
  const ::std::string& payload() const;
  void set_payload(const ::std::string& value);
  #if LANG_CXX11
  void set_payload(::std::string&& value);
  #endif
  void set_payload(const char* value);
  void set_payload(const void* value, size_t size);
  ::std::string* mutable_payload();
  ::std::string* release_payload();
  void set_allocated_payload(::std::string* payload);

  // @@protoc_insertion_point(class_scope:cyberprobe.UnrecognisedDatagram)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr payload_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UnrecognisedStream : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.UnrecognisedStream) */ {
 public:
  UnrecognisedStream();
  virtual ~UnrecognisedStream();

  UnrecognisedStream(const UnrecognisedStream& from);

  inline UnrecognisedStream& operator=(const UnrecognisedStream& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnrecognisedStream(UnrecognisedStream&& from) noexcept
    : UnrecognisedStream() {
    *this = ::std::move(from);
  }

  inline UnrecognisedStream& operator=(UnrecognisedStream&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UnrecognisedStream& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnrecognisedStream* internal_default_instance() {
    return reinterpret_cast<const UnrecognisedStream*>(
               &_UnrecognisedStream_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(UnrecognisedStream* other);
  friend void swap(UnrecognisedStream& a, UnrecognisedStream& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnrecognisedStream* New() const final {
    return CreateMaybeMessage<UnrecognisedStream>(NULL);
  }

  UnrecognisedStream* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UnrecognisedStream>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UnrecognisedStream& from);
  void MergeFrom(const UnrecognisedStream& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnrecognisedStream* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes payload = 1;
  void clear_payload();
  static const int kPayloadFieldNumber = 1;
  const ::std::string& payload() const;
  void set_payload(const ::std::string& value);
  #if LANG_CXX11
  void set_payload(::std::string&& value);
  #endif
  void set_payload(const char* value);
  void set_payload(const void* value, size_t size);
  ::std::string* mutable_payload();
  ::std::string* release_payload();
  void set_allocated_payload(::std::string* payload);

  // int64 position = 2;
  void clear_position();
  static const int kPositionFieldNumber = 2;
  ::google::protobuf::int64 position() const;
  void set_position(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:cyberprobe.UnrecognisedStream)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr payload_;
  ::google::protobuf::int64 position_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Icmp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.Icmp) */ {
 public:
  Icmp();
  virtual ~Icmp();

  Icmp(const Icmp& from);

  inline Icmp& operator=(const Icmp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Icmp(Icmp&& from) noexcept
    : Icmp() {
    *this = ::std::move(from);
  }

  inline Icmp& operator=(Icmp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Icmp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Icmp* internal_default_instance() {
    return reinterpret_cast<const Icmp*>(
               &_Icmp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Icmp* other);
  friend void swap(Icmp& a, Icmp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Icmp* New() const final {
    return CreateMaybeMessage<Icmp>(NULL);
  }

  Icmp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Icmp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Icmp& from);
  void MergeFrom(const Icmp& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Icmp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes payload = 3;
  void clear_payload();
  static const int kPayloadFieldNumber = 3;
  const ::std::string& payload() const;
  void set_payload(const ::std::string& value);
  #if LANG_CXX11
  void set_payload(::std::string&& value);
  #endif
  void set_payload(const char* value);
  void set_payload(const void* value, size_t size);
  ::std::string* mutable_payload();
  ::std::string* release_payload();
  void set_allocated_payload(::std::string* payload);

  // int32 type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // int32 code = 2;
  void clear_code();
  static const int kCodeFieldNumber = 2;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cyberprobe.Icmp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr payload_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 code_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HttpRequest_HeaderEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<HttpRequest_HeaderEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<HttpRequest_HeaderEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  HttpRequest_HeaderEntry_DoNotUse();
  HttpRequest_HeaderEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const HttpRequest_HeaderEntry_DoNotUse& other);
  static const HttpRequest_HeaderEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const HttpRequest_HeaderEntry_DoNotUse*>(&_HttpRequest_HeaderEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class HttpRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.HttpRequest) */ {
 public:
  HttpRequest();
  virtual ~HttpRequest();

  HttpRequest(const HttpRequest& from);

  inline HttpRequest& operator=(const HttpRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HttpRequest(HttpRequest&& from) noexcept
    : HttpRequest() {
    *this = ::std::move(from);
  }

  inline HttpRequest& operator=(HttpRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HttpRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HttpRequest* internal_default_instance() {
    return reinterpret_cast<const HttpRequest*>(
               &_HttpRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(HttpRequest* other);
  friend void swap(HttpRequest& a, HttpRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HttpRequest* New() const final {
    return CreateMaybeMessage<HttpRequest>(NULL);
  }

  HttpRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HttpRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HttpRequest& from);
  void MergeFrom(const HttpRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HttpRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> header = 2;
  int header_size() const;
  void clear_header();
  static const int kHeaderFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      header() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_header();

  // string method = 1;
  void clear_method();
  static const int kMethodFieldNumber = 1;
  const ::std::string& method() const;
  void set_method(const ::std::string& value);
  #if LANG_CXX11
  void set_method(::std::string&& value);
  #endif
  void set_method(const char* value);
  void set_method(const char* value, size_t size);
  ::std::string* mutable_method();
  ::std::string* release_method();
  void set_allocated_method(::std::string* method);

  // bytes body = 3;
  void clear_body();
  static const int kBodyFieldNumber = 3;
  const ::std::string& body() const;
  void set_body(const ::std::string& value);
  #if LANG_CXX11
  void set_body(::std::string&& value);
  #endif
  void set_body(const char* value);
  void set_body(const void* value, size_t size);
  ::std::string* mutable_body();
  ::std::string* release_body();
  void set_allocated_body(::std::string* body);

  // @@protoc_insertion_point(class_scope:cyberprobe.HttpRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      HttpRequest_HeaderEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > header_;
  ::google::protobuf::internal::ArenaStringPtr method_;
  ::google::protobuf::internal::ArenaStringPtr body_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HttpResponse_HeaderEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<HttpResponse_HeaderEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<HttpResponse_HeaderEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  HttpResponse_HeaderEntry_DoNotUse();
  HttpResponse_HeaderEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const HttpResponse_HeaderEntry_DoNotUse& other);
  static const HttpResponse_HeaderEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const HttpResponse_HeaderEntry_DoNotUse*>(&_HttpResponse_HeaderEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class HttpResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.HttpResponse) */ {
 public:
  HttpResponse();
  virtual ~HttpResponse();

  HttpResponse(const HttpResponse& from);

  inline HttpResponse& operator=(const HttpResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HttpResponse(HttpResponse&& from) noexcept
    : HttpResponse() {
    *this = ::std::move(from);
  }

  inline HttpResponse& operator=(HttpResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HttpResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HttpResponse* internal_default_instance() {
    return reinterpret_cast<const HttpResponse*>(
               &_HttpResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(HttpResponse* other);
  friend void swap(HttpResponse& a, HttpResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HttpResponse* New() const final {
    return CreateMaybeMessage<HttpResponse>(NULL);
  }

  HttpResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HttpResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HttpResponse& from);
  void MergeFrom(const HttpResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HttpResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> header = 3;
  int header_size() const;
  void clear_header();
  static const int kHeaderFieldNumber = 3;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      header() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_header();

  // string status = 2;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  const ::std::string& status() const;
  void set_status(const ::std::string& value);
  #if LANG_CXX11
  void set_status(::std::string&& value);
  #endif
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  ::std::string* mutable_status();
  ::std::string* release_status();
  void set_allocated_status(::std::string* status);

  // bytes body = 4;
  void clear_body();
  static const int kBodyFieldNumber = 4;
  const ::std::string& body() const;
  void set_body(const ::std::string& value);
  #if LANG_CXX11
  void set_body(::std::string&& value);
  #endif
  void set_body(const char* value);
  void set_body(const void* value, size_t size);
  ::std::string* mutable_body();
  ::std::string* release_body();
  void set_allocated_body(::std::string* body);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cyberprobe.HttpResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      HttpResponse_HeaderEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > header_;
  ::google::protobuf::internal::ArenaStringPtr status_;
  ::google::protobuf::internal::ArenaStringPtr body_;
  ::google::protobuf::int32 code_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SipRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.SipRequest) */ {
 public:
  SipRequest();
  virtual ~SipRequest();

  SipRequest(const SipRequest& from);

  inline SipRequest& operator=(const SipRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SipRequest(SipRequest&& from) noexcept
    : SipRequest() {
    *this = ::std::move(from);
  }

  inline SipRequest& operator=(SipRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SipRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SipRequest* internal_default_instance() {
    return reinterpret_cast<const SipRequest*>(
               &_SipRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(SipRequest* other);
  friend void swap(SipRequest& a, SipRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SipRequest* New() const final {
    return CreateMaybeMessage<SipRequest>(NULL);
  }

  SipRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SipRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SipRequest& from);
  void MergeFrom(const SipRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SipRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string method = 1;
  void clear_method();
  static const int kMethodFieldNumber = 1;
  const ::std::string& method() const;
  void set_method(const ::std::string& value);
  #if LANG_CXX11
  void set_method(::std::string&& value);
  #endif
  void set_method(const char* value);
  void set_method(const char* value, size_t size);
  ::std::string* mutable_method();
  ::std::string* release_method();
  void set_allocated_method(::std::string* method);

  // string from = 2;
  void clear_from();
  static const int kFromFieldNumber = 2;
  const ::std::string& from() const;
  void set_from(const ::std::string& value);
  #if LANG_CXX11
  void set_from(::std::string&& value);
  #endif
  void set_from(const char* value);
  void set_from(const char* value, size_t size);
  ::std::string* mutable_from();
  ::std::string* release_from();
  void set_allocated_from(::std::string* from);

  // string to = 3;
  void clear_to();
  static const int kToFieldNumber = 3;
  const ::std::string& to() const;
  void set_to(const ::std::string& value);
  #if LANG_CXX11
  void set_to(::std::string&& value);
  #endif
  void set_to(const char* value);
  void set_to(const char* value, size_t size);
  ::std::string* mutable_to();
  ::std::string* release_to();
  void set_allocated_to(::std::string* to);

  // bytes payload = 4;
  void clear_payload();
  static const int kPayloadFieldNumber = 4;
  const ::std::string& payload() const;
  void set_payload(const ::std::string& value);
  #if LANG_CXX11
  void set_payload(::std::string&& value);
  #endif
  void set_payload(const char* value);
  void set_payload(const void* value, size_t size);
  ::std::string* mutable_payload();
  ::std::string* release_payload();
  void set_allocated_payload(::std::string* payload);

  // @@protoc_insertion_point(class_scope:cyberprobe.SipRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr method_;
  ::google::protobuf::internal::ArenaStringPtr from_;
  ::google::protobuf::internal::ArenaStringPtr to_;
  ::google::protobuf::internal::ArenaStringPtr payload_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SipResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.SipResponse) */ {
 public:
  SipResponse();
  virtual ~SipResponse();

  SipResponse(const SipResponse& from);

  inline SipResponse& operator=(const SipResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SipResponse(SipResponse&& from) noexcept
    : SipResponse() {
    *this = ::std::move(from);
  }

  inline SipResponse& operator=(SipResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SipResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SipResponse* internal_default_instance() {
    return reinterpret_cast<const SipResponse*>(
               &_SipResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(SipResponse* other);
  friend void swap(SipResponse& a, SipResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SipResponse* New() const final {
    return CreateMaybeMessage<SipResponse>(NULL);
  }

  SipResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SipResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SipResponse& from);
  void MergeFrom(const SipResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SipResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string status = 2;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  const ::std::string& status() const;
  void set_status(const ::std::string& value);
  #if LANG_CXX11
  void set_status(::std::string&& value);
  #endif
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  ::std::string* mutable_status();
  ::std::string* release_status();
  void set_allocated_status(::std::string* status);

  // string from = 3;
  void clear_from();
  static const int kFromFieldNumber = 3;
  const ::std::string& from() const;
  void set_from(const ::std::string& value);
  #if LANG_CXX11
  void set_from(::std::string&& value);
  #endif
  void set_from(const char* value);
  void set_from(const char* value, size_t size);
  ::std::string* mutable_from();
  ::std::string* release_from();
  void set_allocated_from(::std::string* from);

  // string to = 4;
  void clear_to();
  static const int kToFieldNumber = 4;
  const ::std::string& to() const;
  void set_to(const ::std::string& value);
  #if LANG_CXX11
  void set_to(::std::string&& value);
  #endif
  void set_to(const char* value);
  void set_to(const char* value, size_t size);
  ::std::string* mutable_to();
  ::std::string* release_to();
  void set_allocated_to(::std::string* to);

  // bytes payload = 5;
  void clear_payload();
  static const int kPayloadFieldNumber = 5;
  const ::std::string& payload() const;
  void set_payload(const ::std::string& value);
  #if LANG_CXX11
  void set_payload(::std::string&& value);
  #endif
  void set_payload(const char* value);
  void set_payload(const void* value, size_t size);
  ::std::string* mutable_payload();
  ::std::string* release_payload();
  void set_allocated_payload(::std::string* payload);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cyberprobe.SipResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr status_;
  ::google::protobuf::internal::ArenaStringPtr from_;
  ::google::protobuf::internal::ArenaStringPtr to_;
  ::google::protobuf::internal::ArenaStringPtr payload_;
  ::google::protobuf::int32 code_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SipSsl : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.SipSsl) */ {
 public:
  SipSsl();
  virtual ~SipSsl();

  SipSsl(const SipSsl& from);

  inline SipSsl& operator=(const SipSsl& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SipSsl(SipSsl&& from) noexcept
    : SipSsl() {
    *this = ::std::move(from);
  }

  inline SipSsl& operator=(SipSsl&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SipSsl& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SipSsl* internal_default_instance() {
    return reinterpret_cast<const SipSsl*>(
               &_SipSsl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(SipSsl* other);
  friend void swap(SipSsl& a, SipSsl& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SipSsl* New() const final {
    return CreateMaybeMessage<SipSsl>(NULL);
  }

  SipSsl* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SipSsl>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SipSsl& from);
  void MergeFrom(const SipSsl& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SipSsl* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes payload = 1;
  void clear_payload();
  static const int kPayloadFieldNumber = 1;
  const ::std::string& payload() const;
  void set_payload(const ::std::string& value);
  #if LANG_CXX11
  void set_payload(::std::string&& value);
  #endif
  void set_payload(const char* value);
  void set_payload(const void* value, size_t size);
  ::std::string* mutable_payload();
  ::std::string* release_payload();
  void set_allocated_payload(::std::string* payload);

  // @@protoc_insertion_point(class_scope:cyberprobe.SipSsl)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr payload_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Imap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.Imap) */ {
 public:
  Imap();
  virtual ~Imap();

  Imap(const Imap& from);

  inline Imap& operator=(const Imap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Imap(Imap&& from) noexcept
    : Imap() {
    *this = ::std::move(from);
  }

  inline Imap& operator=(Imap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Imap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Imap* internal_default_instance() {
    return reinterpret_cast<const Imap*>(
               &_Imap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(Imap* other);
  friend void swap(Imap& a, Imap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Imap* New() const final {
    return CreateMaybeMessage<Imap>(NULL);
  }

  Imap* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Imap>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Imap& from);
  void MergeFrom(const Imap& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Imap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes payload = 1;
  void clear_payload();
  static const int kPayloadFieldNumber = 1;
  const ::std::string& payload() const;
  void set_payload(const ::std::string& value);
  #if LANG_CXX11
  void set_payload(::std::string&& value);
  #endif
  void set_payload(const char* value);
  void set_payload(const void* value, size_t size);
  ::std::string* mutable_payload();
  ::std::string* release_payload();
  void set_allocated_payload(::std::string* payload);

  // @@protoc_insertion_point(class_scope:cyberprobe.Imap)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr payload_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Pop3 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.Pop3) */ {
 public:
  Pop3();
  virtual ~Pop3();

  Pop3(const Pop3& from);

  inline Pop3& operator=(const Pop3& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Pop3(Pop3&& from) noexcept
    : Pop3() {
    *this = ::std::move(from);
  }

  inline Pop3& operator=(Pop3&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Pop3& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Pop3* internal_default_instance() {
    return reinterpret_cast<const Pop3*>(
               &_Pop3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(Pop3* other);
  friend void swap(Pop3& a, Pop3& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Pop3* New() const final {
    return CreateMaybeMessage<Pop3>(NULL);
  }

  Pop3* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Pop3>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Pop3& from);
  void MergeFrom(const Pop3& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pop3* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes payload = 1;
  void clear_payload();
  static const int kPayloadFieldNumber = 1;
  const ::std::string& payload() const;
  void set_payload(const ::std::string& value);
  #if LANG_CXX11
  void set_payload(::std::string&& value);
  #endif
  void set_payload(const char* value);
  void set_payload(const void* value, size_t size);
  ::std::string* mutable_payload();
  ::std::string* release_payload();
  void set_allocated_payload(::std::string* payload);

  // @@protoc_insertion_point(class_scope:cyberprobe.Pop3)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr payload_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Pop3Ssl : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.Pop3Ssl) */ {
 public:
  Pop3Ssl();
  virtual ~Pop3Ssl();

  Pop3Ssl(const Pop3Ssl& from);

  inline Pop3Ssl& operator=(const Pop3Ssl& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Pop3Ssl(Pop3Ssl&& from) noexcept
    : Pop3Ssl() {
    *this = ::std::move(from);
  }

  inline Pop3Ssl& operator=(Pop3Ssl&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Pop3Ssl& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Pop3Ssl* internal_default_instance() {
    return reinterpret_cast<const Pop3Ssl*>(
               &_Pop3Ssl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(Pop3Ssl* other);
  friend void swap(Pop3Ssl& a, Pop3Ssl& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Pop3Ssl* New() const final {
    return CreateMaybeMessage<Pop3Ssl>(NULL);
  }

  Pop3Ssl* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Pop3Ssl>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Pop3Ssl& from);
  void MergeFrom(const Pop3Ssl& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pop3Ssl* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes payload = 1;
  void clear_payload();
  static const int kPayloadFieldNumber = 1;
  const ::std::string& payload() const;
  void set_payload(const ::std::string& value);
  #if LANG_CXX11
  void set_payload(::std::string&& value);
  #endif
  void set_payload(const char* value);
  void set_payload(const void* value, size_t size);
  ::std::string* mutable_payload();
  ::std::string* release_payload();
  void set_allocated_payload(::std::string* payload);

  // @@protoc_insertion_point(class_scope:cyberprobe.Pop3Ssl)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr payload_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Ntp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.Ntp) */ {
 public:
  Ntp();
  virtual ~Ntp();

  Ntp(const Ntp& from);

  inline Ntp& operator=(const Ntp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Ntp(Ntp&& from) noexcept
    : Ntp() {
    *this = ::std::move(from);
  }

  inline Ntp& operator=(Ntp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Ntp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Ntp* internal_default_instance() {
    return reinterpret_cast<const Ntp*>(
               &_Ntp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(Ntp* other);
  friend void swap(Ntp& a, Ntp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Ntp* New() const final {
    return CreateMaybeMessage<Ntp>(NULL);
  }

  Ntp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Ntp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Ntp& from);
  void MergeFrom(const Ntp& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ntp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::int32 version() const;
  void set_version(::google::protobuf::int32 value);

  // int32 mode = 2;
  void clear_mode();
  static const int kModeFieldNumber = 2;
  ::google::protobuf::int32 mode() const;
  void set_mode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cyberprobe.Ntp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 version_;
  ::google::protobuf::int32 mode_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FtpCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.FtpCommand) */ {
 public:
  FtpCommand();
  virtual ~FtpCommand();

  FtpCommand(const FtpCommand& from);

  inline FtpCommand& operator=(const FtpCommand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FtpCommand(FtpCommand&& from) noexcept
    : FtpCommand() {
    *this = ::std::move(from);
  }

  inline FtpCommand& operator=(FtpCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FtpCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FtpCommand* internal_default_instance() {
    return reinterpret_cast<const FtpCommand*>(
               &_FtpCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(FtpCommand* other);
  friend void swap(FtpCommand& a, FtpCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FtpCommand* New() const final {
    return CreateMaybeMessage<FtpCommand>(NULL);
  }

  FtpCommand* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FtpCommand>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FtpCommand& from);
  void MergeFrom(const FtpCommand& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FtpCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string command = 1;
  void clear_command();
  static const int kCommandFieldNumber = 1;
  const ::std::string& command() const;
  void set_command(const ::std::string& value);
  #if LANG_CXX11
  void set_command(::std::string&& value);
  #endif
  void set_command(const char* value);
  void set_command(const char* value, size_t size);
  ::std::string* mutable_command();
  ::std::string* release_command();
  void set_allocated_command(::std::string* command);

  // @@protoc_insertion_point(class_scope:cyberprobe.FtpCommand)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr command_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FtpResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.FtpResponse) */ {
 public:
  FtpResponse();
  virtual ~FtpResponse();

  FtpResponse(const FtpResponse& from);

  inline FtpResponse& operator=(const FtpResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FtpResponse(FtpResponse&& from) noexcept
    : FtpResponse() {
    *this = ::std::move(from);
  }

  inline FtpResponse& operator=(FtpResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FtpResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FtpResponse* internal_default_instance() {
    return reinterpret_cast<const FtpResponse*>(
               &_FtpResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(FtpResponse* other);
  friend void swap(FtpResponse& a, FtpResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FtpResponse* New() const final {
    return CreateMaybeMessage<FtpResponse>(NULL);
  }

  FtpResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FtpResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FtpResponse& from);
  void MergeFrom(const FtpResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FtpResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string text = 2;
  int text_size() const;
  void clear_text();
  static const int kTextFieldNumber = 2;
  const ::std::string& text(int index) const;
  ::std::string* mutable_text(int index);
  void set_text(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_text(int index, ::std::string&& value);
  #endif
  void set_text(int index, const char* value);
  void set_text(int index, const char* value, size_t size);
  ::std::string* add_text();
  void add_text(const ::std::string& value);
  #if LANG_CXX11
  void add_text(::std::string&& value);
  #endif
  void add_text(const char* value);
  void add_text(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& text() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_text();

  // int32 status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::google::protobuf::int32 status() const;
  void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cyberprobe.FtpResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> text_;
  ::google::protobuf::int32 status_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SmtpCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.SmtpCommand) */ {
 public:
  SmtpCommand();
  virtual ~SmtpCommand();

  SmtpCommand(const SmtpCommand& from);

  inline SmtpCommand& operator=(const SmtpCommand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SmtpCommand(SmtpCommand&& from) noexcept
    : SmtpCommand() {
    *this = ::std::move(from);
  }

  inline SmtpCommand& operator=(SmtpCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SmtpCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SmtpCommand* internal_default_instance() {
    return reinterpret_cast<const SmtpCommand*>(
               &_SmtpCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(SmtpCommand* other);
  friend void swap(SmtpCommand& a, SmtpCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SmtpCommand* New() const final {
    return CreateMaybeMessage<SmtpCommand>(NULL);
  }

  SmtpCommand* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SmtpCommand>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SmtpCommand& from);
  void MergeFrom(const SmtpCommand& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SmtpCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string command = 1;
  void clear_command();
  static const int kCommandFieldNumber = 1;
  const ::std::string& command() const;
  void set_command(const ::std::string& value);
  #if LANG_CXX11
  void set_command(::std::string&& value);
  #endif
  void set_command(const char* value);
  void set_command(const char* value, size_t size);
  ::std::string* mutable_command();
  ::std::string* release_command();
  void set_allocated_command(::std::string* command);

  // @@protoc_insertion_point(class_scope:cyberprobe.SmtpCommand)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr command_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SmtpResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.SmtpResponse) */ {
 public:
  SmtpResponse();
  virtual ~SmtpResponse();

  SmtpResponse(const SmtpResponse& from);

  inline SmtpResponse& operator=(const SmtpResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SmtpResponse(SmtpResponse&& from) noexcept
    : SmtpResponse() {
    *this = ::std::move(from);
  }

  inline SmtpResponse& operator=(SmtpResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SmtpResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SmtpResponse* internal_default_instance() {
    return reinterpret_cast<const SmtpResponse*>(
               &_SmtpResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(SmtpResponse* other);
  friend void swap(SmtpResponse& a, SmtpResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SmtpResponse* New() const final {
    return CreateMaybeMessage<SmtpResponse>(NULL);
  }

  SmtpResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SmtpResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SmtpResponse& from);
  void MergeFrom(const SmtpResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SmtpResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string text = 2;
  int text_size() const;
  void clear_text();
  static const int kTextFieldNumber = 2;
  const ::std::string& text(int index) const;
  ::std::string* mutable_text(int index);
  void set_text(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_text(int index, ::std::string&& value);
  #endif
  void set_text(int index, const char* value);
  void set_text(int index, const char* value, size_t size);
  ::std::string* add_text();
  void add_text(const ::std::string& value);
  #if LANG_CXX11
  void add_text(::std::string&& value);
  #endif
  void add_text(const char* value);
  void add_text(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& text() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_text();

  // int32 status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::google::protobuf::int32 status() const;
  void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cyberprobe.SmtpResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> text_;
  ::google::protobuf::int32 status_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SmtpData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.SmtpData) */ {
 public:
  SmtpData();
  virtual ~SmtpData();

  SmtpData(const SmtpData& from);

  inline SmtpData& operator=(const SmtpData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SmtpData(SmtpData&& from) noexcept
    : SmtpData() {
    *this = ::std::move(from);
  }

  inline SmtpData& operator=(SmtpData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SmtpData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SmtpData* internal_default_instance() {
    return reinterpret_cast<const SmtpData*>(
               &_SmtpData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(SmtpData* other);
  friend void swap(SmtpData& a, SmtpData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SmtpData* New() const final {
    return CreateMaybeMessage<SmtpData>(NULL);
  }

  SmtpData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SmtpData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SmtpData& from);
  void MergeFrom(const SmtpData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SmtpData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string to = 2;
  int to_size() const;
  void clear_to();
  static const int kToFieldNumber = 2;
  const ::std::string& to(int index) const;
  ::std::string* mutable_to(int index);
  void set_to(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_to(int index, ::std::string&& value);
  #endif
  void set_to(int index, const char* value);
  void set_to(int index, const char* value, size_t size);
  ::std::string* add_to();
  void add_to(const ::std::string& value);
  #if LANG_CXX11
  void add_to(::std::string&& value);
  #endif
  void add_to(const char* value);
  void add_to(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& to() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_to();

  // string from = 1;
  void clear_from();
  static const int kFromFieldNumber = 1;
  const ::std::string& from() const;
  void set_from(const ::std::string& value);
  #if LANG_CXX11
  void set_from(::std::string&& value);
  #endif
  void set_from(const char* value);
  void set_from(const char* value, size_t size);
  ::std::string* mutable_from();
  ::std::string* release_from();
  void set_allocated_from(::std::string* from);

  // bytes body = 3;
  void clear_body();
  static const int kBodyFieldNumber = 3;
  const ::std::string& body() const;
  void set_body(const ::std::string& value);
  #if LANG_CXX11
  void set_body(::std::string&& value);
  #endif
  void set_body(const char* value);
  void set_body(const void* value, size_t size);
  ::std::string* mutable_body();
  ::std::string* release_body();
  void set_allocated_body(::std::string* body);

  // @@protoc_insertion_point(class_scope:cyberprobe.SmtpData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> to_;
  ::google::protobuf::internal::ArenaStringPtr from_;
  ::google::protobuf::internal::ArenaStringPtr body_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Gre : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.Gre) */ {
 public:
  Gre();
  virtual ~Gre();

  Gre(const Gre& from);

  inline Gre& operator=(const Gre& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Gre(Gre&& from) noexcept
    : Gre() {
    *this = ::std::move(from);
  }

  inline Gre& operator=(Gre&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Gre& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Gre* internal_default_instance() {
    return reinterpret_cast<const Gre*>(
               &_Gre_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(Gre* other);
  friend void swap(Gre& a, Gre& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Gre* New() const final {
    return CreateMaybeMessage<Gre>(NULL);
  }

  Gre* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Gre>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Gre& from);
  void MergeFrom(const Gre& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Gre* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string next_proto = 1;
  void clear_next_proto();
  static const int kNextProtoFieldNumber = 1;
  const ::std::string& next_proto() const;
  void set_next_proto(const ::std::string& value);
  #if LANG_CXX11
  void set_next_proto(::std::string&& value);
  #endif
  void set_next_proto(const char* value);
  void set_next_proto(const char* value, size_t size);
  ::std::string* mutable_next_proto();
  ::std::string* release_next_proto();
  void set_allocated_next_proto(::std::string* next_proto);

  // bytes payload = 4;
  void clear_payload();
  static const int kPayloadFieldNumber = 4;
  const ::std::string& payload() const;
  void set_payload(const ::std::string& value);
  #if LANG_CXX11
  void set_payload(::std::string&& value);
  #endif
  void set_payload(const char* value);
  void set_payload(const void* value, size_t size);
  ::std::string* mutable_payload();
  ::std::string* release_payload();
  void set_allocated_payload(::std::string* payload);

  // uint32 key = 2;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  ::google::protobuf::uint32 key() const;
  void set_key(::google::protobuf::uint32 value);

  // uint32 sequence_number = 3;
  void clear_sequence_number();
  static const int kSequenceNumberFieldNumber = 3;
  ::google::protobuf::uint32 sequence_number() const;
  void set_sequence_number(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:cyberprobe.Gre)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr next_proto_;
  ::google::protobuf::internal::ArenaStringPtr payload_;
  ::google::protobuf::uint32 key_;
  ::google::protobuf::uint32 sequence_number_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GrePptp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.GrePptp) */ {
 public:
  GrePptp();
  virtual ~GrePptp();

  GrePptp(const GrePptp& from);

  inline GrePptp& operator=(const GrePptp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GrePptp(GrePptp&& from) noexcept
    : GrePptp() {
    *this = ::std::move(from);
  }

  inline GrePptp& operator=(GrePptp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GrePptp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GrePptp* internal_default_instance() {
    return reinterpret_cast<const GrePptp*>(
               &_GrePptp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(GrePptp* other);
  friend void swap(GrePptp& a, GrePptp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GrePptp* New() const final {
    return CreateMaybeMessage<GrePptp>(NULL);
  }

  GrePptp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GrePptp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GrePptp& from);
  void MergeFrom(const GrePptp& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GrePptp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string next_proto = 1;
  void clear_next_proto();
  static const int kNextProtoFieldNumber = 1;
  const ::std::string& next_proto() const;
  void set_next_proto(const ::std::string& value);
  #if LANG_CXX11
  void set_next_proto(::std::string&& value);
  #endif
  void set_next_proto(const char* value);
  void set_next_proto(const char* value, size_t size);
  ::std::string* mutable_next_proto();
  ::std::string* release_next_proto();
  void set_allocated_next_proto(::std::string* next_proto);

  // bytes payload = 5;
  void clear_payload();
  static const int kPayloadFieldNumber = 5;
  const ::std::string& payload() const;
  void set_payload(const ::std::string& value);
  #if LANG_CXX11
  void set_payload(::std::string&& value);
  #endif
  void set_payload(const char* value);
  void set_payload(const void* value, size_t size);
  ::std::string* mutable_payload();
  ::std::string* release_payload();
  void set_allocated_payload(::std::string* payload);

  // uint32 call_id = 2;
  void clear_call_id();
  static const int kCallIdFieldNumber = 2;
  ::google::protobuf::uint32 call_id() const;
  void set_call_id(::google::protobuf::uint32 value);

  // uint32 sequence_number = 3;
  void clear_sequence_number();
  static const int kSequenceNumberFieldNumber = 3;
  ::google::protobuf::uint32 sequence_number() const;
  void set_sequence_number(::google::protobuf::uint32 value);

  // uint32 acknowledgement_number = 4;
  void clear_acknowledgement_number();
  static const int kAcknowledgementNumberFieldNumber = 4;
  ::google::protobuf::uint32 acknowledgement_number() const;
  void set_acknowledgement_number(::google::protobuf::uint32 value);

  // uint32 payload_length = 6;
  void clear_payload_length();
  static const int kPayloadLengthFieldNumber = 6;
  ::google::protobuf::uint32 payload_length() const;
  void set_payload_length(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:cyberprobe.GrePptp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr next_proto_;
  ::google::protobuf::internal::ArenaStringPtr payload_;
  ::google::protobuf::uint32 call_id_;
  ::google::protobuf::uint32 sequence_number_;
  ::google::protobuf::uint32 acknowledgement_number_;
  ::google::protobuf::uint32 payload_length_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Esp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.Esp) */ {
 public:
  Esp();
  virtual ~Esp();

  Esp(const Esp& from);

  inline Esp& operator=(const Esp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Esp(Esp&& from) noexcept
    : Esp() {
    *this = ::std::move(from);
  }

  inline Esp& operator=(Esp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Esp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Esp* internal_default_instance() {
    return reinterpret_cast<const Esp*>(
               &_Esp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(Esp* other);
  friend void swap(Esp& a, Esp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Esp* New() const final {
    return CreateMaybeMessage<Esp>(NULL);
  }

  Esp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Esp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Esp& from);
  void MergeFrom(const Esp& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Esp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes payload = 3;
  void clear_payload();
  static const int kPayloadFieldNumber = 3;
  const ::std::string& payload() const;
  void set_payload(const ::std::string& value);
  #if LANG_CXX11
  void set_payload(::std::string&& value);
  #endif
  void set_payload(const char* value);
  void set_payload(const void* value, size_t size);
  ::std::string* mutable_payload();
  ::std::string* release_payload();
  void set_allocated_payload(::std::string* payload);

  // uint32 spi = 1;
  void clear_spi();
  static const int kSpiFieldNumber = 1;
  ::google::protobuf::uint32 spi() const;
  void set_spi(::google::protobuf::uint32 value);

  // uint32 sequence_number = 2;
  void clear_sequence_number();
  static const int kSequenceNumberFieldNumber = 2;
  ::google::protobuf::uint32 sequence_number() const;
  void set_sequence_number(::google::protobuf::uint32 value);

  // uint32 payload_length = 4;
  void clear_payload_length();
  static const int kPayloadLengthFieldNumber = 4;
  ::google::protobuf::uint32 payload_length() const;
  void set_payload_length(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:cyberprobe.Esp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr payload_;
  ::google::protobuf::uint32 spi_;
  ::google::protobuf::uint32 sequence_number_;
  ::google::protobuf::uint32 payload_length_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UnrecognisedIpProtocol : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.UnrecognisedIpProtocol) */ {
 public:
  UnrecognisedIpProtocol();
  virtual ~UnrecognisedIpProtocol();

  UnrecognisedIpProtocol(const UnrecognisedIpProtocol& from);

  inline UnrecognisedIpProtocol& operator=(const UnrecognisedIpProtocol& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnrecognisedIpProtocol(UnrecognisedIpProtocol&& from) noexcept
    : UnrecognisedIpProtocol() {
    *this = ::std::move(from);
  }

  inline UnrecognisedIpProtocol& operator=(UnrecognisedIpProtocol&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UnrecognisedIpProtocol& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnrecognisedIpProtocol* internal_default_instance() {
    return reinterpret_cast<const UnrecognisedIpProtocol*>(
               &_UnrecognisedIpProtocol_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(UnrecognisedIpProtocol* other);
  friend void swap(UnrecognisedIpProtocol& a, UnrecognisedIpProtocol& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnrecognisedIpProtocol* New() const final {
    return CreateMaybeMessage<UnrecognisedIpProtocol>(NULL);
  }

  UnrecognisedIpProtocol* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UnrecognisedIpProtocol>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UnrecognisedIpProtocol& from);
  void MergeFrom(const UnrecognisedIpProtocol& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnrecognisedIpProtocol* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes payload = 3;
  void clear_payload();
  static const int kPayloadFieldNumber = 3;
  const ::std::string& payload() const;
  void set_payload(const ::std::string& value);
  #if LANG_CXX11
  void set_payload(::std::string&& value);
  #endif
  void set_payload(const char* value);
  void set_payload(const void* value, size_t size);
  ::std::string* mutable_payload();
  ::std::string* release_payload();
  void set_allocated_payload(::std::string* payload);

  // uint32 next_proto = 1;
  void clear_next_proto();
  static const int kNextProtoFieldNumber = 1;
  ::google::protobuf::uint32 next_proto() const;
  void set_next_proto(::google::protobuf::uint32 value);

  // uint32 sequence_number = 2;
  void clear_sequence_number();
  static const int kSequenceNumberFieldNumber = 2;
  ::google::protobuf::uint32 sequence_number() const;
  void set_sequence_number(::google::protobuf::uint32 value);

  // uint32 payload_length = 4;
  void clear_payload_length();
  static const int kPayloadLengthFieldNumber = 4;
  ::google::protobuf::uint32 payload_length() const;
  void set_payload_length(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:cyberprobe.UnrecognisedIpProtocol)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr payload_;
  ::google::protobuf::uint32 next_proto_;
  ::google::protobuf::uint32 sequence_number_;
  ::google::protobuf::uint32 payload_length_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Wlan : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.Wlan) */ {
 public:
  Wlan();
  virtual ~Wlan();

  Wlan(const Wlan& from);

  inline Wlan& operator=(const Wlan& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Wlan(Wlan&& from) noexcept
    : Wlan() {
    *this = ::std::move(from);
  }

  inline Wlan& operator=(Wlan&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Wlan& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Wlan* internal_default_instance() {
    return reinterpret_cast<const Wlan*>(
               &_Wlan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(Wlan* other);
  friend void swap(Wlan& a, Wlan& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Wlan* New() const final {
    return CreateMaybeMessage<Wlan>(NULL);
  }

  Wlan* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Wlan>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Wlan& from);
  void MergeFrom(const Wlan& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Wlan* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string filt_addr = 6;
  void clear_filt_addr();
  static const int kFiltAddrFieldNumber = 6;
  const ::std::string& filt_addr() const;
  void set_filt_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_filt_addr(::std::string&& value);
  #endif
  void set_filt_addr(const char* value);
  void set_filt_addr(const char* value, size_t size);
  ::std::string* mutable_filt_addr();
  ::std::string* release_filt_addr();
  void set_allocated_filt_addr(::std::string* filt_addr);

  // uint32 version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // uint32 type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // uint32 subtype = 3;
  void clear_subtype();
  static const int kSubtypeFieldNumber = 3;
  ::google::protobuf::uint32 subtype() const;
  void set_subtype(::google::protobuf::uint32 value);

  // uint32 flags = 4;
  void clear_flags();
  static const int kFlagsFieldNumber = 4;
  ::google::protobuf::uint32 flags() const;
  void set_flags(::google::protobuf::uint32 value);

  // bool protected = 5;
  void clear_protected_();
  static const int kProtectedFieldNumber = 5;
  bool protected_() const;
  void set_protected_(bool value);

  // uint32 frag_num = 7;
  void clear_frag_num();
  static const int kFragNumFieldNumber = 7;
  ::google::protobuf::uint32 frag_num() const;
  void set_frag_num(::google::protobuf::uint32 value);

  // uint32 seq_num = 8;
  void clear_seq_num();
  static const int kSeqNumFieldNumber = 8;
  ::google::protobuf::uint32 seq_num() const;
  void set_seq_num(::google::protobuf::uint32 value);

  // uint32 duration = 9;
  void clear_duration();
  static const int kDurationFieldNumber = 9;
  ::google::protobuf::uint32 duration() const;
  void set_duration(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:cyberprobe.Wlan)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr filt_addr_;
  ::google::protobuf::uint32 version_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 subtype_;
  ::google::protobuf::uint32 flags_;
  bool protected__;
  ::google::protobuf::uint32 frag_num_;
  ::google::protobuf::uint32 seq_num_;
  ::google::protobuf::uint32 duration_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TlsUnknown_Tls : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.TlsUnknown.Tls) */ {
 public:
  TlsUnknown_Tls();
  virtual ~TlsUnknown_Tls();

  TlsUnknown_Tls(const TlsUnknown_Tls& from);

  inline TlsUnknown_Tls& operator=(const TlsUnknown_Tls& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TlsUnknown_Tls(TlsUnknown_Tls&& from) noexcept
    : TlsUnknown_Tls() {
    *this = ::std::move(from);
  }

  inline TlsUnknown_Tls& operator=(TlsUnknown_Tls&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TlsUnknown_Tls& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TlsUnknown_Tls* internal_default_instance() {
    return reinterpret_cast<const TlsUnknown_Tls*>(
               &_TlsUnknown_Tls_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(TlsUnknown_Tls* other);
  friend void swap(TlsUnknown_Tls& a, TlsUnknown_Tls& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TlsUnknown_Tls* New() const final {
    return CreateMaybeMessage<TlsUnknown_Tls>(NULL);
  }

  TlsUnknown_Tls* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TlsUnknown_Tls>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TlsUnknown_Tls& from);
  void MergeFrom(const TlsUnknown_Tls& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TlsUnknown_Tls* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // uint32 content_type = 2;
  void clear_content_type();
  static const int kContentTypeFieldNumber = 2;
  ::google::protobuf::uint32 content_type() const;
  void set_content_type(::google::protobuf::uint32 value);

  // uint64 length = 3;
  void clear_length();
  static const int kLengthFieldNumber = 3;
  ::google::protobuf::uint64 length() const;
  void set_length(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:cyberprobe.TlsUnknown.Tls)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 version_;
  ::google::protobuf::uint32 content_type_;
  ::google::protobuf::uint64 length_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TlsUnknown : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.TlsUnknown) */ {
 public:
  TlsUnknown();
  virtual ~TlsUnknown();

  TlsUnknown(const TlsUnknown& from);

  inline TlsUnknown& operator=(const TlsUnknown& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TlsUnknown(TlsUnknown&& from) noexcept
    : TlsUnknown() {
    *this = ::std::move(from);
  }

  inline TlsUnknown& operator=(TlsUnknown&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TlsUnknown& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TlsUnknown* internal_default_instance() {
    return reinterpret_cast<const TlsUnknown*>(
               &_TlsUnknown_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(TlsUnknown* other);
  friend void swap(TlsUnknown& a, TlsUnknown& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TlsUnknown* New() const final {
    return CreateMaybeMessage<TlsUnknown>(NULL);
  }

  TlsUnknown* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TlsUnknown>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TlsUnknown& from);
  void MergeFrom(const TlsUnknown& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TlsUnknown* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TlsUnknown_Tls Tls;

  // accessors -------------------------------------------------------

  // .cyberprobe.TlsUnknown.Tls tls = 1;
  bool has_tls() const;
  void clear_tls();
  static const int kTlsFieldNumber = 1;
  private:
  const ::cyberprobe::TlsUnknown_Tls& _internal_tls() const;
  public:
  const ::cyberprobe::TlsUnknown_Tls& tls() const;
  ::cyberprobe::TlsUnknown_Tls* release_tls();
  ::cyberprobe::TlsUnknown_Tls* mutable_tls();
  void set_allocated_tls(::cyberprobe::TlsUnknown_Tls* tls);

  // @@protoc_insertion_point(class_scope:cyberprobe.TlsUnknown)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cyberprobe::TlsUnknown_Tls* tls_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TlsClientHello_Tls_Random : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.TlsClientHello.Tls.Random) */ {
 public:
  TlsClientHello_Tls_Random();
  virtual ~TlsClientHello_Tls_Random();

  TlsClientHello_Tls_Random(const TlsClientHello_Tls_Random& from);

  inline TlsClientHello_Tls_Random& operator=(const TlsClientHello_Tls_Random& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TlsClientHello_Tls_Random(TlsClientHello_Tls_Random&& from) noexcept
    : TlsClientHello_Tls_Random() {
    *this = ::std::move(from);
  }

  inline TlsClientHello_Tls_Random& operator=(TlsClientHello_Tls_Random&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TlsClientHello_Tls_Random& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TlsClientHello_Tls_Random* internal_default_instance() {
    return reinterpret_cast<const TlsClientHello_Tls_Random*>(
               &_TlsClientHello_Tls_Random_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(TlsClientHello_Tls_Random* other);
  friend void swap(TlsClientHello_Tls_Random& a, TlsClientHello_Tls_Random& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TlsClientHello_Tls_Random* New() const final {
    return CreateMaybeMessage<TlsClientHello_Tls_Random>(NULL);
  }

  TlsClientHello_Tls_Random* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TlsClientHello_Tls_Random>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TlsClientHello_Tls_Random& from);
  void MergeFrom(const TlsClientHello_Tls_Random& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TlsClientHello_Tls_Random* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes data = 2;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // uint64 timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:cyberprobe.TlsClientHello.Tls.Random)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::uint64 timestamp_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TlsClientHello_Tls_Extension : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.TlsClientHello.Tls.Extension) */ {
 public:
  TlsClientHello_Tls_Extension();
  virtual ~TlsClientHello_Tls_Extension();

  TlsClientHello_Tls_Extension(const TlsClientHello_Tls_Extension& from);

  inline TlsClientHello_Tls_Extension& operator=(const TlsClientHello_Tls_Extension& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TlsClientHello_Tls_Extension(TlsClientHello_Tls_Extension&& from) noexcept
    : TlsClientHello_Tls_Extension() {
    *this = ::std::move(from);
  }

  inline TlsClientHello_Tls_Extension& operator=(TlsClientHello_Tls_Extension&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TlsClientHello_Tls_Extension& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TlsClientHello_Tls_Extension* internal_default_instance() {
    return reinterpret_cast<const TlsClientHello_Tls_Extension*>(
               &_TlsClientHello_Tls_Extension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(TlsClientHello_Tls_Extension* other);
  friend void swap(TlsClientHello_Tls_Extension& a, TlsClientHello_Tls_Extension& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TlsClientHello_Tls_Extension* New() const final {
    return CreateMaybeMessage<TlsClientHello_Tls_Extension>(NULL);
  }

  TlsClientHello_Tls_Extension* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TlsClientHello_Tls_Extension>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TlsClientHello_Tls_Extension& from);
  void MergeFrom(const TlsClientHello_Tls_Extension& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TlsClientHello_Tls_Extension* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // bytes data = 3;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // uint32 length = 2;
  void clear_length();
  static const int kLengthFieldNumber = 2;
  ::google::protobuf::uint32 length() const;
  void set_length(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:cyberprobe.TlsClientHello.Tls.Extension)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::uint32 length_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TlsClientHello_Tls : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.TlsClientHello.Tls) */ {
 public:
  TlsClientHello_Tls();
  virtual ~TlsClientHello_Tls();

  TlsClientHello_Tls(const TlsClientHello_Tls& from);

  inline TlsClientHello_Tls& operator=(const TlsClientHello_Tls& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TlsClientHello_Tls(TlsClientHello_Tls&& from) noexcept
    : TlsClientHello_Tls() {
    *this = ::std::move(from);
  }

  inline TlsClientHello_Tls& operator=(TlsClientHello_Tls&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TlsClientHello_Tls& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TlsClientHello_Tls* internal_default_instance() {
    return reinterpret_cast<const TlsClientHello_Tls*>(
               &_TlsClientHello_Tls_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(TlsClientHello_Tls* other);
  friend void swap(TlsClientHello_Tls& a, TlsClientHello_Tls& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TlsClientHello_Tls* New() const final {
    return CreateMaybeMessage<TlsClientHello_Tls>(NULL);
  }

  TlsClientHello_Tls* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TlsClientHello_Tls>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TlsClientHello_Tls& from);
  void MergeFrom(const TlsClientHello_Tls& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TlsClientHello_Tls* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TlsClientHello_Tls_Random Random;
  typedef TlsClientHello_Tls_Extension Extension;

  // accessors -------------------------------------------------------

  // repeated string cipher_suites = 4;
  int cipher_suites_size() const;
  void clear_cipher_suites();
  static const int kCipherSuitesFieldNumber = 4;
  const ::std::string& cipher_suites(int index) const;
  ::std::string* mutable_cipher_suites(int index);
  void set_cipher_suites(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_cipher_suites(int index, ::std::string&& value);
  #endif
  void set_cipher_suites(int index, const char* value);
  void set_cipher_suites(int index, const char* value, size_t size);
  ::std::string* add_cipher_suites();
  void add_cipher_suites(const ::std::string& value);
  #if LANG_CXX11
  void add_cipher_suites(::std::string&& value);
  #endif
  void add_cipher_suites(const char* value);
  void add_cipher_suites(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& cipher_suites() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_cipher_suites();

  // repeated string compression_methods = 5;
  int compression_methods_size() const;
  void clear_compression_methods();
  static const int kCompressionMethodsFieldNumber = 5;
  const ::std::string& compression_methods(int index) const;
  ::std::string* mutable_compression_methods(int index);
  void set_compression_methods(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_compression_methods(int index, ::std::string&& value);
  #endif
  void set_compression_methods(int index, const char* value);
  void set_compression_methods(int index, const char* value, size_t size);
  ::std::string* add_compression_methods();
  void add_compression_methods(const ::std::string& value);
  #if LANG_CXX11
  void add_compression_methods(::std::string&& value);
  #endif
  void add_compression_methods(const char* value);
  void add_compression_methods(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& compression_methods() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_compression_methods();

  // repeated .cyberprobe.TlsClientHello.Tls.Extension extensions = 6;
  int extensions_size() const;
  void clear_extensions();
  static const int kExtensionsFieldNumber = 6;
  ::cyberprobe::TlsClientHello_Tls_Extension* mutable_extensions(int index);
  ::google::protobuf::RepeatedPtrField< ::cyberprobe::TlsClientHello_Tls_Extension >*
      mutable_extensions();
  const ::cyberprobe::TlsClientHello_Tls_Extension& extensions(int index) const;
  ::cyberprobe::TlsClientHello_Tls_Extension* add_extensions();
  const ::google::protobuf::RepeatedPtrField< ::cyberprobe::TlsClientHello_Tls_Extension >&
      extensions() const;

  // .cyberprobe.TlsClientHello.Tls.Random random = 3;
  bool has_random() const;
  void clear_random();
  static const int kRandomFieldNumber = 3;
  private:
  const ::cyberprobe::TlsClientHello_Tls_Random& _internal_random() const;
  public:
  const ::cyberprobe::TlsClientHello_Tls_Random& random() const;
  ::cyberprobe::TlsClientHello_Tls_Random* release_random();
  ::cyberprobe::TlsClientHello_Tls_Random* mutable_random();
  void set_allocated_random(::cyberprobe::TlsClientHello_Tls_Random* random);

  // uint64 session_id = 2;
  void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  ::google::protobuf::uint64 session_id() const;
  void set_session_id(::google::protobuf::uint64 value);

  // uint32 version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:cyberprobe.TlsClientHello.Tls)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> cipher_suites_;
  ::google::protobuf::RepeatedPtrField< ::std::string> compression_methods_;
  ::google::protobuf::RepeatedPtrField< ::cyberprobe::TlsClientHello_Tls_Extension > extensions_;
  ::cyberprobe::TlsClientHello_Tls_Random* random_;
  ::google::protobuf::uint64 session_id_;
  ::google::protobuf::uint32 version_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TlsClientHello : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.TlsClientHello) */ {
 public:
  TlsClientHello();
  virtual ~TlsClientHello();

  TlsClientHello(const TlsClientHello& from);

  inline TlsClientHello& operator=(const TlsClientHello& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TlsClientHello(TlsClientHello&& from) noexcept
    : TlsClientHello() {
    *this = ::std::move(from);
  }

  inline TlsClientHello& operator=(TlsClientHello&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TlsClientHello& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TlsClientHello* internal_default_instance() {
    return reinterpret_cast<const TlsClientHello*>(
               &_TlsClientHello_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(TlsClientHello* other);
  friend void swap(TlsClientHello& a, TlsClientHello& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TlsClientHello* New() const final {
    return CreateMaybeMessage<TlsClientHello>(NULL);
  }

  TlsClientHello* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TlsClientHello>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TlsClientHello& from);
  void MergeFrom(const TlsClientHello& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TlsClientHello* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TlsClientHello_Tls Tls;

  // accessors -------------------------------------------------------

  // .cyberprobe.TlsClientHello.Tls tls = 1;
  bool has_tls() const;
  void clear_tls();
  static const int kTlsFieldNumber = 1;
  private:
  const ::cyberprobe::TlsClientHello_Tls& _internal_tls() const;
  public:
  const ::cyberprobe::TlsClientHello_Tls& tls() const;
  ::cyberprobe::TlsClientHello_Tls* release_tls();
  ::cyberprobe::TlsClientHello_Tls* mutable_tls();
  void set_allocated_tls(::cyberprobe::TlsClientHello_Tls* tls);

  // @@protoc_insertion_point(class_scope:cyberprobe.TlsClientHello)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cyberprobe::TlsClientHello_Tls* tls_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TlsServerHello_Tls_Random : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.TlsServerHello.Tls.Random) */ {
 public:
  TlsServerHello_Tls_Random();
  virtual ~TlsServerHello_Tls_Random();

  TlsServerHello_Tls_Random(const TlsServerHello_Tls_Random& from);

  inline TlsServerHello_Tls_Random& operator=(const TlsServerHello_Tls_Random& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TlsServerHello_Tls_Random(TlsServerHello_Tls_Random&& from) noexcept
    : TlsServerHello_Tls_Random() {
    *this = ::std::move(from);
  }

  inline TlsServerHello_Tls_Random& operator=(TlsServerHello_Tls_Random&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TlsServerHello_Tls_Random& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TlsServerHello_Tls_Random* internal_default_instance() {
    return reinterpret_cast<const TlsServerHello_Tls_Random*>(
               &_TlsServerHello_Tls_Random_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(TlsServerHello_Tls_Random* other);
  friend void swap(TlsServerHello_Tls_Random& a, TlsServerHello_Tls_Random& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TlsServerHello_Tls_Random* New() const final {
    return CreateMaybeMessage<TlsServerHello_Tls_Random>(NULL);
  }

  TlsServerHello_Tls_Random* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TlsServerHello_Tls_Random>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TlsServerHello_Tls_Random& from);
  void MergeFrom(const TlsServerHello_Tls_Random& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TlsServerHello_Tls_Random* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes data = 2;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // uint64 timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:cyberprobe.TlsServerHello.Tls.Random)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::uint64 timestamp_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TlsServerHello_Tls_Extension : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.TlsServerHello.Tls.Extension) */ {
 public:
  TlsServerHello_Tls_Extension();
  virtual ~TlsServerHello_Tls_Extension();

  TlsServerHello_Tls_Extension(const TlsServerHello_Tls_Extension& from);

  inline TlsServerHello_Tls_Extension& operator=(const TlsServerHello_Tls_Extension& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TlsServerHello_Tls_Extension(TlsServerHello_Tls_Extension&& from) noexcept
    : TlsServerHello_Tls_Extension() {
    *this = ::std::move(from);
  }

  inline TlsServerHello_Tls_Extension& operator=(TlsServerHello_Tls_Extension&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TlsServerHello_Tls_Extension& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TlsServerHello_Tls_Extension* internal_default_instance() {
    return reinterpret_cast<const TlsServerHello_Tls_Extension*>(
               &_TlsServerHello_Tls_Extension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  void Swap(TlsServerHello_Tls_Extension* other);
  friend void swap(TlsServerHello_Tls_Extension& a, TlsServerHello_Tls_Extension& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TlsServerHello_Tls_Extension* New() const final {
    return CreateMaybeMessage<TlsServerHello_Tls_Extension>(NULL);
  }

  TlsServerHello_Tls_Extension* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TlsServerHello_Tls_Extension>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TlsServerHello_Tls_Extension& from);
  void MergeFrom(const TlsServerHello_Tls_Extension& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TlsServerHello_Tls_Extension* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // bytes data = 3;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // uint32 length = 2;
  void clear_length();
  static const int kLengthFieldNumber = 2;
  ::google::protobuf::uint32 length() const;
  void set_length(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:cyberprobe.TlsServerHello.Tls.Extension)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::uint32 length_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TlsServerHello_Tls : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.TlsServerHello.Tls) */ {
 public:
  TlsServerHello_Tls();
  virtual ~TlsServerHello_Tls();

  TlsServerHello_Tls(const TlsServerHello_Tls& from);

  inline TlsServerHello_Tls& operator=(const TlsServerHello_Tls& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TlsServerHello_Tls(TlsServerHello_Tls&& from) noexcept
    : TlsServerHello_Tls() {
    *this = ::std::move(from);
  }

  inline TlsServerHello_Tls& operator=(TlsServerHello_Tls&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TlsServerHello_Tls& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TlsServerHello_Tls* internal_default_instance() {
    return reinterpret_cast<const TlsServerHello_Tls*>(
               &_TlsServerHello_Tls_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  void Swap(TlsServerHello_Tls* other);
  friend void swap(TlsServerHello_Tls& a, TlsServerHello_Tls& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TlsServerHello_Tls* New() const final {
    return CreateMaybeMessage<TlsServerHello_Tls>(NULL);
  }

  TlsServerHello_Tls* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TlsServerHello_Tls>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TlsServerHello_Tls& from);
  void MergeFrom(const TlsServerHello_Tls& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TlsServerHello_Tls* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TlsServerHello_Tls_Random Random;
  typedef TlsServerHello_Tls_Extension Extension;

  // accessors -------------------------------------------------------

  // repeated .cyberprobe.TlsServerHello.Tls.Extension extensions = 6;
  int extensions_size() const;
  void clear_extensions();
  static const int kExtensionsFieldNumber = 6;
  ::cyberprobe::TlsServerHello_Tls_Extension* mutable_extensions(int index);
  ::google::protobuf::RepeatedPtrField< ::cyberprobe::TlsServerHello_Tls_Extension >*
      mutable_extensions();
  const ::cyberprobe::TlsServerHello_Tls_Extension& extensions(int index) const;
  ::cyberprobe::TlsServerHello_Tls_Extension* add_extensions();
  const ::google::protobuf::RepeatedPtrField< ::cyberprobe::TlsServerHello_Tls_Extension >&
      extensions() const;

  // string cipher_suite = 4;
  void clear_cipher_suite();
  static const int kCipherSuiteFieldNumber = 4;
  const ::std::string& cipher_suite() const;
  void set_cipher_suite(const ::std::string& value);
  #if LANG_CXX11
  void set_cipher_suite(::std::string&& value);
  #endif
  void set_cipher_suite(const char* value);
  void set_cipher_suite(const char* value, size_t size);
  ::std::string* mutable_cipher_suite();
  ::std::string* release_cipher_suite();
  void set_allocated_cipher_suite(::std::string* cipher_suite);

  // string compression_method = 5;
  void clear_compression_method();
  static const int kCompressionMethodFieldNumber = 5;
  const ::std::string& compression_method() const;
  void set_compression_method(const ::std::string& value);
  #if LANG_CXX11
  void set_compression_method(::std::string&& value);
  #endif
  void set_compression_method(const char* value);
  void set_compression_method(const char* value, size_t size);
  ::std::string* mutable_compression_method();
  ::std::string* release_compression_method();
  void set_allocated_compression_method(::std::string* compression_method);

  // .cyberprobe.TlsServerHello.Tls.Random random = 3;
  bool has_random() const;
  void clear_random();
  static const int kRandomFieldNumber = 3;
  private:
  const ::cyberprobe::TlsServerHello_Tls_Random& _internal_random() const;
  public:
  const ::cyberprobe::TlsServerHello_Tls_Random& random() const;
  ::cyberprobe::TlsServerHello_Tls_Random* release_random();
  ::cyberprobe::TlsServerHello_Tls_Random* mutable_random();
  void set_allocated_random(::cyberprobe::TlsServerHello_Tls_Random* random);

  // uint64 session_id = 2;
  void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  ::google::protobuf::uint64 session_id() const;
  void set_session_id(::google::protobuf::uint64 value);

  // uint32 version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:cyberprobe.TlsServerHello.Tls)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::cyberprobe::TlsServerHello_Tls_Extension > extensions_;
  ::google::protobuf::internal::ArenaStringPtr cipher_suite_;
  ::google::protobuf::internal::ArenaStringPtr compression_method_;
  ::cyberprobe::TlsServerHello_Tls_Random* random_;
  ::google::protobuf::uint64 session_id_;
  ::google::protobuf::uint32 version_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TlsServerHello : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.TlsServerHello) */ {
 public:
  TlsServerHello();
  virtual ~TlsServerHello();

  TlsServerHello(const TlsServerHello& from);

  inline TlsServerHello& operator=(const TlsServerHello& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TlsServerHello(TlsServerHello&& from) noexcept
    : TlsServerHello() {
    *this = ::std::move(from);
  }

  inline TlsServerHello& operator=(TlsServerHello&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TlsServerHello& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TlsServerHello* internal_default_instance() {
    return reinterpret_cast<const TlsServerHello*>(
               &_TlsServerHello_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  void Swap(TlsServerHello* other);
  friend void swap(TlsServerHello& a, TlsServerHello& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TlsServerHello* New() const final {
    return CreateMaybeMessage<TlsServerHello>(NULL);
  }

  TlsServerHello* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TlsServerHello>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TlsServerHello& from);
  void MergeFrom(const TlsServerHello& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TlsServerHello* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TlsServerHello_Tls Tls;

  // accessors -------------------------------------------------------

  // .cyberprobe.TlsServerHello.Tls tls = 1;
  bool has_tls() const;
  void clear_tls();
  static const int kTlsFieldNumber = 1;
  private:
  const ::cyberprobe::TlsServerHello_Tls& _internal_tls() const;
  public:
  const ::cyberprobe::TlsServerHello_Tls& tls() const;
  ::cyberprobe::TlsServerHello_Tls* release_tls();
  ::cyberprobe::TlsServerHello_Tls* mutable_tls();
  void set_allocated_tls(::cyberprobe::TlsServerHello_Tls* tls);

  // @@protoc_insertion_point(class_scope:cyberprobe.TlsServerHello)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cyberprobe::TlsServerHello_Tls* tls_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TlsCertificates_Tls : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.TlsCertificates.Tls) */ {
 public:
  TlsCertificates_Tls();
  virtual ~TlsCertificates_Tls();

  TlsCertificates_Tls(const TlsCertificates_Tls& from);

  inline TlsCertificates_Tls& operator=(const TlsCertificates_Tls& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TlsCertificates_Tls(TlsCertificates_Tls&& from) noexcept
    : TlsCertificates_Tls() {
    *this = ::std::move(from);
  }

  inline TlsCertificates_Tls& operator=(TlsCertificates_Tls&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TlsCertificates_Tls& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TlsCertificates_Tls* internal_default_instance() {
    return reinterpret_cast<const TlsCertificates_Tls*>(
               &_TlsCertificates_Tls_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  void Swap(TlsCertificates_Tls* other);
  friend void swap(TlsCertificates_Tls& a, TlsCertificates_Tls& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TlsCertificates_Tls* New() const final {
    return CreateMaybeMessage<TlsCertificates_Tls>(NULL);
  }

  TlsCertificates_Tls* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TlsCertificates_Tls>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TlsCertificates_Tls& from);
  void MergeFrom(const TlsCertificates_Tls& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TlsCertificates_Tls* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes certificates = 1;
  int certificates_size() const;
  void clear_certificates();
  static const int kCertificatesFieldNumber = 1;
  const ::std::string& certificates(int index) const;
  ::std::string* mutable_certificates(int index);
  void set_certificates(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_certificates(int index, ::std::string&& value);
  #endif
  void set_certificates(int index, const char* value);
  void set_certificates(int index, const void* value, size_t size);
  ::std::string* add_certificates();
  void add_certificates(const ::std::string& value);
  #if LANG_CXX11
  void add_certificates(::std::string&& value);
  #endif
  void add_certificates(const char* value);
  void add_certificates(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& certificates() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_certificates();

  // @@protoc_insertion_point(class_scope:cyberprobe.TlsCertificates.Tls)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> certificates_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TlsCertificates : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.TlsCertificates) */ {
 public:
  TlsCertificates();
  virtual ~TlsCertificates();

  TlsCertificates(const TlsCertificates& from);

  inline TlsCertificates& operator=(const TlsCertificates& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TlsCertificates(TlsCertificates&& from) noexcept
    : TlsCertificates() {
    *this = ::std::move(from);
  }

  inline TlsCertificates& operator=(TlsCertificates&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TlsCertificates& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TlsCertificates* internal_default_instance() {
    return reinterpret_cast<const TlsCertificates*>(
               &_TlsCertificates_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  void Swap(TlsCertificates* other);
  friend void swap(TlsCertificates& a, TlsCertificates& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TlsCertificates* New() const final {
    return CreateMaybeMessage<TlsCertificates>(NULL);
  }

  TlsCertificates* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TlsCertificates>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TlsCertificates& from);
  void MergeFrom(const TlsCertificates& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TlsCertificates* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TlsCertificates_Tls Tls;

  // accessors -------------------------------------------------------

  // .cyberprobe.TlsCertificates.Tls tls = 1;
  bool has_tls() const;
  void clear_tls();
  static const int kTlsFieldNumber = 1;
  private:
  const ::cyberprobe::TlsCertificates_Tls& _internal_tls() const;
  public:
  const ::cyberprobe::TlsCertificates_Tls& tls() const;
  ::cyberprobe::TlsCertificates_Tls* release_tls();
  ::cyberprobe::TlsCertificates_Tls* mutable_tls();
  void set_allocated_tls(::cyberprobe::TlsCertificates_Tls* tls);

  // @@protoc_insertion_point(class_scope:cyberprobe.TlsCertificates)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cyberprobe::TlsCertificates_Tls* tls_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TlsServerKeyExchange_Tls_CurveMetadataEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<TlsServerKeyExchange_Tls_CurveMetadataEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<TlsServerKeyExchange_Tls_CurveMetadataEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  TlsServerKeyExchange_Tls_CurveMetadataEntry_DoNotUse();
  TlsServerKeyExchange_Tls_CurveMetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const TlsServerKeyExchange_Tls_CurveMetadataEntry_DoNotUse& other);
  static const TlsServerKeyExchange_Tls_CurveMetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TlsServerKeyExchange_Tls_CurveMetadataEntry_DoNotUse*>(&_TlsServerKeyExchange_Tls_CurveMetadataEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class TlsServerKeyExchange_Tls : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.TlsServerKeyExchange.Tls) */ {
 public:
  TlsServerKeyExchange_Tls();
  virtual ~TlsServerKeyExchange_Tls();

  TlsServerKeyExchange_Tls(const TlsServerKeyExchange_Tls& from);

  inline TlsServerKeyExchange_Tls& operator=(const TlsServerKeyExchange_Tls& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TlsServerKeyExchange_Tls(TlsServerKeyExchange_Tls&& from) noexcept
    : TlsServerKeyExchange_Tls() {
    *this = ::std::move(from);
  }

  inline TlsServerKeyExchange_Tls& operator=(TlsServerKeyExchange_Tls&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TlsServerKeyExchange_Tls& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TlsServerKeyExchange_Tls* internal_default_instance() {
    return reinterpret_cast<const TlsServerKeyExchange_Tls*>(
               &_TlsServerKeyExchange_Tls_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  void Swap(TlsServerKeyExchange_Tls* other);
  friend void swap(TlsServerKeyExchange_Tls& a, TlsServerKeyExchange_Tls& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TlsServerKeyExchange_Tls* New() const final {
    return CreateMaybeMessage<TlsServerKeyExchange_Tls>(NULL);
  }

  TlsServerKeyExchange_Tls* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TlsServerKeyExchange_Tls>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TlsServerKeyExchange_Tls& from);
  void MergeFrom(const TlsServerKeyExchange_Tls& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TlsServerKeyExchange_Tls* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> curve_metadata = 3;
  int curve_metadata_size() const;
  void clear_curve_metadata();
  static const int kCurveMetadataFieldNumber = 3;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      curve_metadata() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_curve_metadata();

  // string key_exchange_algorithm = 1;
  void clear_key_exchange_algorithm();
  static const int kKeyExchangeAlgorithmFieldNumber = 1;
  const ::std::string& key_exchange_algorithm() const;
  void set_key_exchange_algorithm(const ::std::string& value);
  #if LANG_CXX11
  void set_key_exchange_algorithm(::std::string&& value);
  #endif
  void set_key_exchange_algorithm(const char* value);
  void set_key_exchange_algorithm(const char* value, size_t size);
  ::std::string* mutable_key_exchange_algorithm();
  ::std::string* release_key_exchange_algorithm();
  void set_allocated_key_exchange_algorithm(::std::string* key_exchange_algorithm);

  // string curve_type_field = 2;
  void clear_curve_type_field();
  static const int kCurveTypeFieldFieldNumber = 2;
  const ::std::string& curve_type_field() const;
  void set_curve_type_field(const ::std::string& value);
  #if LANG_CXX11
  void set_curve_type_field(::std::string&& value);
  #endif
  void set_curve_type_field(const char* value);
  void set_curve_type_field(const char* value, size_t size);
  ::std::string* mutable_curve_type_field();
  ::std::string* release_curve_type_field();
  void set_allocated_curve_type_field(::std::string* curve_type_field);

  // string public_key = 4;
  void clear_public_key();
  static const int kPublicKeyFieldNumber = 4;
  const ::std::string& public_key() const;
  void set_public_key(const ::std::string& value);
  #if LANG_CXX11
  void set_public_key(::std::string&& value);
  #endif
  void set_public_key(const char* value);
  void set_public_key(const char* value, size_t size);
  ::std::string* mutable_public_key();
  ::std::string* release_public_key();
  void set_allocated_public_key(::std::string* public_key);

  // string signature_hash_algorithm = 5;
  void clear_signature_hash_algorithm();
  static const int kSignatureHashAlgorithmFieldNumber = 5;
  const ::std::string& signature_hash_algorithm() const;
  void set_signature_hash_algorithm(const ::std::string& value);
  #if LANG_CXX11
  void set_signature_hash_algorithm(::std::string&& value);
  #endif
  void set_signature_hash_algorithm(const char* value);
  void set_signature_hash_algorithm(const char* value, size_t size);
  ::std::string* mutable_signature_hash_algorithm();
  ::std::string* release_signature_hash_algorithm();
  void set_allocated_signature_hash_algorithm(::std::string* signature_hash_algorithm);

  // string signature_algorithm = 6;
  void clear_signature_algorithm();
  static const int kSignatureAlgorithmFieldNumber = 6;
  const ::std::string& signature_algorithm() const;
  void set_signature_algorithm(const ::std::string& value);
  #if LANG_CXX11
  void set_signature_algorithm(::std::string&& value);
  #endif
  void set_signature_algorithm(const char* value);
  void set_signature_algorithm(const char* value, size_t size);
  ::std::string* mutable_signature_algorithm();
  ::std::string* release_signature_algorithm();
  void set_allocated_signature_algorithm(::std::string* signature_algorithm);

  // string signature_hash = 7;
  void clear_signature_hash();
  static const int kSignatureHashFieldNumber = 7;
  const ::std::string& signature_hash() const;
  void set_signature_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_signature_hash(::std::string&& value);
  #endif
  void set_signature_hash(const char* value);
  void set_signature_hash(const char* value, size_t size);
  ::std::string* mutable_signature_hash();
  ::std::string* release_signature_hash();
  void set_allocated_signature_hash(::std::string* signature_hash);

  // @@protoc_insertion_point(class_scope:cyberprobe.TlsServerKeyExchange.Tls)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      TlsServerKeyExchange_Tls_CurveMetadataEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > curve_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_exchange_algorithm_;
  ::google::protobuf::internal::ArenaStringPtr curve_type_field_;
  ::google::protobuf::internal::ArenaStringPtr public_key_;
  ::google::protobuf::internal::ArenaStringPtr signature_hash_algorithm_;
  ::google::protobuf::internal::ArenaStringPtr signature_algorithm_;
  ::google::protobuf::internal::ArenaStringPtr signature_hash_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TlsServerKeyExchange : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.TlsServerKeyExchange) */ {
 public:
  TlsServerKeyExchange();
  virtual ~TlsServerKeyExchange();

  TlsServerKeyExchange(const TlsServerKeyExchange& from);

  inline TlsServerKeyExchange& operator=(const TlsServerKeyExchange& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TlsServerKeyExchange(TlsServerKeyExchange&& from) noexcept
    : TlsServerKeyExchange() {
    *this = ::std::move(from);
  }

  inline TlsServerKeyExchange& operator=(TlsServerKeyExchange&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TlsServerKeyExchange& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TlsServerKeyExchange* internal_default_instance() {
    return reinterpret_cast<const TlsServerKeyExchange*>(
               &_TlsServerKeyExchange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  void Swap(TlsServerKeyExchange* other);
  friend void swap(TlsServerKeyExchange& a, TlsServerKeyExchange& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TlsServerKeyExchange* New() const final {
    return CreateMaybeMessage<TlsServerKeyExchange>(NULL);
  }

  TlsServerKeyExchange* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TlsServerKeyExchange>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TlsServerKeyExchange& from);
  void MergeFrom(const TlsServerKeyExchange& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TlsServerKeyExchange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TlsServerKeyExchange_Tls Tls;

  // accessors -------------------------------------------------------

  // .cyberprobe.TlsServerKeyExchange.Tls tls = 1;
  bool has_tls() const;
  void clear_tls();
  static const int kTlsFieldNumber = 1;
  private:
  const ::cyberprobe::TlsServerKeyExchange_Tls& _internal_tls() const;
  public:
  const ::cyberprobe::TlsServerKeyExchange_Tls& tls() const;
  ::cyberprobe::TlsServerKeyExchange_Tls* release_tls();
  ::cyberprobe::TlsServerKeyExchange_Tls* mutable_tls();
  void set_allocated_tls(::cyberprobe::TlsServerKeyExchange_Tls* tls);

  // @@protoc_insertion_point(class_scope:cyberprobe.TlsServerKeyExchange)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cyberprobe::TlsServerKeyExchange_Tls* tls_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TlsServerHelloDone_Tls : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.TlsServerHelloDone.Tls) */ {
 public:
  TlsServerHelloDone_Tls();
  virtual ~TlsServerHelloDone_Tls();

  TlsServerHelloDone_Tls(const TlsServerHelloDone_Tls& from);

  inline TlsServerHelloDone_Tls& operator=(const TlsServerHelloDone_Tls& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TlsServerHelloDone_Tls(TlsServerHelloDone_Tls&& from) noexcept
    : TlsServerHelloDone_Tls() {
    *this = ::std::move(from);
  }

  inline TlsServerHelloDone_Tls& operator=(TlsServerHelloDone_Tls&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TlsServerHelloDone_Tls& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TlsServerHelloDone_Tls* internal_default_instance() {
    return reinterpret_cast<const TlsServerHelloDone_Tls*>(
               &_TlsServerHelloDone_Tls_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  void Swap(TlsServerHelloDone_Tls* other);
  friend void swap(TlsServerHelloDone_Tls& a, TlsServerHelloDone_Tls& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TlsServerHelloDone_Tls* New() const final {
    return CreateMaybeMessage<TlsServerHelloDone_Tls>(NULL);
  }

  TlsServerHelloDone_Tls* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TlsServerHelloDone_Tls>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TlsServerHelloDone_Tls& from);
  void MergeFrom(const TlsServerHelloDone_Tls& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TlsServerHelloDone_Tls* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cyberprobe.TlsServerHelloDone.Tls)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TlsServerHelloDone : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.TlsServerHelloDone) */ {
 public:
  TlsServerHelloDone();
  virtual ~TlsServerHelloDone();

  TlsServerHelloDone(const TlsServerHelloDone& from);

  inline TlsServerHelloDone& operator=(const TlsServerHelloDone& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TlsServerHelloDone(TlsServerHelloDone&& from) noexcept
    : TlsServerHelloDone() {
    *this = ::std::move(from);
  }

  inline TlsServerHelloDone& operator=(TlsServerHelloDone&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TlsServerHelloDone& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TlsServerHelloDone* internal_default_instance() {
    return reinterpret_cast<const TlsServerHelloDone*>(
               &_TlsServerHelloDone_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  void Swap(TlsServerHelloDone* other);
  friend void swap(TlsServerHelloDone& a, TlsServerHelloDone& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TlsServerHelloDone* New() const final {
    return CreateMaybeMessage<TlsServerHelloDone>(NULL);
  }

  TlsServerHelloDone* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TlsServerHelloDone>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TlsServerHelloDone& from);
  void MergeFrom(const TlsServerHelloDone& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TlsServerHelloDone* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TlsServerHelloDone_Tls Tls;

  // accessors -------------------------------------------------------

  // .cyberprobe.TlsServerHelloDone.Tls tls = 1;
  bool has_tls() const;
  void clear_tls();
  static const int kTlsFieldNumber = 1;
  private:
  const ::cyberprobe::TlsServerHelloDone_Tls& _internal_tls() const;
  public:
  const ::cyberprobe::TlsServerHelloDone_Tls& tls() const;
  ::cyberprobe::TlsServerHelloDone_Tls* release_tls();
  ::cyberprobe::TlsServerHelloDone_Tls* mutable_tls();
  void set_allocated_tls(::cyberprobe::TlsServerHelloDone_Tls* tls);

  // @@protoc_insertion_point(class_scope:cyberprobe.TlsServerHelloDone)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cyberprobe::TlsServerHelloDone_Tls* tls_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TlsHandshakeUnknown_Tls : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.TlsHandshakeUnknown.Tls) */ {
 public:
  TlsHandshakeUnknown_Tls();
  virtual ~TlsHandshakeUnknown_Tls();

  TlsHandshakeUnknown_Tls(const TlsHandshakeUnknown_Tls& from);

  inline TlsHandshakeUnknown_Tls& operator=(const TlsHandshakeUnknown_Tls& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TlsHandshakeUnknown_Tls(TlsHandshakeUnknown_Tls&& from) noexcept
    : TlsHandshakeUnknown_Tls() {
    *this = ::std::move(from);
  }

  inline TlsHandshakeUnknown_Tls& operator=(TlsHandshakeUnknown_Tls&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TlsHandshakeUnknown_Tls& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TlsHandshakeUnknown_Tls* internal_default_instance() {
    return reinterpret_cast<const TlsHandshakeUnknown_Tls*>(
               &_TlsHandshakeUnknown_Tls_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  void Swap(TlsHandshakeUnknown_Tls* other);
  friend void swap(TlsHandshakeUnknown_Tls& a, TlsHandshakeUnknown_Tls& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TlsHandshakeUnknown_Tls* New() const final {
    return CreateMaybeMessage<TlsHandshakeUnknown_Tls>(NULL);
  }

  TlsHandshakeUnknown_Tls* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TlsHandshakeUnknown_Tls>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TlsHandshakeUnknown_Tls& from);
  void MergeFrom(const TlsHandshakeUnknown_Tls& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TlsHandshakeUnknown_Tls* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // uint32 length = 2;
  void clear_length();
  static const int kLengthFieldNumber = 2;
  ::google::protobuf::uint32 length() const;
  void set_length(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:cyberprobe.TlsHandshakeUnknown.Tls)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::uint32 length_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TlsHandshakeUnknown : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.TlsHandshakeUnknown) */ {
 public:
  TlsHandshakeUnknown();
  virtual ~TlsHandshakeUnknown();

  TlsHandshakeUnknown(const TlsHandshakeUnknown& from);

  inline TlsHandshakeUnknown& operator=(const TlsHandshakeUnknown& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TlsHandshakeUnknown(TlsHandshakeUnknown&& from) noexcept
    : TlsHandshakeUnknown() {
    *this = ::std::move(from);
  }

  inline TlsHandshakeUnknown& operator=(TlsHandshakeUnknown&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TlsHandshakeUnknown& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TlsHandshakeUnknown* internal_default_instance() {
    return reinterpret_cast<const TlsHandshakeUnknown*>(
               &_TlsHandshakeUnknown_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  void Swap(TlsHandshakeUnknown* other);
  friend void swap(TlsHandshakeUnknown& a, TlsHandshakeUnknown& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TlsHandshakeUnknown* New() const final {
    return CreateMaybeMessage<TlsHandshakeUnknown>(NULL);
  }

  TlsHandshakeUnknown* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TlsHandshakeUnknown>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TlsHandshakeUnknown& from);
  void MergeFrom(const TlsHandshakeUnknown& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TlsHandshakeUnknown* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TlsHandshakeUnknown_Tls Tls;

  // accessors -------------------------------------------------------

  // .cyberprobe.TlsHandshakeUnknown.Tls tls = 1;
  bool has_tls() const;
  void clear_tls();
  static const int kTlsFieldNumber = 1;
  private:
  const ::cyberprobe::TlsHandshakeUnknown_Tls& _internal_tls() const;
  public:
  const ::cyberprobe::TlsHandshakeUnknown_Tls& tls() const;
  ::cyberprobe::TlsHandshakeUnknown_Tls* release_tls();
  ::cyberprobe::TlsHandshakeUnknown_Tls* mutable_tls();
  void set_allocated_tls(::cyberprobe::TlsHandshakeUnknown_Tls* tls);

  // @@protoc_insertion_point(class_scope:cyberprobe.TlsHandshakeUnknown)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cyberprobe::TlsHandshakeUnknown_Tls* tls_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TlsCertificateRequest_Tls_SignatureAlgorithm : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.TlsCertificateRequest.Tls.SignatureAlgorithm) */ {
 public:
  TlsCertificateRequest_Tls_SignatureAlgorithm();
  virtual ~TlsCertificateRequest_Tls_SignatureAlgorithm();

  TlsCertificateRequest_Tls_SignatureAlgorithm(const TlsCertificateRequest_Tls_SignatureAlgorithm& from);

  inline TlsCertificateRequest_Tls_SignatureAlgorithm& operator=(const TlsCertificateRequest_Tls_SignatureAlgorithm& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TlsCertificateRequest_Tls_SignatureAlgorithm(TlsCertificateRequest_Tls_SignatureAlgorithm&& from) noexcept
    : TlsCertificateRequest_Tls_SignatureAlgorithm() {
    *this = ::std::move(from);
  }

  inline TlsCertificateRequest_Tls_SignatureAlgorithm& operator=(TlsCertificateRequest_Tls_SignatureAlgorithm&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TlsCertificateRequest_Tls_SignatureAlgorithm& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TlsCertificateRequest_Tls_SignatureAlgorithm* internal_default_instance() {
    return reinterpret_cast<const TlsCertificateRequest_Tls_SignatureAlgorithm*>(
               &_TlsCertificateRequest_Tls_SignatureAlgorithm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  void Swap(TlsCertificateRequest_Tls_SignatureAlgorithm* other);
  friend void swap(TlsCertificateRequest_Tls_SignatureAlgorithm& a, TlsCertificateRequest_Tls_SignatureAlgorithm& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TlsCertificateRequest_Tls_SignatureAlgorithm* New() const final {
    return CreateMaybeMessage<TlsCertificateRequest_Tls_SignatureAlgorithm>(NULL);
  }

  TlsCertificateRequest_Tls_SignatureAlgorithm* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TlsCertificateRequest_Tls_SignatureAlgorithm>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TlsCertificateRequest_Tls_SignatureAlgorithm& from);
  void MergeFrom(const TlsCertificateRequest_Tls_SignatureAlgorithm& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TlsCertificateRequest_Tls_SignatureAlgorithm* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string hash_algorithm = 1;
  void clear_hash_algorithm();
  static const int kHashAlgorithmFieldNumber = 1;
  const ::std::string& hash_algorithm() const;
  void set_hash_algorithm(const ::std::string& value);
  #if LANG_CXX11
  void set_hash_algorithm(::std::string&& value);
  #endif
  void set_hash_algorithm(const char* value);
  void set_hash_algorithm(const char* value, size_t size);
  ::std::string* mutable_hash_algorithm();
  ::std::string* release_hash_algorithm();
  void set_allocated_hash_algorithm(::std::string* hash_algorithm);

  // string signature_algorithm = 2;
  void clear_signature_algorithm();
  static const int kSignatureAlgorithmFieldNumber = 2;
  const ::std::string& signature_algorithm() const;
  void set_signature_algorithm(const ::std::string& value);
  #if LANG_CXX11
  void set_signature_algorithm(::std::string&& value);
  #endif
  void set_signature_algorithm(const char* value);
  void set_signature_algorithm(const char* value, size_t size);
  ::std::string* mutable_signature_algorithm();
  ::std::string* release_signature_algorithm();
  void set_allocated_signature_algorithm(::std::string* signature_algorithm);

  // @@protoc_insertion_point(class_scope:cyberprobe.TlsCertificateRequest.Tls.SignatureAlgorithm)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hash_algorithm_;
  ::google::protobuf::internal::ArenaStringPtr signature_algorithm_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TlsCertificateRequest_Tls : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.TlsCertificateRequest.Tls) */ {
 public:
  TlsCertificateRequest_Tls();
  virtual ~TlsCertificateRequest_Tls();

  TlsCertificateRequest_Tls(const TlsCertificateRequest_Tls& from);

  inline TlsCertificateRequest_Tls& operator=(const TlsCertificateRequest_Tls& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TlsCertificateRequest_Tls(TlsCertificateRequest_Tls&& from) noexcept
    : TlsCertificateRequest_Tls() {
    *this = ::std::move(from);
  }

  inline TlsCertificateRequest_Tls& operator=(TlsCertificateRequest_Tls&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TlsCertificateRequest_Tls& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TlsCertificateRequest_Tls* internal_default_instance() {
    return reinterpret_cast<const TlsCertificateRequest_Tls*>(
               &_TlsCertificateRequest_Tls_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  void Swap(TlsCertificateRequest_Tls* other);
  friend void swap(TlsCertificateRequest_Tls& a, TlsCertificateRequest_Tls& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TlsCertificateRequest_Tls* New() const final {
    return CreateMaybeMessage<TlsCertificateRequest_Tls>(NULL);
  }

  TlsCertificateRequest_Tls* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TlsCertificateRequest_Tls>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TlsCertificateRequest_Tls& from);
  void MergeFrom(const TlsCertificateRequest_Tls& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TlsCertificateRequest_Tls* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TlsCertificateRequest_Tls_SignatureAlgorithm SignatureAlgorithm;

  // accessors -------------------------------------------------------

  // repeated string certificate_types = 1;
  int certificate_types_size() const;
  void clear_certificate_types();
  static const int kCertificateTypesFieldNumber = 1;
  const ::std::string& certificate_types(int index) const;
  ::std::string* mutable_certificate_types(int index);
  void set_certificate_types(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_certificate_types(int index, ::std::string&& value);
  #endif
  void set_certificate_types(int index, const char* value);
  void set_certificate_types(int index, const char* value, size_t size);
  ::std::string* add_certificate_types();
  void add_certificate_types(const ::std::string& value);
  #if LANG_CXX11
  void add_certificate_types(::std::string&& value);
  #endif
  void add_certificate_types(const char* value);
  void add_certificate_types(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& certificate_types() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_certificate_types();

  // repeated .cyberprobe.TlsCertificateRequest.Tls.SignatureAlgorithm signature_algorithms = 2;
  int signature_algorithms_size() const;
  void clear_signature_algorithms();
  static const int kSignatureAlgorithmsFieldNumber = 2;
  ::cyberprobe::TlsCertificateRequest_Tls_SignatureAlgorithm* mutable_signature_algorithms(int index);
  ::google::protobuf::RepeatedPtrField< ::cyberprobe::TlsCertificateRequest_Tls_SignatureAlgorithm >*
      mutable_signature_algorithms();
  const ::cyberprobe::TlsCertificateRequest_Tls_SignatureAlgorithm& signature_algorithms(int index) const;
  ::cyberprobe::TlsCertificateRequest_Tls_SignatureAlgorithm* add_signature_algorithms();
  const ::google::protobuf::RepeatedPtrField< ::cyberprobe::TlsCertificateRequest_Tls_SignatureAlgorithm >&
      signature_algorithms() const;

  // string distinguished_names = 3;
  void clear_distinguished_names();
  static const int kDistinguishedNamesFieldNumber = 3;
  const ::std::string& distinguished_names() const;
  void set_distinguished_names(const ::std::string& value);
  #if LANG_CXX11
  void set_distinguished_names(::std::string&& value);
  #endif
  void set_distinguished_names(const char* value);
  void set_distinguished_names(const char* value, size_t size);
  ::std::string* mutable_distinguished_names();
  ::std::string* release_distinguished_names();
  void set_allocated_distinguished_names(::std::string* distinguished_names);

  // @@protoc_insertion_point(class_scope:cyberprobe.TlsCertificateRequest.Tls)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> certificate_types_;
  ::google::protobuf::RepeatedPtrField< ::cyberprobe::TlsCertificateRequest_Tls_SignatureAlgorithm > signature_algorithms_;
  ::google::protobuf::internal::ArenaStringPtr distinguished_names_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TlsCertificateRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.TlsCertificateRequest) */ {
 public:
  TlsCertificateRequest();
  virtual ~TlsCertificateRequest();

  TlsCertificateRequest(const TlsCertificateRequest& from);

  inline TlsCertificateRequest& operator=(const TlsCertificateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TlsCertificateRequest(TlsCertificateRequest&& from) noexcept
    : TlsCertificateRequest() {
    *this = ::std::move(from);
  }

  inline TlsCertificateRequest& operator=(TlsCertificateRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TlsCertificateRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TlsCertificateRequest* internal_default_instance() {
    return reinterpret_cast<const TlsCertificateRequest*>(
               &_TlsCertificateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  void Swap(TlsCertificateRequest* other);
  friend void swap(TlsCertificateRequest& a, TlsCertificateRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TlsCertificateRequest* New() const final {
    return CreateMaybeMessage<TlsCertificateRequest>(NULL);
  }

  TlsCertificateRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TlsCertificateRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TlsCertificateRequest& from);
  void MergeFrom(const TlsCertificateRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TlsCertificateRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TlsCertificateRequest_Tls Tls;

  // accessors -------------------------------------------------------

  // .cyberprobe.TlsCertificateRequest.Tls tls = 1;
  bool has_tls() const;
  void clear_tls();
  static const int kTlsFieldNumber = 1;
  private:
  const ::cyberprobe::TlsCertificateRequest_Tls& _internal_tls() const;
  public:
  const ::cyberprobe::TlsCertificateRequest_Tls& tls() const;
  ::cyberprobe::TlsCertificateRequest_Tls* release_tls();
  ::cyberprobe::TlsCertificateRequest_Tls* mutable_tls();
  void set_allocated_tls(::cyberprobe::TlsCertificateRequest_Tls* tls);

  // @@protoc_insertion_point(class_scope:cyberprobe.TlsCertificateRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cyberprobe::TlsCertificateRequest_Tls* tls_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TlsClientKeyExchange_Tls : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.TlsClientKeyExchange.Tls) */ {
 public:
  TlsClientKeyExchange_Tls();
  virtual ~TlsClientKeyExchange_Tls();

  TlsClientKeyExchange_Tls(const TlsClientKeyExchange_Tls& from);

  inline TlsClientKeyExchange_Tls& operator=(const TlsClientKeyExchange_Tls& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TlsClientKeyExchange_Tls(TlsClientKeyExchange_Tls&& from) noexcept
    : TlsClientKeyExchange_Tls() {
    *this = ::std::move(from);
  }

  inline TlsClientKeyExchange_Tls& operator=(TlsClientKeyExchange_Tls&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TlsClientKeyExchange_Tls& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TlsClientKeyExchange_Tls* internal_default_instance() {
    return reinterpret_cast<const TlsClientKeyExchange_Tls*>(
               &_TlsClientKeyExchange_Tls_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  void Swap(TlsClientKeyExchange_Tls* other);
  friend void swap(TlsClientKeyExchange_Tls& a, TlsClientKeyExchange_Tls& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TlsClientKeyExchange_Tls* New() const final {
    return CreateMaybeMessage<TlsClientKeyExchange_Tls>(NULL);
  }

  TlsClientKeyExchange_Tls* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TlsClientKeyExchange_Tls>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TlsClientKeyExchange_Tls& from);
  void MergeFrom(const TlsClientKeyExchange_Tls& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TlsClientKeyExchange_Tls* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:cyberprobe.TlsClientKeyExchange.Tls)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TlsClientKeyExchange : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.TlsClientKeyExchange) */ {
 public:
  TlsClientKeyExchange();
  virtual ~TlsClientKeyExchange();

  TlsClientKeyExchange(const TlsClientKeyExchange& from);

  inline TlsClientKeyExchange& operator=(const TlsClientKeyExchange& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TlsClientKeyExchange(TlsClientKeyExchange&& from) noexcept
    : TlsClientKeyExchange() {
    *this = ::std::move(from);
  }

  inline TlsClientKeyExchange& operator=(TlsClientKeyExchange&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TlsClientKeyExchange& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TlsClientKeyExchange* internal_default_instance() {
    return reinterpret_cast<const TlsClientKeyExchange*>(
               &_TlsClientKeyExchange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  void Swap(TlsClientKeyExchange* other);
  friend void swap(TlsClientKeyExchange& a, TlsClientKeyExchange& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TlsClientKeyExchange* New() const final {
    return CreateMaybeMessage<TlsClientKeyExchange>(NULL);
  }

  TlsClientKeyExchange* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TlsClientKeyExchange>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TlsClientKeyExchange& from);
  void MergeFrom(const TlsClientKeyExchange& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TlsClientKeyExchange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TlsClientKeyExchange_Tls Tls;

  // accessors -------------------------------------------------------

  // .cyberprobe.TlsClientKeyExchange.Tls tls = 1;
  bool has_tls() const;
  void clear_tls();
  static const int kTlsFieldNumber = 1;
  private:
  const ::cyberprobe::TlsClientKeyExchange_Tls& _internal_tls() const;
  public:
  const ::cyberprobe::TlsClientKeyExchange_Tls& tls() const;
  ::cyberprobe::TlsClientKeyExchange_Tls* release_tls();
  ::cyberprobe::TlsClientKeyExchange_Tls* mutable_tls();
  void set_allocated_tls(::cyberprobe::TlsClientKeyExchange_Tls* tls);

  // @@protoc_insertion_point(class_scope:cyberprobe.TlsClientKeyExchange)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cyberprobe::TlsClientKeyExchange_Tls* tls_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TlsCertificateVerify_Tls_SignatureAlgorithm : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.TlsCertificateVerify.Tls.SignatureAlgorithm) */ {
 public:
  TlsCertificateVerify_Tls_SignatureAlgorithm();
  virtual ~TlsCertificateVerify_Tls_SignatureAlgorithm();

  TlsCertificateVerify_Tls_SignatureAlgorithm(const TlsCertificateVerify_Tls_SignatureAlgorithm& from);

  inline TlsCertificateVerify_Tls_SignatureAlgorithm& operator=(const TlsCertificateVerify_Tls_SignatureAlgorithm& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TlsCertificateVerify_Tls_SignatureAlgorithm(TlsCertificateVerify_Tls_SignatureAlgorithm&& from) noexcept
    : TlsCertificateVerify_Tls_SignatureAlgorithm() {
    *this = ::std::move(from);
  }

  inline TlsCertificateVerify_Tls_SignatureAlgorithm& operator=(TlsCertificateVerify_Tls_SignatureAlgorithm&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TlsCertificateVerify_Tls_SignatureAlgorithm& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TlsCertificateVerify_Tls_SignatureAlgorithm* internal_default_instance() {
    return reinterpret_cast<const TlsCertificateVerify_Tls_SignatureAlgorithm*>(
               &_TlsCertificateVerify_Tls_SignatureAlgorithm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  void Swap(TlsCertificateVerify_Tls_SignatureAlgorithm* other);
  friend void swap(TlsCertificateVerify_Tls_SignatureAlgorithm& a, TlsCertificateVerify_Tls_SignatureAlgorithm& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TlsCertificateVerify_Tls_SignatureAlgorithm* New() const final {
    return CreateMaybeMessage<TlsCertificateVerify_Tls_SignatureAlgorithm>(NULL);
  }

  TlsCertificateVerify_Tls_SignatureAlgorithm* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TlsCertificateVerify_Tls_SignatureAlgorithm>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TlsCertificateVerify_Tls_SignatureAlgorithm& from);
  void MergeFrom(const TlsCertificateVerify_Tls_SignatureAlgorithm& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TlsCertificateVerify_Tls_SignatureAlgorithm* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string hash_algorithm = 1;
  void clear_hash_algorithm();
  static const int kHashAlgorithmFieldNumber = 1;
  const ::std::string& hash_algorithm() const;
  void set_hash_algorithm(const ::std::string& value);
  #if LANG_CXX11
  void set_hash_algorithm(::std::string&& value);
  #endif
  void set_hash_algorithm(const char* value);
  void set_hash_algorithm(const char* value, size_t size);
  ::std::string* mutable_hash_algorithm();
  ::std::string* release_hash_algorithm();
  void set_allocated_hash_algorithm(::std::string* hash_algorithm);

  // string signature_algorithm = 2;
  void clear_signature_algorithm();
  static const int kSignatureAlgorithmFieldNumber = 2;
  const ::std::string& signature_algorithm() const;
  void set_signature_algorithm(const ::std::string& value);
  #if LANG_CXX11
  void set_signature_algorithm(::std::string&& value);
  #endif
  void set_signature_algorithm(const char* value);
  void set_signature_algorithm(const char* value, size_t size);
  ::std::string* mutable_signature_algorithm();
  ::std::string* release_signature_algorithm();
  void set_allocated_signature_algorithm(::std::string* signature_algorithm);

  // @@protoc_insertion_point(class_scope:cyberprobe.TlsCertificateVerify.Tls.SignatureAlgorithm)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hash_algorithm_;
  ::google::protobuf::internal::ArenaStringPtr signature_algorithm_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TlsCertificateVerify_Tls : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.TlsCertificateVerify.Tls) */ {
 public:
  TlsCertificateVerify_Tls();
  virtual ~TlsCertificateVerify_Tls();

  TlsCertificateVerify_Tls(const TlsCertificateVerify_Tls& from);

  inline TlsCertificateVerify_Tls& operator=(const TlsCertificateVerify_Tls& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TlsCertificateVerify_Tls(TlsCertificateVerify_Tls&& from) noexcept
    : TlsCertificateVerify_Tls() {
    *this = ::std::move(from);
  }

  inline TlsCertificateVerify_Tls& operator=(TlsCertificateVerify_Tls&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TlsCertificateVerify_Tls& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TlsCertificateVerify_Tls* internal_default_instance() {
    return reinterpret_cast<const TlsCertificateVerify_Tls*>(
               &_TlsCertificateVerify_Tls_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  void Swap(TlsCertificateVerify_Tls* other);
  friend void swap(TlsCertificateVerify_Tls& a, TlsCertificateVerify_Tls& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TlsCertificateVerify_Tls* New() const final {
    return CreateMaybeMessage<TlsCertificateVerify_Tls>(NULL);
  }

  TlsCertificateVerify_Tls* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TlsCertificateVerify_Tls>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TlsCertificateVerify_Tls& from);
  void MergeFrom(const TlsCertificateVerify_Tls& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TlsCertificateVerify_Tls* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TlsCertificateVerify_Tls_SignatureAlgorithm SignatureAlgorithm;

  // accessors -------------------------------------------------------

  // repeated .cyberprobe.TlsCertificateVerify.Tls.SignatureAlgorithm signature_algorithms = 2;
  int signature_algorithms_size() const;
  void clear_signature_algorithms();
  static const int kSignatureAlgorithmsFieldNumber = 2;
  ::cyberprobe::TlsCertificateVerify_Tls_SignatureAlgorithm* mutable_signature_algorithms(int index);
  ::google::protobuf::RepeatedPtrField< ::cyberprobe::TlsCertificateVerify_Tls_SignatureAlgorithm >*
      mutable_signature_algorithms();
  const ::cyberprobe::TlsCertificateVerify_Tls_SignatureAlgorithm& signature_algorithms(int index) const;
  ::cyberprobe::TlsCertificateVerify_Tls_SignatureAlgorithm* add_signature_algorithms();
  const ::google::protobuf::RepeatedPtrField< ::cyberprobe::TlsCertificateVerify_Tls_SignatureAlgorithm >&
      signature_algorithms() const;

  // string signature = 3;
  void clear_signature();
  static const int kSignatureFieldNumber = 3;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_signature(::std::string&& value);
  #endif
  void set_signature(const char* value);
  void set_signature(const char* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:cyberprobe.TlsCertificateVerify.Tls)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::cyberprobe::TlsCertificateVerify_Tls_SignatureAlgorithm > signature_algorithms_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TlsCertificateVerify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.TlsCertificateVerify) */ {
 public:
  TlsCertificateVerify();
  virtual ~TlsCertificateVerify();

  TlsCertificateVerify(const TlsCertificateVerify& from);

  inline TlsCertificateVerify& operator=(const TlsCertificateVerify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TlsCertificateVerify(TlsCertificateVerify&& from) noexcept
    : TlsCertificateVerify() {
    *this = ::std::move(from);
  }

  inline TlsCertificateVerify& operator=(TlsCertificateVerify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TlsCertificateVerify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TlsCertificateVerify* internal_default_instance() {
    return reinterpret_cast<const TlsCertificateVerify*>(
               &_TlsCertificateVerify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  void Swap(TlsCertificateVerify* other);
  friend void swap(TlsCertificateVerify& a, TlsCertificateVerify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TlsCertificateVerify* New() const final {
    return CreateMaybeMessage<TlsCertificateVerify>(NULL);
  }

  TlsCertificateVerify* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TlsCertificateVerify>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TlsCertificateVerify& from);
  void MergeFrom(const TlsCertificateVerify& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TlsCertificateVerify* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TlsCertificateVerify_Tls Tls;

  // accessors -------------------------------------------------------

  // .cyberprobe.TlsCertificateVerify.Tls tls = 1;
  bool has_tls() const;
  void clear_tls();
  static const int kTlsFieldNumber = 1;
  private:
  const ::cyberprobe::TlsCertificateVerify_Tls& _internal_tls() const;
  public:
  const ::cyberprobe::TlsCertificateVerify_Tls& tls() const;
  ::cyberprobe::TlsCertificateVerify_Tls* release_tls();
  ::cyberprobe::TlsCertificateVerify_Tls* mutable_tls();
  void set_allocated_tls(::cyberprobe::TlsCertificateVerify_Tls* tls);

  // @@protoc_insertion_point(class_scope:cyberprobe.TlsCertificateVerify)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cyberprobe::TlsCertificateVerify_Tls* tls_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TlsChangeCipherSpec_Tls : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.TlsChangeCipherSpec.Tls) */ {
 public:
  TlsChangeCipherSpec_Tls();
  virtual ~TlsChangeCipherSpec_Tls();

  TlsChangeCipherSpec_Tls(const TlsChangeCipherSpec_Tls& from);

  inline TlsChangeCipherSpec_Tls& operator=(const TlsChangeCipherSpec_Tls& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TlsChangeCipherSpec_Tls(TlsChangeCipherSpec_Tls&& from) noexcept
    : TlsChangeCipherSpec_Tls() {
    *this = ::std::move(from);
  }

  inline TlsChangeCipherSpec_Tls& operator=(TlsChangeCipherSpec_Tls&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TlsChangeCipherSpec_Tls& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TlsChangeCipherSpec_Tls* internal_default_instance() {
    return reinterpret_cast<const TlsChangeCipherSpec_Tls*>(
               &_TlsChangeCipherSpec_Tls_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  void Swap(TlsChangeCipherSpec_Tls* other);
  friend void swap(TlsChangeCipherSpec_Tls& a, TlsChangeCipherSpec_Tls& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TlsChangeCipherSpec_Tls* New() const final {
    return CreateMaybeMessage<TlsChangeCipherSpec_Tls>(NULL);
  }

  TlsChangeCipherSpec_Tls* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TlsChangeCipherSpec_Tls>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TlsChangeCipherSpec_Tls& from);
  void MergeFrom(const TlsChangeCipherSpec_Tls& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TlsChangeCipherSpec_Tls* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:cyberprobe.TlsChangeCipherSpec.Tls)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TlsChangeCipherSpec : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.TlsChangeCipherSpec) */ {
 public:
  TlsChangeCipherSpec();
  virtual ~TlsChangeCipherSpec();

  TlsChangeCipherSpec(const TlsChangeCipherSpec& from);

  inline TlsChangeCipherSpec& operator=(const TlsChangeCipherSpec& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TlsChangeCipherSpec(TlsChangeCipherSpec&& from) noexcept
    : TlsChangeCipherSpec() {
    *this = ::std::move(from);
  }

  inline TlsChangeCipherSpec& operator=(TlsChangeCipherSpec&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TlsChangeCipherSpec& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TlsChangeCipherSpec* internal_default_instance() {
    return reinterpret_cast<const TlsChangeCipherSpec*>(
               &_TlsChangeCipherSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  void Swap(TlsChangeCipherSpec* other);
  friend void swap(TlsChangeCipherSpec& a, TlsChangeCipherSpec& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TlsChangeCipherSpec* New() const final {
    return CreateMaybeMessage<TlsChangeCipherSpec>(NULL);
  }

  TlsChangeCipherSpec* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TlsChangeCipherSpec>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TlsChangeCipherSpec& from);
  void MergeFrom(const TlsChangeCipherSpec& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TlsChangeCipherSpec* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TlsChangeCipherSpec_Tls Tls;

  // accessors -------------------------------------------------------

  // .cyberprobe.TlsChangeCipherSpec.Tls tls = 1;
  bool has_tls() const;
  void clear_tls();
  static const int kTlsFieldNumber = 1;
  private:
  const ::cyberprobe::TlsChangeCipherSpec_Tls& _internal_tls() const;
  public:
  const ::cyberprobe::TlsChangeCipherSpec_Tls& tls() const;
  ::cyberprobe::TlsChangeCipherSpec_Tls* release_tls();
  ::cyberprobe::TlsChangeCipherSpec_Tls* mutable_tls();
  void set_allocated_tls(::cyberprobe::TlsChangeCipherSpec_Tls* tls);

  // @@protoc_insertion_point(class_scope:cyberprobe.TlsChangeCipherSpec)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cyberprobe::TlsChangeCipherSpec_Tls* tls_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TlsHandshakeFinished_Tls : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.TlsHandshakeFinished.Tls) */ {
 public:
  TlsHandshakeFinished_Tls();
  virtual ~TlsHandshakeFinished_Tls();

  TlsHandshakeFinished_Tls(const TlsHandshakeFinished_Tls& from);

  inline TlsHandshakeFinished_Tls& operator=(const TlsHandshakeFinished_Tls& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TlsHandshakeFinished_Tls(TlsHandshakeFinished_Tls&& from) noexcept
    : TlsHandshakeFinished_Tls() {
    *this = ::std::move(from);
  }

  inline TlsHandshakeFinished_Tls& operator=(TlsHandshakeFinished_Tls&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TlsHandshakeFinished_Tls& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TlsHandshakeFinished_Tls* internal_default_instance() {
    return reinterpret_cast<const TlsHandshakeFinished_Tls*>(
               &_TlsHandshakeFinished_Tls_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  void Swap(TlsHandshakeFinished_Tls* other);
  friend void swap(TlsHandshakeFinished_Tls& a, TlsHandshakeFinished_Tls& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TlsHandshakeFinished_Tls* New() const final {
    return CreateMaybeMessage<TlsHandshakeFinished_Tls>(NULL);
  }

  TlsHandshakeFinished_Tls* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TlsHandshakeFinished_Tls>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TlsHandshakeFinished_Tls& from);
  void MergeFrom(const TlsHandshakeFinished_Tls& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TlsHandshakeFinished_Tls* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 1;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:cyberprobe.TlsHandshakeFinished.Tls)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TlsHandshakeFinished : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.TlsHandshakeFinished) */ {
 public:
  TlsHandshakeFinished();
  virtual ~TlsHandshakeFinished();

  TlsHandshakeFinished(const TlsHandshakeFinished& from);

  inline TlsHandshakeFinished& operator=(const TlsHandshakeFinished& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TlsHandshakeFinished(TlsHandshakeFinished&& from) noexcept
    : TlsHandshakeFinished() {
    *this = ::std::move(from);
  }

  inline TlsHandshakeFinished& operator=(TlsHandshakeFinished&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TlsHandshakeFinished& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TlsHandshakeFinished* internal_default_instance() {
    return reinterpret_cast<const TlsHandshakeFinished*>(
               &_TlsHandshakeFinished_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  void Swap(TlsHandshakeFinished* other);
  friend void swap(TlsHandshakeFinished& a, TlsHandshakeFinished& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TlsHandshakeFinished* New() const final {
    return CreateMaybeMessage<TlsHandshakeFinished>(NULL);
  }

  TlsHandshakeFinished* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TlsHandshakeFinished>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TlsHandshakeFinished& from);
  void MergeFrom(const TlsHandshakeFinished& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TlsHandshakeFinished* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TlsHandshakeFinished_Tls Tls;

  // accessors -------------------------------------------------------

  // .cyberprobe.TlsHandshakeFinished.Tls tls = 1;
  bool has_tls() const;
  void clear_tls();
  static const int kTlsFieldNumber = 1;
  private:
  const ::cyberprobe::TlsHandshakeFinished_Tls& _internal_tls() const;
  public:
  const ::cyberprobe::TlsHandshakeFinished_Tls& tls() const;
  ::cyberprobe::TlsHandshakeFinished_Tls* release_tls();
  ::cyberprobe::TlsHandshakeFinished_Tls* mutable_tls();
  void set_allocated_tls(::cyberprobe::TlsHandshakeFinished_Tls* tls);

  // @@protoc_insertion_point(class_scope:cyberprobe.TlsHandshakeFinished)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cyberprobe::TlsHandshakeFinished_Tls* tls_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TlsHandshakeComplete_Tls : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.TlsHandshakeComplete.Tls) */ {
 public:
  TlsHandshakeComplete_Tls();
  virtual ~TlsHandshakeComplete_Tls();

  TlsHandshakeComplete_Tls(const TlsHandshakeComplete_Tls& from);

  inline TlsHandshakeComplete_Tls& operator=(const TlsHandshakeComplete_Tls& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TlsHandshakeComplete_Tls(TlsHandshakeComplete_Tls&& from) noexcept
    : TlsHandshakeComplete_Tls() {
    *this = ::std::move(from);
  }

  inline TlsHandshakeComplete_Tls& operator=(TlsHandshakeComplete_Tls&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TlsHandshakeComplete_Tls& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TlsHandshakeComplete_Tls* internal_default_instance() {
    return reinterpret_cast<const TlsHandshakeComplete_Tls*>(
               &_TlsHandshakeComplete_Tls_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  void Swap(TlsHandshakeComplete_Tls* other);
  friend void swap(TlsHandshakeComplete_Tls& a, TlsHandshakeComplete_Tls& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TlsHandshakeComplete_Tls* New() const final {
    return CreateMaybeMessage<TlsHandshakeComplete_Tls>(NULL);
  }

  TlsHandshakeComplete_Tls* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TlsHandshakeComplete_Tls>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TlsHandshakeComplete_Tls& from);
  void MergeFrom(const TlsHandshakeComplete_Tls& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TlsHandshakeComplete_Tls* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cyberprobe.TlsHandshakeComplete.Tls)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TlsHandshakeComplete : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.TlsHandshakeComplete) */ {
 public:
  TlsHandshakeComplete();
  virtual ~TlsHandshakeComplete();

  TlsHandshakeComplete(const TlsHandshakeComplete& from);

  inline TlsHandshakeComplete& operator=(const TlsHandshakeComplete& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TlsHandshakeComplete(TlsHandshakeComplete&& from) noexcept
    : TlsHandshakeComplete() {
    *this = ::std::move(from);
  }

  inline TlsHandshakeComplete& operator=(TlsHandshakeComplete&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TlsHandshakeComplete& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TlsHandshakeComplete* internal_default_instance() {
    return reinterpret_cast<const TlsHandshakeComplete*>(
               &_TlsHandshakeComplete_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  void Swap(TlsHandshakeComplete* other);
  friend void swap(TlsHandshakeComplete& a, TlsHandshakeComplete& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TlsHandshakeComplete* New() const final {
    return CreateMaybeMessage<TlsHandshakeComplete>(NULL);
  }

  TlsHandshakeComplete* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TlsHandshakeComplete>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TlsHandshakeComplete& from);
  void MergeFrom(const TlsHandshakeComplete& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TlsHandshakeComplete* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TlsHandshakeComplete_Tls Tls;

  // accessors -------------------------------------------------------

  // .cyberprobe.TlsHandshakeComplete.Tls tls = 1;
  bool has_tls() const;
  void clear_tls();
  static const int kTlsFieldNumber = 1;
  private:
  const ::cyberprobe::TlsHandshakeComplete_Tls& _internal_tls() const;
  public:
  const ::cyberprobe::TlsHandshakeComplete_Tls& tls() const;
  ::cyberprobe::TlsHandshakeComplete_Tls* release_tls();
  ::cyberprobe::TlsHandshakeComplete_Tls* mutable_tls();
  void set_allocated_tls(::cyberprobe::TlsHandshakeComplete_Tls* tls);

  // @@protoc_insertion_point(class_scope:cyberprobe.TlsHandshakeComplete)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cyberprobe::TlsHandshakeComplete_Tls* tls_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TlsApplicationData_Tls : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.TlsApplicationData.Tls) */ {
 public:
  TlsApplicationData_Tls();
  virtual ~TlsApplicationData_Tls();

  TlsApplicationData_Tls(const TlsApplicationData_Tls& from);

  inline TlsApplicationData_Tls& operator=(const TlsApplicationData_Tls& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TlsApplicationData_Tls(TlsApplicationData_Tls&& from) noexcept
    : TlsApplicationData_Tls() {
    *this = ::std::move(from);
  }

  inline TlsApplicationData_Tls& operator=(TlsApplicationData_Tls&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TlsApplicationData_Tls& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TlsApplicationData_Tls* internal_default_instance() {
    return reinterpret_cast<const TlsApplicationData_Tls*>(
               &_TlsApplicationData_Tls_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  void Swap(TlsApplicationData_Tls* other);
  friend void swap(TlsApplicationData_Tls& a, TlsApplicationData_Tls& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TlsApplicationData_Tls* New() const final {
    return CreateMaybeMessage<TlsApplicationData_Tls>(NULL);
  }

  TlsApplicationData_Tls* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TlsApplicationData_Tls>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TlsApplicationData_Tls& from);
  void MergeFrom(const TlsApplicationData_Tls& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TlsApplicationData_Tls* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 length = 2;
  void clear_length();
  static const int kLengthFieldNumber = 2;
  ::google::protobuf::uint64 length() const;
  void set_length(::google::protobuf::uint64 value);

  // uint32 version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:cyberprobe.TlsApplicationData.Tls)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 length_;
  ::google::protobuf::uint32 version_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TlsApplicationData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.TlsApplicationData) */ {
 public:
  TlsApplicationData();
  virtual ~TlsApplicationData();

  TlsApplicationData(const TlsApplicationData& from);

  inline TlsApplicationData& operator=(const TlsApplicationData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TlsApplicationData(TlsApplicationData&& from) noexcept
    : TlsApplicationData() {
    *this = ::std::move(from);
  }

  inline TlsApplicationData& operator=(TlsApplicationData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TlsApplicationData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TlsApplicationData* internal_default_instance() {
    return reinterpret_cast<const TlsApplicationData*>(
               &_TlsApplicationData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  void Swap(TlsApplicationData* other);
  friend void swap(TlsApplicationData& a, TlsApplicationData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TlsApplicationData* New() const final {
    return CreateMaybeMessage<TlsApplicationData>(NULL);
  }

  TlsApplicationData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TlsApplicationData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TlsApplicationData& from);
  void MergeFrom(const TlsApplicationData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TlsApplicationData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TlsApplicationData_Tls Tls;

  // accessors -------------------------------------------------------

  // .cyberprobe.TlsApplicationData.Tls tls = 1;
  bool has_tls() const;
  void clear_tls();
  static const int kTlsFieldNumber = 1;
  private:
  const ::cyberprobe::TlsApplicationData_Tls& _internal_tls() const;
  public:
  const ::cyberprobe::TlsApplicationData_Tls& tls() const;
  ::cyberprobe::TlsApplicationData_Tls* release_tls();
  ::cyberprobe::TlsApplicationData_Tls* mutable_tls();
  void set_allocated_tls(::cyberprobe::TlsApplicationData_Tls* tls);

  // @@protoc_insertion_point(class_scope:cyberprobe.TlsApplicationData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cyberprobe::TlsApplicationData_Tls* tls_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Locations_Location : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.Locations.Location) */ {
 public:
  Locations_Location();
  virtual ~Locations_Location();

  Locations_Location(const Locations_Location& from);

  inline Locations_Location& operator=(const Locations_Location& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Locations_Location(Locations_Location&& from) noexcept
    : Locations_Location() {
    *this = ::std::move(from);
  }

  inline Locations_Location& operator=(Locations_Location&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Locations_Location& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Locations_Location* internal_default_instance() {
    return reinterpret_cast<const Locations_Location*>(
               &_Locations_Location_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  void Swap(Locations_Location* other);
  friend void swap(Locations_Location& a, Locations_Location& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Locations_Location* New() const final {
    return CreateMaybeMessage<Locations_Location>(NULL);
  }

  Locations_Location* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Locations_Location>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Locations_Location& from);
  void MergeFrom(const Locations_Location& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Locations_Location* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string city = 1;
  void clear_city();
  static const int kCityFieldNumber = 1;
  const ::std::string& city() const;
  void set_city(const ::std::string& value);
  #if LANG_CXX11
  void set_city(::std::string&& value);
  #endif
  void set_city(const char* value);
  void set_city(const char* value, size_t size);
  ::std::string* mutable_city();
  ::std::string* release_city();
  void set_allocated_city(::std::string* city);

  // string iso = 2;
  void clear_iso();
  static const int kIsoFieldNumber = 2;
  const ::std::string& iso() const;
  void set_iso(const ::std::string& value);
  #if LANG_CXX11
  void set_iso(::std::string&& value);
  #endif
  void set_iso(const char* value);
  void set_iso(const char* value, size_t size);
  ::std::string* mutable_iso();
  ::std::string* release_iso();
  void set_allocated_iso(::std::string* iso);

  // string country = 3;
  void clear_country();
  static const int kCountryFieldNumber = 3;
  const ::std::string& country() const;
  void set_country(const ::std::string& value);
  #if LANG_CXX11
  void set_country(::std::string&& value);
  #endif
  void set_country(const char* value);
  void set_country(const char* value, size_t size);
  ::std::string* mutable_country();
  ::std::string* release_country();
  void set_allocated_country(::std::string* country);

  // float latitude = 4;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 4;
  float latitude() const;
  void set_latitude(float value);

  // float longitude = 5;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 5;
  float longitude() const;
  void set_longitude(float value);

  // @@protoc_insertion_point(class_scope:cyberprobe.Locations.Location)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr city_;
  ::google::protobuf::internal::ArenaStringPtr iso_;
  ::google::protobuf::internal::ArenaStringPtr country_;
  float latitude_;
  float longitude_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Locations : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.Locations) */ {
 public:
  Locations();
  virtual ~Locations();

  Locations(const Locations& from);

  inline Locations& operator=(const Locations& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Locations(Locations&& from) noexcept
    : Locations() {
    *this = ::std::move(from);
  }

  inline Locations& operator=(Locations&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Locations& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Locations* internal_default_instance() {
    return reinterpret_cast<const Locations*>(
               &_Locations_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  void Swap(Locations* other);
  friend void swap(Locations& a, Locations& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Locations* New() const final {
    return CreateMaybeMessage<Locations>(NULL);
  }

  Locations* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Locations>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Locations& from);
  void MergeFrom(const Locations& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Locations* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Locations_Location Location;

  // accessors -------------------------------------------------------

  // .cyberprobe.Locations.Location src = 1;
  bool has_src() const;
  void clear_src();
  static const int kSrcFieldNumber = 1;
  private:
  const ::cyberprobe::Locations_Location& _internal_src() const;
  public:
  const ::cyberprobe::Locations_Location& src() const;
  ::cyberprobe::Locations_Location* release_src();
  ::cyberprobe::Locations_Location* mutable_src();
  void set_allocated_src(::cyberprobe::Locations_Location* src);

  // .cyberprobe.Locations.Location dest = 2;
  bool has_dest() const;
  void clear_dest();
  static const int kDestFieldNumber = 2;
  private:
  const ::cyberprobe::Locations_Location& _internal_dest() const;
  public:
  const ::cyberprobe::Locations_Location& dest() const;
  ::cyberprobe::Locations_Location* release_dest();
  ::cyberprobe::Locations_Location* mutable_dest();
  void set_allocated_dest(::cyberprobe::Locations_Location* dest);

  // @@protoc_insertion_point(class_scope:cyberprobe.Locations)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cyberprobe::Locations_Location* src_;
  ::cyberprobe::Locations_Location* dest_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Indicator : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.Indicator) */ {
 public:
  Indicator();
  virtual ~Indicator();

  Indicator(const Indicator& from);

  inline Indicator& operator=(const Indicator& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Indicator(Indicator&& from) noexcept
    : Indicator() {
    *this = ::std::move(from);
  }

  inline Indicator& operator=(Indicator&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Indicator& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Indicator* internal_default_instance() {
    return reinterpret_cast<const Indicator*>(
               &_Indicator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  void Swap(Indicator* other);
  friend void swap(Indicator& a, Indicator& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Indicator* New() const final {
    return CreateMaybeMessage<Indicator>(NULL);
  }

  Indicator* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Indicator>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Indicator& from);
  void MergeFrom(const Indicator& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Indicator* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // string value = 3;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // string description = 4;
  void clear_description();
  static const int kDescriptionFieldNumber = 4;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // @@protoc_insertion_point(class_scope:cyberprobe.Indicator)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Event : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.Event) */ {
 public:
  Event();
  virtual ~Event();

  Event(const Event& from);

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(Event&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Event& default_instance();

  enum DetailCase {
    kDnsMessage = 10,
    kUnrecognisedDatagram = 11,
    kUnrecognisedStream = 12,
    kIcmp = 13,
    kHttpRequest = 14,
    kHttpResponse = 15,
    kSipRequest = 16,
    kSipResponse = 17,
    kSipSsl = 18,
    kImap = 19,
    kPop3 = 20,
    kPop3Ssl = 21,
    kNtpTimestamp = 22,
    kNtpControl = 23,
    kNtpPrivate = 24,
    kFtpCommand = 25,
    kFtpResponse = 26,
    kSmtpCommand = 27,
    kSmtpResponse = 28,
    kSmtpData = 29,
    kGre = 30,
    kGrePptp = 31,
    kEsp = 32,
    kUnrecognisedIpProtocol = 33,
    kWlan = 34,
    kTlsUnknown = 35,
    kTlsClientHello = 36,
    kTlsServerHello = 37,
    kTlsCertificates = 38,
    kTlsServerKeyExchange = 39,
    kTlsServerHelloDone = 40,
    kTlsHandshakeUnknown = 41,
    kTlsCertificateRequest = 42,
    kTlsClientKeyExchange = 43,
    kTlsCertificateVerify = 44,
    kTlsChangeCipherSpec = 45,
    kTlsHandshakeFinished = 46,
    kTlsHandshakeComplete = 47,
    kTlsApplicationData = 48,
    DETAIL_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  void Swap(Event* other);
  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event* New() const final {
    return CreateMaybeMessage<Event>(NULL);
  }

  Event* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Event>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string src = 7;
  int src_size() const;
  void clear_src();
  static const int kSrcFieldNumber = 7;
  const ::std::string& src(int index) const;
  ::std::string* mutable_src(int index);
  void set_src(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_src(int index, ::std::string&& value);
  #endif
  void set_src(int index, const char* value);
  void set_src(int index, const char* value, size_t size);
  ::std::string* add_src();
  void add_src(const ::std::string& value);
  #if LANG_CXX11
  void add_src(::std::string&& value);
  #endif
  void add_src(const char* value);
  void add_src(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& src() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_src();

  // repeated string dest = 8;
  int dest_size() const;
  void clear_dest();
  static const int kDestFieldNumber = 8;
  const ::std::string& dest(int index) const;
  ::std::string* mutable_dest(int index);
  void set_dest(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_dest(int index, ::std::string&& value);
  #endif
  void set_dest(int index, const char* value);
  void set_dest(int index, const char* value, size_t size);
  ::std::string* add_dest();
  void add_dest(const ::std::string& value);
  #if LANG_CXX11
  void add_dest(::std::string&& value);
  #endif
  void add_dest(const char* value);
  void add_dest(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& dest() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_dest();

  // repeated .cyberprobe.Indicator indicators = 50;
  int indicators_size() const;
  void clear_indicators();
  static const int kIndicatorsFieldNumber = 50;
  ::cyberprobe::Indicator* mutable_indicators(int index);
  ::google::protobuf::RepeatedPtrField< ::cyberprobe::Indicator >*
      mutable_indicators();
  const ::cyberprobe::Indicator& indicators(int index) const;
  ::cyberprobe::Indicator* add_indicators();
  const ::google::protobuf::RepeatedPtrField< ::cyberprobe::Indicator >&
      indicators() const;

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string device = 2;
  void clear_device();
  static const int kDeviceFieldNumber = 2;
  const ::std::string& device() const;
  void set_device(const ::std::string& value);
  #if LANG_CXX11
  void set_device(::std::string&& value);
  #endif
  void set_device(const char* value);
  void set_device(const char* value, size_t size);
  ::std::string* mutable_device();
  ::std::string* release_device();
  void set_allocated_device(::std::string* device);

  // string network = 3;
  void clear_network();
  static const int kNetworkFieldNumber = 3;
  const ::std::string& network() const;
  void set_network(const ::std::string& value);
  #if LANG_CXX11
  void set_network(::std::string&& value);
  #endif
  void set_network(const char* value);
  void set_network(const char* value, size_t size);
  ::std::string* mutable_network();
  ::std::string* release_network();
  void set_allocated_network(::std::string* network);

  // string origin = 4;
  void clear_origin();
  static const int kOriginFieldNumber = 4;
  const ::std::string& origin() const;
  void set_origin(const ::std::string& value);
  #if LANG_CXX11
  void set_origin(::std::string&& value);
  #endif
  void set_origin(const char* value);
  void set_origin(const char* value, size_t size);
  ::std::string* mutable_origin();
  ::std::string* release_origin();
  void set_allocated_origin(::std::string* origin);

  // string url = 6;
  void clear_url();
  static const int kUrlFieldNumber = 6;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // .google.protobuf.Timestamp time = 9;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 9;
  private:
  const ::google::protobuf::Timestamp& _internal_time() const;
  public:
  const ::google::protobuf::Timestamp& time() const;
  ::google::protobuf::Timestamp* release_time();
  ::google::protobuf::Timestamp* mutable_time();
  void set_allocated_time(::google::protobuf::Timestamp* time);

  // .cyberprobe.Locations location = 49;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 49;
  private:
  const ::cyberprobe::Locations& _internal_location() const;
  public:
  const ::cyberprobe::Locations& location() const;
  ::cyberprobe::Locations* release_location();
  ::cyberprobe::Locations* mutable_location();
  void set_allocated_location(::cyberprobe::Locations* location);

  // .cyberprobe.Action action = 5;
  void clear_action();
  static const int kActionFieldNumber = 5;
  ::cyberprobe::Action action() const;
  void set_action(::cyberprobe::Action value);

  // .cyberprobe.DnsMessage dns_message = 10;
  bool has_dns_message() const;
  void clear_dns_message();
  static const int kDnsMessageFieldNumber = 10;
  private:
  const ::cyberprobe::DnsMessage& _internal_dns_message() const;
  public:
  const ::cyberprobe::DnsMessage& dns_message() const;
  ::cyberprobe::DnsMessage* release_dns_message();
  ::cyberprobe::DnsMessage* mutable_dns_message();
  void set_allocated_dns_message(::cyberprobe::DnsMessage* dns_message);

  // .cyberprobe.UnrecognisedDatagram unrecognised_datagram = 11;
  bool has_unrecognised_datagram() const;
  void clear_unrecognised_datagram();
  static const int kUnrecognisedDatagramFieldNumber = 11;
  private:
  const ::cyberprobe::UnrecognisedDatagram& _internal_unrecognised_datagram() const;
  public:
  const ::cyberprobe::UnrecognisedDatagram& unrecognised_datagram() const;
  ::cyberprobe::UnrecognisedDatagram* release_unrecognised_datagram();
  ::cyberprobe::UnrecognisedDatagram* mutable_unrecognised_datagram();
  void set_allocated_unrecognised_datagram(::cyberprobe::UnrecognisedDatagram* unrecognised_datagram);

  // .cyberprobe.UnrecognisedStream unrecognised_stream = 12;
  bool has_unrecognised_stream() const;
  void clear_unrecognised_stream();
  static const int kUnrecognisedStreamFieldNumber = 12;
  private:
  const ::cyberprobe::UnrecognisedStream& _internal_unrecognised_stream() const;
  public:
  const ::cyberprobe::UnrecognisedStream& unrecognised_stream() const;
  ::cyberprobe::UnrecognisedStream* release_unrecognised_stream();
  ::cyberprobe::UnrecognisedStream* mutable_unrecognised_stream();
  void set_allocated_unrecognised_stream(::cyberprobe::UnrecognisedStream* unrecognised_stream);

  // .cyberprobe.Icmp icmp = 13;
  bool has_icmp() const;
  void clear_icmp();
  static const int kIcmpFieldNumber = 13;
  private:
  const ::cyberprobe::Icmp& _internal_icmp() const;
  public:
  const ::cyberprobe::Icmp& icmp() const;
  ::cyberprobe::Icmp* release_icmp();
  ::cyberprobe::Icmp* mutable_icmp();
  void set_allocated_icmp(::cyberprobe::Icmp* icmp);

  // .cyberprobe.HttpRequest http_request = 14;
  bool has_http_request() const;
  void clear_http_request();
  static const int kHttpRequestFieldNumber = 14;
  private:
  const ::cyberprobe::HttpRequest& _internal_http_request() const;
  public:
  const ::cyberprobe::HttpRequest& http_request() const;
  ::cyberprobe::HttpRequest* release_http_request();
  ::cyberprobe::HttpRequest* mutable_http_request();
  void set_allocated_http_request(::cyberprobe::HttpRequest* http_request);

  // .cyberprobe.HttpResponse http_response = 15;
  bool has_http_response() const;
  void clear_http_response();
  static const int kHttpResponseFieldNumber = 15;
  private:
  const ::cyberprobe::HttpResponse& _internal_http_response() const;
  public:
  const ::cyberprobe::HttpResponse& http_response() const;
  ::cyberprobe::HttpResponse* release_http_response();
  ::cyberprobe::HttpResponse* mutable_http_response();
  void set_allocated_http_response(::cyberprobe::HttpResponse* http_response);

  // .cyberprobe.SipRequest sip_request = 16;
  bool has_sip_request() const;
  void clear_sip_request();
  static const int kSipRequestFieldNumber = 16;
  private:
  const ::cyberprobe::SipRequest& _internal_sip_request() const;
  public:
  const ::cyberprobe::SipRequest& sip_request() const;
  ::cyberprobe::SipRequest* release_sip_request();
  ::cyberprobe::SipRequest* mutable_sip_request();
  void set_allocated_sip_request(::cyberprobe::SipRequest* sip_request);

  // .cyberprobe.SipResponse sip_response = 17;
  bool has_sip_response() const;
  void clear_sip_response();
  static const int kSipResponseFieldNumber = 17;
  private:
  const ::cyberprobe::SipResponse& _internal_sip_response() const;
  public:
  const ::cyberprobe::SipResponse& sip_response() const;
  ::cyberprobe::SipResponse* release_sip_response();
  ::cyberprobe::SipResponse* mutable_sip_response();
  void set_allocated_sip_response(::cyberprobe::SipResponse* sip_response);

  // .cyberprobe.SipSsl sip_ssl = 18;
  bool has_sip_ssl() const;
  void clear_sip_ssl();
  static const int kSipSslFieldNumber = 18;
  private:
  const ::cyberprobe::SipSsl& _internal_sip_ssl() const;
  public:
  const ::cyberprobe::SipSsl& sip_ssl() const;
  ::cyberprobe::SipSsl* release_sip_ssl();
  ::cyberprobe::SipSsl* mutable_sip_ssl();
  void set_allocated_sip_ssl(::cyberprobe::SipSsl* sip_ssl);

  // .cyberprobe.Imap imap = 19;
  bool has_imap() const;
  void clear_imap();
  static const int kImapFieldNumber = 19;
  private:
  const ::cyberprobe::Imap& _internal_imap() const;
  public:
  const ::cyberprobe::Imap& imap() const;
  ::cyberprobe::Imap* release_imap();
  ::cyberprobe::Imap* mutable_imap();
  void set_allocated_imap(::cyberprobe::Imap* imap);

  // .cyberprobe.Pop3 pop3 = 20;
  bool has_pop3() const;
  void clear_pop3();
  static const int kPop3FieldNumber = 20;
  private:
  const ::cyberprobe::Pop3& _internal_pop3() const;
  public:
  const ::cyberprobe::Pop3& pop3() const;
  ::cyberprobe::Pop3* release_pop3();
  ::cyberprobe::Pop3* mutable_pop3();
  void set_allocated_pop3(::cyberprobe::Pop3* pop3);

  // .cyberprobe.Pop3Ssl pop3_ssl = 21;
  bool has_pop3_ssl() const;
  void clear_pop3_ssl();
  static const int kPop3SslFieldNumber = 21;
  private:
  const ::cyberprobe::Pop3Ssl& _internal_pop3_ssl() const;
  public:
  const ::cyberprobe::Pop3Ssl& pop3_ssl() const;
  ::cyberprobe::Pop3Ssl* release_pop3_ssl();
  ::cyberprobe::Pop3Ssl* mutable_pop3_ssl();
  void set_allocated_pop3_ssl(::cyberprobe::Pop3Ssl* pop3_ssl);

  // .cyberprobe.Ntp ntp_timestamp = 22;
  bool has_ntp_timestamp() const;
  void clear_ntp_timestamp();
  static const int kNtpTimestampFieldNumber = 22;
  private:
  const ::cyberprobe::Ntp& _internal_ntp_timestamp() const;
  public:
  const ::cyberprobe::Ntp& ntp_timestamp() const;
  ::cyberprobe::Ntp* release_ntp_timestamp();
  ::cyberprobe::Ntp* mutable_ntp_timestamp();
  void set_allocated_ntp_timestamp(::cyberprobe::Ntp* ntp_timestamp);

  // .cyberprobe.Ntp ntp_control = 23;
  bool has_ntp_control() const;
  void clear_ntp_control();
  static const int kNtpControlFieldNumber = 23;
  private:
  const ::cyberprobe::Ntp& _internal_ntp_control() const;
  public:
  const ::cyberprobe::Ntp& ntp_control() const;
  ::cyberprobe::Ntp* release_ntp_control();
  ::cyberprobe::Ntp* mutable_ntp_control();
  void set_allocated_ntp_control(::cyberprobe::Ntp* ntp_control);

  // .cyberprobe.Ntp ntp_private = 24;
  bool has_ntp_private() const;
  void clear_ntp_private();
  static const int kNtpPrivateFieldNumber = 24;
  private:
  const ::cyberprobe::Ntp& _internal_ntp_private() const;
  public:
  const ::cyberprobe::Ntp& ntp_private() const;
  ::cyberprobe::Ntp* release_ntp_private();
  ::cyberprobe::Ntp* mutable_ntp_private();
  void set_allocated_ntp_private(::cyberprobe::Ntp* ntp_private);

  // .cyberprobe.FtpCommand ftp_command = 25;
  bool has_ftp_command() const;
  void clear_ftp_command();
  static const int kFtpCommandFieldNumber = 25;
  private:
  const ::cyberprobe::FtpCommand& _internal_ftp_command() const;
  public:
  const ::cyberprobe::FtpCommand& ftp_command() const;
  ::cyberprobe::FtpCommand* release_ftp_command();
  ::cyberprobe::FtpCommand* mutable_ftp_command();
  void set_allocated_ftp_command(::cyberprobe::FtpCommand* ftp_command);

  // .cyberprobe.FtpResponse ftp_response = 26;
  bool has_ftp_response() const;
  void clear_ftp_response();
  static const int kFtpResponseFieldNumber = 26;
  private:
  const ::cyberprobe::FtpResponse& _internal_ftp_response() const;
  public:
  const ::cyberprobe::FtpResponse& ftp_response() const;
  ::cyberprobe::FtpResponse* release_ftp_response();
  ::cyberprobe::FtpResponse* mutable_ftp_response();
  void set_allocated_ftp_response(::cyberprobe::FtpResponse* ftp_response);

  // .cyberprobe.SmtpCommand smtp_command = 27;
  bool has_smtp_command() const;
  void clear_smtp_command();
  static const int kSmtpCommandFieldNumber = 27;
  private:
  const ::cyberprobe::SmtpCommand& _internal_smtp_command() const;
  public:
  const ::cyberprobe::SmtpCommand& smtp_command() const;
  ::cyberprobe::SmtpCommand* release_smtp_command();
  ::cyberprobe::SmtpCommand* mutable_smtp_command();
  void set_allocated_smtp_command(::cyberprobe::SmtpCommand* smtp_command);

  // .cyberprobe.SmtpResponse smtp_response = 28;
  bool has_smtp_response() const;
  void clear_smtp_response();
  static const int kSmtpResponseFieldNumber = 28;
  private:
  const ::cyberprobe::SmtpResponse& _internal_smtp_response() const;
  public:
  const ::cyberprobe::SmtpResponse& smtp_response() const;
  ::cyberprobe::SmtpResponse* release_smtp_response();
  ::cyberprobe::SmtpResponse* mutable_smtp_response();
  void set_allocated_smtp_response(::cyberprobe::SmtpResponse* smtp_response);

  // .cyberprobe.SmtpData smtp_data = 29;
  bool has_smtp_data() const;
  void clear_smtp_data();
  static const int kSmtpDataFieldNumber = 29;
  private:
  const ::cyberprobe::SmtpData& _internal_smtp_data() const;
  public:
  const ::cyberprobe::SmtpData& smtp_data() const;
  ::cyberprobe::SmtpData* release_smtp_data();
  ::cyberprobe::SmtpData* mutable_smtp_data();
  void set_allocated_smtp_data(::cyberprobe::SmtpData* smtp_data);

  // .cyberprobe.Gre gre = 30;
  bool has_gre() const;
  void clear_gre();
  static const int kGreFieldNumber = 30;
  private:
  const ::cyberprobe::Gre& _internal_gre() const;
  public:
  const ::cyberprobe::Gre& gre() const;
  ::cyberprobe::Gre* release_gre();
  ::cyberprobe::Gre* mutable_gre();
  void set_allocated_gre(::cyberprobe::Gre* gre);

  // .cyberprobe.GrePptp gre_pptp = 31;
  bool has_gre_pptp() const;
  void clear_gre_pptp();
  static const int kGrePptpFieldNumber = 31;
  private:
  const ::cyberprobe::GrePptp& _internal_gre_pptp() const;
  public:
  const ::cyberprobe::GrePptp& gre_pptp() const;
  ::cyberprobe::GrePptp* release_gre_pptp();
  ::cyberprobe::GrePptp* mutable_gre_pptp();
  void set_allocated_gre_pptp(::cyberprobe::GrePptp* gre_pptp);

  // .cyberprobe.Esp esp = 32;
  bool has_esp() const;
  void clear_esp();
  static const int kEspFieldNumber = 32;
  private:
  const ::cyberprobe::Esp& _internal_esp() const;
  public:
  const ::cyberprobe::Esp& esp() const;
  ::cyberprobe::Esp* release_esp();
  ::cyberprobe::Esp* mutable_esp();
  void set_allocated_esp(::cyberprobe::Esp* esp);

  // .cyberprobe.UnrecognisedIpProtocol unrecognised_ip_protocol = 33;
  bool has_unrecognised_ip_protocol() const;
  void clear_unrecognised_ip_protocol();
  static const int kUnrecognisedIpProtocolFieldNumber = 33;
  private:
  const ::cyberprobe::UnrecognisedIpProtocol& _internal_unrecognised_ip_protocol() const;
  public:
  const ::cyberprobe::UnrecognisedIpProtocol& unrecognised_ip_protocol() const;
  ::cyberprobe::UnrecognisedIpProtocol* release_unrecognised_ip_protocol();
  ::cyberprobe::UnrecognisedIpProtocol* mutable_unrecognised_ip_protocol();
  void set_allocated_unrecognised_ip_protocol(::cyberprobe::UnrecognisedIpProtocol* unrecognised_ip_protocol);

  // .cyberprobe.Wlan wlan = 34;
  bool has_wlan() const;
  void clear_wlan();
  static const int kWlanFieldNumber = 34;
  private:
  const ::cyberprobe::Wlan& _internal_wlan() const;
  public:
  const ::cyberprobe::Wlan& wlan() const;
  ::cyberprobe::Wlan* release_wlan();
  ::cyberprobe::Wlan* mutable_wlan();
  void set_allocated_wlan(::cyberprobe::Wlan* wlan);

  // .cyberprobe.TlsUnknown tls_unknown = 35;
  bool has_tls_unknown() const;
  void clear_tls_unknown();
  static const int kTlsUnknownFieldNumber = 35;
  private:
  const ::cyberprobe::TlsUnknown& _internal_tls_unknown() const;
  public:
  const ::cyberprobe::TlsUnknown& tls_unknown() const;
  ::cyberprobe::TlsUnknown* release_tls_unknown();
  ::cyberprobe::TlsUnknown* mutable_tls_unknown();
  void set_allocated_tls_unknown(::cyberprobe::TlsUnknown* tls_unknown);

  // .cyberprobe.TlsClientHello tls_client_hello = 36;
  bool has_tls_client_hello() const;
  void clear_tls_client_hello();
  static const int kTlsClientHelloFieldNumber = 36;
  private:
  const ::cyberprobe::TlsClientHello& _internal_tls_client_hello() const;
  public:
  const ::cyberprobe::TlsClientHello& tls_client_hello() const;
  ::cyberprobe::TlsClientHello* release_tls_client_hello();
  ::cyberprobe::TlsClientHello* mutable_tls_client_hello();
  void set_allocated_tls_client_hello(::cyberprobe::TlsClientHello* tls_client_hello);

  // .cyberprobe.TlsServerHello tls_server_hello = 37;
  bool has_tls_server_hello() const;
  void clear_tls_server_hello();
  static const int kTlsServerHelloFieldNumber = 37;
  private:
  const ::cyberprobe::TlsServerHello& _internal_tls_server_hello() const;
  public:
  const ::cyberprobe::TlsServerHello& tls_server_hello() const;
  ::cyberprobe::TlsServerHello* release_tls_server_hello();
  ::cyberprobe::TlsServerHello* mutable_tls_server_hello();
  void set_allocated_tls_server_hello(::cyberprobe::TlsServerHello* tls_server_hello);

  // .cyberprobe.TlsCertificates tls_certificates = 38;
  bool has_tls_certificates() const;
  void clear_tls_certificates();
  static const int kTlsCertificatesFieldNumber = 38;
  private:
  const ::cyberprobe::TlsCertificates& _internal_tls_certificates() const;
  public:
  const ::cyberprobe::TlsCertificates& tls_certificates() const;
  ::cyberprobe::TlsCertificates* release_tls_certificates();
  ::cyberprobe::TlsCertificates* mutable_tls_certificates();
  void set_allocated_tls_certificates(::cyberprobe::TlsCertificates* tls_certificates);

  // .cyberprobe.TlsServerKeyExchange tls_server_key_exchange = 39;
  bool has_tls_server_key_exchange() const;
  void clear_tls_server_key_exchange();
  static const int kTlsServerKeyExchangeFieldNumber = 39;
  private:
  const ::cyberprobe::TlsServerKeyExchange& _internal_tls_server_key_exchange() const;
  public:
  const ::cyberprobe::TlsServerKeyExchange& tls_server_key_exchange() const;
  ::cyberprobe::TlsServerKeyExchange* release_tls_server_key_exchange();
  ::cyberprobe::TlsServerKeyExchange* mutable_tls_server_key_exchange();
  void set_allocated_tls_server_key_exchange(::cyberprobe::TlsServerKeyExchange* tls_server_key_exchange);

  // .cyberprobe.TlsServerHelloDone tls_server_hello_done = 40;
  bool has_tls_server_hello_done() const;
  void clear_tls_server_hello_done();
  static const int kTlsServerHelloDoneFieldNumber = 40;
  private:
  const ::cyberprobe::TlsServerHelloDone& _internal_tls_server_hello_done() const;
  public:
  const ::cyberprobe::TlsServerHelloDone& tls_server_hello_done() const;
  ::cyberprobe::TlsServerHelloDone* release_tls_server_hello_done();
  ::cyberprobe::TlsServerHelloDone* mutable_tls_server_hello_done();
  void set_allocated_tls_server_hello_done(::cyberprobe::TlsServerHelloDone* tls_server_hello_done);

  // .cyberprobe.TlsHandshakeUnknown tls_handshake_unknown = 41;
  bool has_tls_handshake_unknown() const;
  void clear_tls_handshake_unknown();
  static const int kTlsHandshakeUnknownFieldNumber = 41;
  private:
  const ::cyberprobe::TlsHandshakeUnknown& _internal_tls_handshake_unknown() const;
  public:
  const ::cyberprobe::TlsHandshakeUnknown& tls_handshake_unknown() const;
  ::cyberprobe::TlsHandshakeUnknown* release_tls_handshake_unknown();
  ::cyberprobe::TlsHandshakeUnknown* mutable_tls_handshake_unknown();
  void set_allocated_tls_handshake_unknown(::cyberprobe::TlsHandshakeUnknown* tls_handshake_unknown);

  // .cyberprobe.TlsCertificateRequest tls_certificate_request = 42;
  bool has_tls_certificate_request() const;
  void clear_tls_certificate_request();
  static const int kTlsCertificateRequestFieldNumber = 42;
  private:
  const ::cyberprobe::TlsCertificateRequest& _internal_tls_certificate_request() const;
  public:
  const ::cyberprobe::TlsCertificateRequest& tls_certificate_request() const;
  ::cyberprobe::TlsCertificateRequest* release_tls_certificate_request();
  ::cyberprobe::TlsCertificateRequest* mutable_tls_certificate_request();
  void set_allocated_tls_certificate_request(::cyberprobe::TlsCertificateRequest* tls_certificate_request);

  // .cyberprobe.TlsClientKeyExchange tls_client_key_exchange = 43;
  bool has_tls_client_key_exchange() const;
  void clear_tls_client_key_exchange();
  static const int kTlsClientKeyExchangeFieldNumber = 43;
  private:
  const ::cyberprobe::TlsClientKeyExchange& _internal_tls_client_key_exchange() const;
  public:
  const ::cyberprobe::TlsClientKeyExchange& tls_client_key_exchange() const;
  ::cyberprobe::TlsClientKeyExchange* release_tls_client_key_exchange();
  ::cyberprobe::TlsClientKeyExchange* mutable_tls_client_key_exchange();
  void set_allocated_tls_client_key_exchange(::cyberprobe::TlsClientKeyExchange* tls_client_key_exchange);

  // .cyberprobe.TlsCertificateVerify tls_certificate_verify = 44;
  bool has_tls_certificate_verify() const;
  void clear_tls_certificate_verify();
  static const int kTlsCertificateVerifyFieldNumber = 44;
  private:
  const ::cyberprobe::TlsCertificateVerify& _internal_tls_certificate_verify() const;
  public:
  const ::cyberprobe::TlsCertificateVerify& tls_certificate_verify() const;
  ::cyberprobe::TlsCertificateVerify* release_tls_certificate_verify();
  ::cyberprobe::TlsCertificateVerify* mutable_tls_certificate_verify();
  void set_allocated_tls_certificate_verify(::cyberprobe::TlsCertificateVerify* tls_certificate_verify);

  // .cyberprobe.TlsChangeCipherSpec tls_change_cipher_spec = 45;
  bool has_tls_change_cipher_spec() const;
  void clear_tls_change_cipher_spec();
  static const int kTlsChangeCipherSpecFieldNumber = 45;
  private:
  const ::cyberprobe::TlsChangeCipherSpec& _internal_tls_change_cipher_spec() const;
  public:
  const ::cyberprobe::TlsChangeCipherSpec& tls_change_cipher_spec() const;
  ::cyberprobe::TlsChangeCipherSpec* release_tls_change_cipher_spec();
  ::cyberprobe::TlsChangeCipherSpec* mutable_tls_change_cipher_spec();
  void set_allocated_tls_change_cipher_spec(::cyberprobe::TlsChangeCipherSpec* tls_change_cipher_spec);

  // .cyberprobe.TlsHandshakeFinished tls_handshake_finished = 46;
  bool has_tls_handshake_finished() const;
  void clear_tls_handshake_finished();
  static const int kTlsHandshakeFinishedFieldNumber = 46;
  private:
  const ::cyberprobe::TlsHandshakeFinished& _internal_tls_handshake_finished() const;
  public:
  const ::cyberprobe::TlsHandshakeFinished& tls_handshake_finished() const;
  ::cyberprobe::TlsHandshakeFinished* release_tls_handshake_finished();
  ::cyberprobe::TlsHandshakeFinished* mutable_tls_handshake_finished();
  void set_allocated_tls_handshake_finished(::cyberprobe::TlsHandshakeFinished* tls_handshake_finished);

  // .cyberprobe.TlsHandshakeComplete tls_handshake_complete = 47;
  bool has_tls_handshake_complete() const;
  void clear_tls_handshake_complete();
  static const int kTlsHandshakeCompleteFieldNumber = 47;
  private:
  const ::cyberprobe::TlsHandshakeComplete& _internal_tls_handshake_complete() const;
  public:
  const ::cyberprobe::TlsHandshakeComplete& tls_handshake_complete() const;
  ::cyberprobe::TlsHandshakeComplete* release_tls_handshake_complete();
  ::cyberprobe::TlsHandshakeComplete* mutable_tls_handshake_complete();
  void set_allocated_tls_handshake_complete(::cyberprobe::TlsHandshakeComplete* tls_handshake_complete);

  // .cyberprobe.TlsApplicationData tls_application_data = 48;
  bool has_tls_application_data() const;
  void clear_tls_application_data();
  static const int kTlsApplicationDataFieldNumber = 48;
  private:
  const ::cyberprobe::TlsApplicationData& _internal_tls_application_data() const;
  public:
  const ::cyberprobe::TlsApplicationData& tls_application_data() const;
  ::cyberprobe::TlsApplicationData* release_tls_application_data();
  ::cyberprobe::TlsApplicationData* mutable_tls_application_data();
  void set_allocated_tls_application_data(::cyberprobe::TlsApplicationData* tls_application_data);

  void clear_Detail();
  DetailCase Detail_case() const;
  // @@protoc_insertion_point(class_scope:cyberprobe.Event)
 private:
  void set_has_dns_message();
  void set_has_unrecognised_datagram();
  void set_has_unrecognised_stream();
  void set_has_icmp();
  void set_has_http_request();
  void set_has_http_response();
  void set_has_sip_request();
  void set_has_sip_response();
  void set_has_sip_ssl();
  void set_has_imap();
  void set_has_pop3();
  void set_has_pop3_ssl();
  void set_has_ntp_timestamp();
  void set_has_ntp_control();
  void set_has_ntp_private();
  void set_has_ftp_command();
  void set_has_ftp_response();
  void set_has_smtp_command();
  void set_has_smtp_response();
  void set_has_smtp_data();
  void set_has_gre();
  void set_has_gre_pptp();
  void set_has_esp();
  void set_has_unrecognised_ip_protocol();
  void set_has_wlan();
  void set_has_tls_unknown();
  void set_has_tls_client_hello();
  void set_has_tls_server_hello();
  void set_has_tls_certificates();
  void set_has_tls_server_key_exchange();
  void set_has_tls_server_hello_done();
  void set_has_tls_handshake_unknown();
  void set_has_tls_certificate_request();
  void set_has_tls_client_key_exchange();
  void set_has_tls_certificate_verify();
  void set_has_tls_change_cipher_spec();
  void set_has_tls_handshake_finished();
  void set_has_tls_handshake_complete();
  void set_has_tls_application_data();

  inline bool has_Detail() const;
  inline void clear_has_Detail();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> src_;
  ::google::protobuf::RepeatedPtrField< ::std::string> dest_;
  ::google::protobuf::RepeatedPtrField< ::cyberprobe::Indicator > indicators_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr device_;
  ::google::protobuf::internal::ArenaStringPtr network_;
  ::google::protobuf::internal::ArenaStringPtr origin_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::google::protobuf::Timestamp* time_;
  ::cyberprobe::Locations* location_;
  int action_;
  union DetailUnion {
    DetailUnion() {}
    ::cyberprobe::DnsMessage* dns_message_;
    ::cyberprobe::UnrecognisedDatagram* unrecognised_datagram_;
    ::cyberprobe::UnrecognisedStream* unrecognised_stream_;
    ::cyberprobe::Icmp* icmp_;
    ::cyberprobe::HttpRequest* http_request_;
    ::cyberprobe::HttpResponse* http_response_;
    ::cyberprobe::SipRequest* sip_request_;
    ::cyberprobe::SipResponse* sip_response_;
    ::cyberprobe::SipSsl* sip_ssl_;
    ::cyberprobe::Imap* imap_;
    ::cyberprobe::Pop3* pop3_;
    ::cyberprobe::Pop3Ssl* pop3_ssl_;
    ::cyberprobe::Ntp* ntp_timestamp_;
    ::cyberprobe::Ntp* ntp_control_;
    ::cyberprobe::Ntp* ntp_private_;
    ::cyberprobe::FtpCommand* ftp_command_;
    ::cyberprobe::FtpResponse* ftp_response_;
    ::cyberprobe::SmtpCommand* smtp_command_;
    ::cyberprobe::SmtpResponse* smtp_response_;
    ::cyberprobe::SmtpData* smtp_data_;
    ::cyberprobe::Gre* gre_;
    ::cyberprobe::GrePptp* gre_pptp_;
    ::cyberprobe::Esp* esp_;
    ::cyberprobe::UnrecognisedIpProtocol* unrecognised_ip_protocol_;
    ::cyberprobe::Wlan* wlan_;
    ::cyberprobe::TlsUnknown* tls_unknown_;
    ::cyberprobe::TlsClientHello* tls_client_hello_;
    ::cyberprobe::TlsServerHello* tls_server_hello_;
    ::cyberprobe::TlsCertificates* tls_certificates_;
    ::cyberprobe::TlsServerKeyExchange* tls_server_key_exchange_;
    ::cyberprobe::TlsServerHelloDone* tls_server_hello_done_;
    ::cyberprobe::TlsHandshakeUnknown* tls_handshake_unknown_;
    ::cyberprobe::TlsCertificateRequest* tls_certificate_request_;
    ::cyberprobe::TlsClientKeyExchange* tls_client_key_exchange_;
    ::cyberprobe::TlsCertificateVerify* tls_certificate_verify_;
    ::cyberprobe::TlsChangeCipherSpec* tls_change_cipher_spec_;
    ::cyberprobe::TlsHandshakeFinished* tls_handshake_finished_;
    ::cyberprobe::TlsHandshakeComplete* tls_handshake_complete_;
    ::cyberprobe::TlsApplicationData* tls_application_data_;
  } Detail_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Empty : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cyberprobe.Empty) */ {
 public:
  Empty();
  virtual ~Empty();

  Empty(const Empty& from);

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(Empty&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Empty& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  void Swap(Empty* other);
  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Empty* New() const final {
    return CreateMaybeMessage<Empty>(NULL);
  }

  Empty* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Empty& from);
  void MergeFrom(const Empty& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Empty* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cyberprobe.Empty)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cyberprobe_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Query

// string name = 1;
inline void Query::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Query::name() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Query.name)
  return name_.GetNoArena();
}
inline void Query::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.Query.name)
}
#if LANG_CXX11
inline void Query::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.Query.name)
}
#endif
inline void Query::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.Query.name)
}
inline void Query::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.Query.name)
}
inline ::std::string* Query::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.Query.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Query::release_name() {
  // @@protoc_insertion_point(field_release:cyberprobe.Query.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Query::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.Query.name)
}

// string type = 2;
inline void Query::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Query::type() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Query.type)
  return type_.GetNoArena();
}
inline void Query::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.Query.type)
}
#if LANG_CXX11
inline void Query::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.Query.type)
}
#endif
inline void Query::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.Query.type)
}
inline void Query::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.Query.type)
}
inline ::std::string* Query::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.Query.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Query::release_type() {
  // @@protoc_insertion_point(field_release:cyberprobe.Query.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Query::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.Query.type)
}

// string class = 3;
inline void Query::clear_class_() {
  class__.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Query::class_() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Query.class)
  return class__.GetNoArena();
}
inline void Query::set_class_(const ::std::string& value) {
  
  class__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.Query.class)
}
#if LANG_CXX11
inline void Query::set_class_(::std::string&& value) {
  
  class__.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.Query.class)
}
#endif
inline void Query::set_class_(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  class__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.Query.class)
}
inline void Query::set_class_(const char* value, size_t size) {
  
  class__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.Query.class)
}
inline ::std::string* Query::mutable_class_() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.Query.class)
  return class__.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Query::release_class_() {
  // @@protoc_insertion_point(field_release:cyberprobe.Query.class)
  
  return class__.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Query::set_allocated_class_(::std::string* class_) {
  if (class_ != NULL) {
    
  } else {
    
  }
  class__.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), class_);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.Query.class)
}

// -------------------------------------------------------------------

// Answer

// string name = 1;
inline void Answer::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Answer::name() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Answer.name)
  return name_.GetNoArena();
}
inline void Answer::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.Answer.name)
}
#if LANG_CXX11
inline void Answer::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.Answer.name)
}
#endif
inline void Answer::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.Answer.name)
}
inline void Answer::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.Answer.name)
}
inline ::std::string* Answer::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.Answer.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Answer::release_name() {
  // @@protoc_insertion_point(field_release:cyberprobe.Answer.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Answer::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.Answer.name)
}

// string type = 2;
inline void Answer::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Answer::type() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Answer.type)
  return type_.GetNoArena();
}
inline void Answer::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.Answer.type)
}
#if LANG_CXX11
inline void Answer::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.Answer.type)
}
#endif
inline void Answer::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.Answer.type)
}
inline void Answer::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.Answer.type)
}
inline ::std::string* Answer::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.Answer.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Answer::release_type() {
  // @@protoc_insertion_point(field_release:cyberprobe.Answer.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Answer::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.Answer.type)
}

// string class = 3;
inline void Answer::clear_class_() {
  class__.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Answer::class_() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Answer.class)
  return class__.GetNoArena();
}
inline void Answer::set_class_(const ::std::string& value) {
  
  class__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.Answer.class)
}
#if LANG_CXX11
inline void Answer::set_class_(::std::string&& value) {
  
  class__.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.Answer.class)
}
#endif
inline void Answer::set_class_(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  class__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.Answer.class)
}
inline void Answer::set_class_(const char* value, size_t size) {
  
  class__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.Answer.class)
}
inline ::std::string* Answer::mutable_class_() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.Answer.class)
  return class__.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Answer::release_class_() {
  // @@protoc_insertion_point(field_release:cyberprobe.Answer.class)
  
  return class__.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Answer::set_allocated_class_(::std::string* class_) {
  if (class_ != NULL) {
    
  } else {
    
  }
  class__.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), class_);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.Answer.class)
}

// string address = 4;
inline void Answer::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Answer::address() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Answer.address)
  return address_.GetNoArena();
}
inline void Answer::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.Answer.address)
}
#if LANG_CXX11
inline void Answer::set_address(::std::string&& value) {
  
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.Answer.address)
}
#endif
inline void Answer::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.Answer.address)
}
inline void Answer::set_address(const char* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.Answer.address)
}
inline ::std::string* Answer::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.Answer.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Answer::release_address() {
  // @@protoc_insertion_point(field_release:cyberprobe.Answer.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Answer::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.Answer.address)
}

// -------------------------------------------------------------------

// DnsMessage

// repeated .cyberprobe.Query query = 1;
inline int DnsMessage::query_size() const {
  return query_.size();
}
inline void DnsMessage::clear_query() {
  query_.Clear();
}
inline ::cyberprobe::Query* DnsMessage::mutable_query(int index) {
  // @@protoc_insertion_point(field_mutable:cyberprobe.DnsMessage.query)
  return query_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::cyberprobe::Query >*
DnsMessage::mutable_query() {
  // @@protoc_insertion_point(field_mutable_list:cyberprobe.DnsMessage.query)
  return &query_;
}
inline const ::cyberprobe::Query& DnsMessage::query(int index) const {
  // @@protoc_insertion_point(field_get:cyberprobe.DnsMessage.query)
  return query_.Get(index);
}
inline ::cyberprobe::Query* DnsMessage::add_query() {
  // @@protoc_insertion_point(field_add:cyberprobe.DnsMessage.query)
  return query_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cyberprobe::Query >&
DnsMessage::query() const {
  // @@protoc_insertion_point(field_list:cyberprobe.DnsMessage.query)
  return query_;
}

// repeated .cyberprobe.Answer answer = 2;
inline int DnsMessage::answer_size() const {
  return answer_.size();
}
inline void DnsMessage::clear_answer() {
  answer_.Clear();
}
inline ::cyberprobe::Answer* DnsMessage::mutable_answer(int index) {
  // @@protoc_insertion_point(field_mutable:cyberprobe.DnsMessage.answer)
  return answer_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::cyberprobe::Answer >*
DnsMessage::mutable_answer() {
  // @@protoc_insertion_point(field_mutable_list:cyberprobe.DnsMessage.answer)
  return &answer_;
}
inline const ::cyberprobe::Answer& DnsMessage::answer(int index) const {
  // @@protoc_insertion_point(field_get:cyberprobe.DnsMessage.answer)
  return answer_.Get(index);
}
inline ::cyberprobe::Answer* DnsMessage::add_answer() {
  // @@protoc_insertion_point(field_add:cyberprobe.DnsMessage.answer)
  return answer_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cyberprobe::Answer >&
DnsMessage::answer() const {
  // @@protoc_insertion_point(field_list:cyberprobe.DnsMessage.answer)
  return answer_;
}

// string type = 3;
inline void DnsMessage::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DnsMessage::type() const {
  // @@protoc_insertion_point(field_get:cyberprobe.DnsMessage.type)
  return type_.GetNoArena();
}
inline void DnsMessage::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.DnsMessage.type)
}
#if LANG_CXX11
inline void DnsMessage::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.DnsMessage.type)
}
#endif
inline void DnsMessage::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.DnsMessage.type)
}
inline void DnsMessage::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.DnsMessage.type)
}
inline ::std::string* DnsMessage::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.DnsMessage.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DnsMessage::release_type() {
  // @@protoc_insertion_point(field_release:cyberprobe.DnsMessage.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DnsMessage::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.DnsMessage.type)
}

// -------------------------------------------------------------------

// UnrecognisedDatagram

// bytes payload = 1;
inline void UnrecognisedDatagram::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UnrecognisedDatagram::payload() const {
  // @@protoc_insertion_point(field_get:cyberprobe.UnrecognisedDatagram.payload)
  return payload_.GetNoArena();
}
inline void UnrecognisedDatagram::set_payload(const ::std::string& value) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.UnrecognisedDatagram.payload)
}
#if LANG_CXX11
inline void UnrecognisedDatagram::set_payload(::std::string&& value) {
  
  payload_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.UnrecognisedDatagram.payload)
}
#endif
inline void UnrecognisedDatagram::set_payload(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.UnrecognisedDatagram.payload)
}
inline void UnrecognisedDatagram::set_payload(const void* value, size_t size) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.UnrecognisedDatagram.payload)
}
inline ::std::string* UnrecognisedDatagram::mutable_payload() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.UnrecognisedDatagram.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UnrecognisedDatagram::release_payload() {
  // @@protoc_insertion_point(field_release:cyberprobe.UnrecognisedDatagram.payload)
  
  return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UnrecognisedDatagram::set_allocated_payload(::std::string* payload) {
  if (payload != NULL) {
    
  } else {
    
  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.UnrecognisedDatagram.payload)
}

// -------------------------------------------------------------------

// UnrecognisedStream

// bytes payload = 1;
inline void UnrecognisedStream::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UnrecognisedStream::payload() const {
  // @@protoc_insertion_point(field_get:cyberprobe.UnrecognisedStream.payload)
  return payload_.GetNoArena();
}
inline void UnrecognisedStream::set_payload(const ::std::string& value) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.UnrecognisedStream.payload)
}
#if LANG_CXX11
inline void UnrecognisedStream::set_payload(::std::string&& value) {
  
  payload_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.UnrecognisedStream.payload)
}
#endif
inline void UnrecognisedStream::set_payload(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.UnrecognisedStream.payload)
}
inline void UnrecognisedStream::set_payload(const void* value, size_t size) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.UnrecognisedStream.payload)
}
inline ::std::string* UnrecognisedStream::mutable_payload() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.UnrecognisedStream.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UnrecognisedStream::release_payload() {
  // @@protoc_insertion_point(field_release:cyberprobe.UnrecognisedStream.payload)
  
  return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UnrecognisedStream::set_allocated_payload(::std::string* payload) {
  if (payload != NULL) {
    
  } else {
    
  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.UnrecognisedStream.payload)
}

// int64 position = 2;
inline void UnrecognisedStream::clear_position() {
  position_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 UnrecognisedStream::position() const {
  // @@protoc_insertion_point(field_get:cyberprobe.UnrecognisedStream.position)
  return position_;
}
inline void UnrecognisedStream::set_position(::google::protobuf::int64 value) {
  
  position_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.UnrecognisedStream.position)
}

// -------------------------------------------------------------------

// Icmp

// int32 type = 1;
inline void Icmp::clear_type() {
  type_ = 0;
}
inline ::google::protobuf::int32 Icmp::type() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Icmp.type)
  return type_;
}
inline void Icmp::set_type(::google::protobuf::int32 value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.Icmp.type)
}

// int32 code = 2;
inline void Icmp::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 Icmp::code() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Icmp.code)
  return code_;
}
inline void Icmp::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.Icmp.code)
}

// bytes payload = 3;
inline void Icmp::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Icmp::payload() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Icmp.payload)
  return payload_.GetNoArena();
}
inline void Icmp::set_payload(const ::std::string& value) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.Icmp.payload)
}
#if LANG_CXX11
inline void Icmp::set_payload(::std::string&& value) {
  
  payload_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.Icmp.payload)
}
#endif
inline void Icmp::set_payload(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.Icmp.payload)
}
inline void Icmp::set_payload(const void* value, size_t size) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.Icmp.payload)
}
inline ::std::string* Icmp::mutable_payload() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.Icmp.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Icmp::release_payload() {
  // @@protoc_insertion_point(field_release:cyberprobe.Icmp.payload)
  
  return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Icmp::set_allocated_payload(::std::string* payload) {
  if (payload != NULL) {
    
  } else {
    
  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.Icmp.payload)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// HttpRequest

// string method = 1;
inline void HttpRequest::clear_method() {
  method_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HttpRequest::method() const {
  // @@protoc_insertion_point(field_get:cyberprobe.HttpRequest.method)
  return method_.GetNoArena();
}
inline void HttpRequest::set_method(const ::std::string& value) {
  
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.HttpRequest.method)
}
#if LANG_CXX11
inline void HttpRequest::set_method(::std::string&& value) {
  
  method_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.HttpRequest.method)
}
#endif
inline void HttpRequest::set_method(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.HttpRequest.method)
}
inline void HttpRequest::set_method(const char* value, size_t size) {
  
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.HttpRequest.method)
}
inline ::std::string* HttpRequest::mutable_method() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.HttpRequest.method)
  return method_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HttpRequest::release_method() {
  // @@protoc_insertion_point(field_release:cyberprobe.HttpRequest.method)
  
  return method_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HttpRequest::set_allocated_method(::std::string* method) {
  if (method != NULL) {
    
  } else {
    
  }
  method_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), method);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.HttpRequest.method)
}

// map<string, string> header = 2;
inline int HttpRequest::header_size() const {
  return header_.size();
}
inline void HttpRequest::clear_header() {
  header_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
HttpRequest::header() const {
  // @@protoc_insertion_point(field_map:cyberprobe.HttpRequest.header)
  return header_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
HttpRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable_map:cyberprobe.HttpRequest.header)
  return header_.MutableMap();
}

// bytes body = 3;
inline void HttpRequest::clear_body() {
  body_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HttpRequest::body() const {
  // @@protoc_insertion_point(field_get:cyberprobe.HttpRequest.body)
  return body_.GetNoArena();
}
inline void HttpRequest::set_body(const ::std::string& value) {
  
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.HttpRequest.body)
}
#if LANG_CXX11
inline void HttpRequest::set_body(::std::string&& value) {
  
  body_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.HttpRequest.body)
}
#endif
inline void HttpRequest::set_body(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.HttpRequest.body)
}
inline void HttpRequest::set_body(const void* value, size_t size) {
  
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.HttpRequest.body)
}
inline ::std::string* HttpRequest::mutable_body() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.HttpRequest.body)
  return body_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HttpRequest::release_body() {
  // @@protoc_insertion_point(field_release:cyberprobe.HttpRequest.body)
  
  return body_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HttpRequest::set_allocated_body(::std::string* body) {
  if (body != NULL) {
    
  } else {
    
  }
  body_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), body);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.HttpRequest.body)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// HttpResponse

// int32 code = 1;
inline void HttpResponse::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 HttpResponse::code() const {
  // @@protoc_insertion_point(field_get:cyberprobe.HttpResponse.code)
  return code_;
}
inline void HttpResponse::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.HttpResponse.code)
}

// string status = 2;
inline void HttpResponse::clear_status() {
  status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HttpResponse::status() const {
  // @@protoc_insertion_point(field_get:cyberprobe.HttpResponse.status)
  return status_.GetNoArena();
}
inline void HttpResponse::set_status(const ::std::string& value) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.HttpResponse.status)
}
#if LANG_CXX11
inline void HttpResponse::set_status(::std::string&& value) {
  
  status_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.HttpResponse.status)
}
#endif
inline void HttpResponse::set_status(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.HttpResponse.status)
}
inline void HttpResponse::set_status(const char* value, size_t size) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.HttpResponse.status)
}
inline ::std::string* HttpResponse::mutable_status() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.HttpResponse.status)
  return status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HttpResponse::release_status() {
  // @@protoc_insertion_point(field_release:cyberprobe.HttpResponse.status)
  
  return status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HttpResponse::set_allocated_status(::std::string* status) {
  if (status != NULL) {
    
  } else {
    
  }
  status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.HttpResponse.status)
}

// map<string, string> header = 3;
inline int HttpResponse::header_size() const {
  return header_.size();
}
inline void HttpResponse::clear_header() {
  header_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
HttpResponse::header() const {
  // @@protoc_insertion_point(field_map:cyberprobe.HttpResponse.header)
  return header_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
HttpResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable_map:cyberprobe.HttpResponse.header)
  return header_.MutableMap();
}

// bytes body = 4;
inline void HttpResponse::clear_body() {
  body_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HttpResponse::body() const {
  // @@protoc_insertion_point(field_get:cyberprobe.HttpResponse.body)
  return body_.GetNoArena();
}
inline void HttpResponse::set_body(const ::std::string& value) {
  
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.HttpResponse.body)
}
#if LANG_CXX11
inline void HttpResponse::set_body(::std::string&& value) {
  
  body_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.HttpResponse.body)
}
#endif
inline void HttpResponse::set_body(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.HttpResponse.body)
}
inline void HttpResponse::set_body(const void* value, size_t size) {
  
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.HttpResponse.body)
}
inline ::std::string* HttpResponse::mutable_body() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.HttpResponse.body)
  return body_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HttpResponse::release_body() {
  // @@protoc_insertion_point(field_release:cyberprobe.HttpResponse.body)
  
  return body_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HttpResponse::set_allocated_body(::std::string* body) {
  if (body != NULL) {
    
  } else {
    
  }
  body_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), body);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.HttpResponse.body)
}

// -------------------------------------------------------------------

// SipRequest

// string method = 1;
inline void SipRequest::clear_method() {
  method_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SipRequest::method() const {
  // @@protoc_insertion_point(field_get:cyberprobe.SipRequest.method)
  return method_.GetNoArena();
}
inline void SipRequest::set_method(const ::std::string& value) {
  
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.SipRequest.method)
}
#if LANG_CXX11
inline void SipRequest::set_method(::std::string&& value) {
  
  method_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.SipRequest.method)
}
#endif
inline void SipRequest::set_method(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.SipRequest.method)
}
inline void SipRequest::set_method(const char* value, size_t size) {
  
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.SipRequest.method)
}
inline ::std::string* SipRequest::mutable_method() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.SipRequest.method)
  return method_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SipRequest::release_method() {
  // @@protoc_insertion_point(field_release:cyberprobe.SipRequest.method)
  
  return method_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SipRequest::set_allocated_method(::std::string* method) {
  if (method != NULL) {
    
  } else {
    
  }
  method_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), method);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.SipRequest.method)
}

// string from = 2;
inline void SipRequest::clear_from() {
  from_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SipRequest::from() const {
  // @@protoc_insertion_point(field_get:cyberprobe.SipRequest.from)
  return from_.GetNoArena();
}
inline void SipRequest::set_from(const ::std::string& value) {
  
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.SipRequest.from)
}
#if LANG_CXX11
inline void SipRequest::set_from(::std::string&& value) {
  
  from_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.SipRequest.from)
}
#endif
inline void SipRequest::set_from(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.SipRequest.from)
}
inline void SipRequest::set_from(const char* value, size_t size) {
  
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.SipRequest.from)
}
inline ::std::string* SipRequest::mutable_from() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.SipRequest.from)
  return from_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SipRequest::release_from() {
  // @@protoc_insertion_point(field_release:cyberprobe.SipRequest.from)
  
  return from_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SipRequest::set_allocated_from(::std::string* from) {
  if (from != NULL) {
    
  } else {
    
  }
  from_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.SipRequest.from)
}

// string to = 3;
inline void SipRequest::clear_to() {
  to_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SipRequest::to() const {
  // @@protoc_insertion_point(field_get:cyberprobe.SipRequest.to)
  return to_.GetNoArena();
}
inline void SipRequest::set_to(const ::std::string& value) {
  
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.SipRequest.to)
}
#if LANG_CXX11
inline void SipRequest::set_to(::std::string&& value) {
  
  to_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.SipRequest.to)
}
#endif
inline void SipRequest::set_to(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.SipRequest.to)
}
inline void SipRequest::set_to(const char* value, size_t size) {
  
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.SipRequest.to)
}
inline ::std::string* SipRequest::mutable_to() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.SipRequest.to)
  return to_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SipRequest::release_to() {
  // @@protoc_insertion_point(field_release:cyberprobe.SipRequest.to)
  
  return to_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SipRequest::set_allocated_to(::std::string* to) {
  if (to != NULL) {
    
  } else {
    
  }
  to_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), to);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.SipRequest.to)
}

// bytes payload = 4;
inline void SipRequest::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SipRequest::payload() const {
  // @@protoc_insertion_point(field_get:cyberprobe.SipRequest.payload)
  return payload_.GetNoArena();
}
inline void SipRequest::set_payload(const ::std::string& value) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.SipRequest.payload)
}
#if LANG_CXX11
inline void SipRequest::set_payload(::std::string&& value) {
  
  payload_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.SipRequest.payload)
}
#endif
inline void SipRequest::set_payload(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.SipRequest.payload)
}
inline void SipRequest::set_payload(const void* value, size_t size) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.SipRequest.payload)
}
inline ::std::string* SipRequest::mutable_payload() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.SipRequest.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SipRequest::release_payload() {
  // @@protoc_insertion_point(field_release:cyberprobe.SipRequest.payload)
  
  return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SipRequest::set_allocated_payload(::std::string* payload) {
  if (payload != NULL) {
    
  } else {
    
  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.SipRequest.payload)
}

// -------------------------------------------------------------------

// SipResponse

// int32 code = 1;
inline void SipResponse::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 SipResponse::code() const {
  // @@protoc_insertion_point(field_get:cyberprobe.SipResponse.code)
  return code_;
}
inline void SipResponse::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.SipResponse.code)
}

// string status = 2;
inline void SipResponse::clear_status() {
  status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SipResponse::status() const {
  // @@protoc_insertion_point(field_get:cyberprobe.SipResponse.status)
  return status_.GetNoArena();
}
inline void SipResponse::set_status(const ::std::string& value) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.SipResponse.status)
}
#if LANG_CXX11
inline void SipResponse::set_status(::std::string&& value) {
  
  status_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.SipResponse.status)
}
#endif
inline void SipResponse::set_status(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.SipResponse.status)
}
inline void SipResponse::set_status(const char* value, size_t size) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.SipResponse.status)
}
inline ::std::string* SipResponse::mutable_status() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.SipResponse.status)
  return status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SipResponse::release_status() {
  // @@protoc_insertion_point(field_release:cyberprobe.SipResponse.status)
  
  return status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SipResponse::set_allocated_status(::std::string* status) {
  if (status != NULL) {
    
  } else {
    
  }
  status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.SipResponse.status)
}

// string from = 3;
inline void SipResponse::clear_from() {
  from_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SipResponse::from() const {
  // @@protoc_insertion_point(field_get:cyberprobe.SipResponse.from)
  return from_.GetNoArena();
}
inline void SipResponse::set_from(const ::std::string& value) {
  
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.SipResponse.from)
}
#if LANG_CXX11
inline void SipResponse::set_from(::std::string&& value) {
  
  from_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.SipResponse.from)
}
#endif
inline void SipResponse::set_from(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.SipResponse.from)
}
inline void SipResponse::set_from(const char* value, size_t size) {
  
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.SipResponse.from)
}
inline ::std::string* SipResponse::mutable_from() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.SipResponse.from)
  return from_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SipResponse::release_from() {
  // @@protoc_insertion_point(field_release:cyberprobe.SipResponse.from)
  
  return from_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SipResponse::set_allocated_from(::std::string* from) {
  if (from != NULL) {
    
  } else {
    
  }
  from_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.SipResponse.from)
}

// string to = 4;
inline void SipResponse::clear_to() {
  to_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SipResponse::to() const {
  // @@protoc_insertion_point(field_get:cyberprobe.SipResponse.to)
  return to_.GetNoArena();
}
inline void SipResponse::set_to(const ::std::string& value) {
  
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.SipResponse.to)
}
#if LANG_CXX11
inline void SipResponse::set_to(::std::string&& value) {
  
  to_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.SipResponse.to)
}
#endif
inline void SipResponse::set_to(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.SipResponse.to)
}
inline void SipResponse::set_to(const char* value, size_t size) {
  
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.SipResponse.to)
}
inline ::std::string* SipResponse::mutable_to() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.SipResponse.to)
  return to_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SipResponse::release_to() {
  // @@protoc_insertion_point(field_release:cyberprobe.SipResponse.to)
  
  return to_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SipResponse::set_allocated_to(::std::string* to) {
  if (to != NULL) {
    
  } else {
    
  }
  to_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), to);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.SipResponse.to)
}

// bytes payload = 5;
inline void SipResponse::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SipResponse::payload() const {
  // @@protoc_insertion_point(field_get:cyberprobe.SipResponse.payload)
  return payload_.GetNoArena();
}
inline void SipResponse::set_payload(const ::std::string& value) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.SipResponse.payload)
}
#if LANG_CXX11
inline void SipResponse::set_payload(::std::string&& value) {
  
  payload_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.SipResponse.payload)
}
#endif
inline void SipResponse::set_payload(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.SipResponse.payload)
}
inline void SipResponse::set_payload(const void* value, size_t size) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.SipResponse.payload)
}
inline ::std::string* SipResponse::mutable_payload() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.SipResponse.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SipResponse::release_payload() {
  // @@protoc_insertion_point(field_release:cyberprobe.SipResponse.payload)
  
  return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SipResponse::set_allocated_payload(::std::string* payload) {
  if (payload != NULL) {
    
  } else {
    
  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.SipResponse.payload)
}

// -------------------------------------------------------------------

// SipSsl

// bytes payload = 1;
inline void SipSsl::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SipSsl::payload() const {
  // @@protoc_insertion_point(field_get:cyberprobe.SipSsl.payload)
  return payload_.GetNoArena();
}
inline void SipSsl::set_payload(const ::std::string& value) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.SipSsl.payload)
}
#if LANG_CXX11
inline void SipSsl::set_payload(::std::string&& value) {
  
  payload_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.SipSsl.payload)
}
#endif
inline void SipSsl::set_payload(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.SipSsl.payload)
}
inline void SipSsl::set_payload(const void* value, size_t size) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.SipSsl.payload)
}
inline ::std::string* SipSsl::mutable_payload() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.SipSsl.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SipSsl::release_payload() {
  // @@protoc_insertion_point(field_release:cyberprobe.SipSsl.payload)
  
  return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SipSsl::set_allocated_payload(::std::string* payload) {
  if (payload != NULL) {
    
  } else {
    
  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.SipSsl.payload)
}

// -------------------------------------------------------------------

// Imap

// bytes payload = 1;
inline void Imap::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Imap::payload() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Imap.payload)
  return payload_.GetNoArena();
}
inline void Imap::set_payload(const ::std::string& value) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.Imap.payload)
}
#if LANG_CXX11
inline void Imap::set_payload(::std::string&& value) {
  
  payload_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.Imap.payload)
}
#endif
inline void Imap::set_payload(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.Imap.payload)
}
inline void Imap::set_payload(const void* value, size_t size) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.Imap.payload)
}
inline ::std::string* Imap::mutable_payload() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.Imap.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Imap::release_payload() {
  // @@protoc_insertion_point(field_release:cyberprobe.Imap.payload)
  
  return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Imap::set_allocated_payload(::std::string* payload) {
  if (payload != NULL) {
    
  } else {
    
  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.Imap.payload)
}

// -------------------------------------------------------------------

// Pop3

// bytes payload = 1;
inline void Pop3::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Pop3::payload() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Pop3.payload)
  return payload_.GetNoArena();
}
inline void Pop3::set_payload(const ::std::string& value) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.Pop3.payload)
}
#if LANG_CXX11
inline void Pop3::set_payload(::std::string&& value) {
  
  payload_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.Pop3.payload)
}
#endif
inline void Pop3::set_payload(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.Pop3.payload)
}
inline void Pop3::set_payload(const void* value, size_t size) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.Pop3.payload)
}
inline ::std::string* Pop3::mutable_payload() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.Pop3.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Pop3::release_payload() {
  // @@protoc_insertion_point(field_release:cyberprobe.Pop3.payload)
  
  return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Pop3::set_allocated_payload(::std::string* payload) {
  if (payload != NULL) {
    
  } else {
    
  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.Pop3.payload)
}

// -------------------------------------------------------------------

// Pop3Ssl

// bytes payload = 1;
inline void Pop3Ssl::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Pop3Ssl::payload() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Pop3Ssl.payload)
  return payload_.GetNoArena();
}
inline void Pop3Ssl::set_payload(const ::std::string& value) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.Pop3Ssl.payload)
}
#if LANG_CXX11
inline void Pop3Ssl::set_payload(::std::string&& value) {
  
  payload_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.Pop3Ssl.payload)
}
#endif
inline void Pop3Ssl::set_payload(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.Pop3Ssl.payload)
}
inline void Pop3Ssl::set_payload(const void* value, size_t size) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.Pop3Ssl.payload)
}
inline ::std::string* Pop3Ssl::mutable_payload() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.Pop3Ssl.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Pop3Ssl::release_payload() {
  // @@protoc_insertion_point(field_release:cyberprobe.Pop3Ssl.payload)
  
  return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Pop3Ssl::set_allocated_payload(::std::string* payload) {
  if (payload != NULL) {
    
  } else {
    
  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.Pop3Ssl.payload)
}

// -------------------------------------------------------------------

// Ntp

// int32 version = 1;
inline void Ntp::clear_version() {
  version_ = 0;
}
inline ::google::protobuf::int32 Ntp::version() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Ntp.version)
  return version_;
}
inline void Ntp::set_version(::google::protobuf::int32 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.Ntp.version)
}

// int32 mode = 2;
inline void Ntp::clear_mode() {
  mode_ = 0;
}
inline ::google::protobuf::int32 Ntp::mode() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Ntp.mode)
  return mode_;
}
inline void Ntp::set_mode(::google::protobuf::int32 value) {
  
  mode_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.Ntp.mode)
}

// -------------------------------------------------------------------

// FtpCommand

// string command = 1;
inline void FtpCommand::clear_command() {
  command_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FtpCommand::command() const {
  // @@protoc_insertion_point(field_get:cyberprobe.FtpCommand.command)
  return command_.GetNoArena();
}
inline void FtpCommand::set_command(const ::std::string& value) {
  
  command_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.FtpCommand.command)
}
#if LANG_CXX11
inline void FtpCommand::set_command(::std::string&& value) {
  
  command_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.FtpCommand.command)
}
#endif
inline void FtpCommand::set_command(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  command_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.FtpCommand.command)
}
inline void FtpCommand::set_command(const char* value, size_t size) {
  
  command_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.FtpCommand.command)
}
inline ::std::string* FtpCommand::mutable_command() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.FtpCommand.command)
  return command_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FtpCommand::release_command() {
  // @@protoc_insertion_point(field_release:cyberprobe.FtpCommand.command)
  
  return command_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FtpCommand::set_allocated_command(::std::string* command) {
  if (command != NULL) {
    
  } else {
    
  }
  command_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), command);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.FtpCommand.command)
}

// -------------------------------------------------------------------

// FtpResponse

// int32 status = 1;
inline void FtpResponse::clear_status() {
  status_ = 0;
}
inline ::google::protobuf::int32 FtpResponse::status() const {
  // @@protoc_insertion_point(field_get:cyberprobe.FtpResponse.status)
  return status_;
}
inline void FtpResponse::set_status(::google::protobuf::int32 value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.FtpResponse.status)
}

// repeated string text = 2;
inline int FtpResponse::text_size() const {
  return text_.size();
}
inline void FtpResponse::clear_text() {
  text_.Clear();
}
inline const ::std::string& FtpResponse::text(int index) const {
  // @@protoc_insertion_point(field_get:cyberprobe.FtpResponse.text)
  return text_.Get(index);
}
inline ::std::string* FtpResponse::mutable_text(int index) {
  // @@protoc_insertion_point(field_mutable:cyberprobe.FtpResponse.text)
  return text_.Mutable(index);
}
inline void FtpResponse::set_text(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:cyberprobe.FtpResponse.text)
  text_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void FtpResponse::set_text(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:cyberprobe.FtpResponse.text)
  text_.Mutable(index)->assign(std::move(value));
}
#endif
inline void FtpResponse::set_text(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  text_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cyberprobe.FtpResponse.text)
}
inline void FtpResponse::set_text(int index, const char* value, size_t size) {
  text_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.FtpResponse.text)
}
inline ::std::string* FtpResponse::add_text() {
  // @@protoc_insertion_point(field_add_mutable:cyberprobe.FtpResponse.text)
  return text_.Add();
}
inline void FtpResponse::add_text(const ::std::string& value) {
  text_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:cyberprobe.FtpResponse.text)
}
#if LANG_CXX11
inline void FtpResponse::add_text(::std::string&& value) {
  text_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:cyberprobe.FtpResponse.text)
}
#endif
inline void FtpResponse::add_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  text_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cyberprobe.FtpResponse.text)
}
inline void FtpResponse::add_text(const char* value, size_t size) {
  text_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cyberprobe.FtpResponse.text)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FtpResponse::text() const {
  // @@protoc_insertion_point(field_list:cyberprobe.FtpResponse.text)
  return text_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FtpResponse::mutable_text() {
  // @@protoc_insertion_point(field_mutable_list:cyberprobe.FtpResponse.text)
  return &text_;
}

// -------------------------------------------------------------------

// SmtpCommand

// string command = 1;
inline void SmtpCommand::clear_command() {
  command_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SmtpCommand::command() const {
  // @@protoc_insertion_point(field_get:cyberprobe.SmtpCommand.command)
  return command_.GetNoArena();
}
inline void SmtpCommand::set_command(const ::std::string& value) {
  
  command_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.SmtpCommand.command)
}
#if LANG_CXX11
inline void SmtpCommand::set_command(::std::string&& value) {
  
  command_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.SmtpCommand.command)
}
#endif
inline void SmtpCommand::set_command(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  command_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.SmtpCommand.command)
}
inline void SmtpCommand::set_command(const char* value, size_t size) {
  
  command_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.SmtpCommand.command)
}
inline ::std::string* SmtpCommand::mutable_command() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.SmtpCommand.command)
  return command_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SmtpCommand::release_command() {
  // @@protoc_insertion_point(field_release:cyberprobe.SmtpCommand.command)
  
  return command_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SmtpCommand::set_allocated_command(::std::string* command) {
  if (command != NULL) {
    
  } else {
    
  }
  command_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), command);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.SmtpCommand.command)
}

// -------------------------------------------------------------------

// SmtpResponse

// int32 status = 1;
inline void SmtpResponse::clear_status() {
  status_ = 0;
}
inline ::google::protobuf::int32 SmtpResponse::status() const {
  // @@protoc_insertion_point(field_get:cyberprobe.SmtpResponse.status)
  return status_;
}
inline void SmtpResponse::set_status(::google::protobuf::int32 value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.SmtpResponse.status)
}

// repeated string text = 2;
inline int SmtpResponse::text_size() const {
  return text_.size();
}
inline void SmtpResponse::clear_text() {
  text_.Clear();
}
inline const ::std::string& SmtpResponse::text(int index) const {
  // @@protoc_insertion_point(field_get:cyberprobe.SmtpResponse.text)
  return text_.Get(index);
}
inline ::std::string* SmtpResponse::mutable_text(int index) {
  // @@protoc_insertion_point(field_mutable:cyberprobe.SmtpResponse.text)
  return text_.Mutable(index);
}
inline void SmtpResponse::set_text(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:cyberprobe.SmtpResponse.text)
  text_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void SmtpResponse::set_text(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:cyberprobe.SmtpResponse.text)
  text_.Mutable(index)->assign(std::move(value));
}
#endif
inline void SmtpResponse::set_text(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  text_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cyberprobe.SmtpResponse.text)
}
inline void SmtpResponse::set_text(int index, const char* value, size_t size) {
  text_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.SmtpResponse.text)
}
inline ::std::string* SmtpResponse::add_text() {
  // @@protoc_insertion_point(field_add_mutable:cyberprobe.SmtpResponse.text)
  return text_.Add();
}
inline void SmtpResponse::add_text(const ::std::string& value) {
  text_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:cyberprobe.SmtpResponse.text)
}
#if LANG_CXX11
inline void SmtpResponse::add_text(::std::string&& value) {
  text_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:cyberprobe.SmtpResponse.text)
}
#endif
inline void SmtpResponse::add_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  text_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cyberprobe.SmtpResponse.text)
}
inline void SmtpResponse::add_text(const char* value, size_t size) {
  text_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cyberprobe.SmtpResponse.text)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SmtpResponse::text() const {
  // @@protoc_insertion_point(field_list:cyberprobe.SmtpResponse.text)
  return text_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SmtpResponse::mutable_text() {
  // @@protoc_insertion_point(field_mutable_list:cyberprobe.SmtpResponse.text)
  return &text_;
}

// -------------------------------------------------------------------

// SmtpData

// string from = 1;
inline void SmtpData::clear_from() {
  from_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SmtpData::from() const {
  // @@protoc_insertion_point(field_get:cyberprobe.SmtpData.from)
  return from_.GetNoArena();
}
inline void SmtpData::set_from(const ::std::string& value) {
  
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.SmtpData.from)
}
#if LANG_CXX11
inline void SmtpData::set_from(::std::string&& value) {
  
  from_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.SmtpData.from)
}
#endif
inline void SmtpData::set_from(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.SmtpData.from)
}
inline void SmtpData::set_from(const char* value, size_t size) {
  
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.SmtpData.from)
}
inline ::std::string* SmtpData::mutable_from() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.SmtpData.from)
  return from_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SmtpData::release_from() {
  // @@protoc_insertion_point(field_release:cyberprobe.SmtpData.from)
  
  return from_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SmtpData::set_allocated_from(::std::string* from) {
  if (from != NULL) {
    
  } else {
    
  }
  from_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.SmtpData.from)
}

// repeated string to = 2;
inline int SmtpData::to_size() const {
  return to_.size();
}
inline void SmtpData::clear_to() {
  to_.Clear();
}
inline const ::std::string& SmtpData::to(int index) const {
  // @@protoc_insertion_point(field_get:cyberprobe.SmtpData.to)
  return to_.Get(index);
}
inline ::std::string* SmtpData::mutable_to(int index) {
  // @@protoc_insertion_point(field_mutable:cyberprobe.SmtpData.to)
  return to_.Mutable(index);
}
inline void SmtpData::set_to(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:cyberprobe.SmtpData.to)
  to_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void SmtpData::set_to(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:cyberprobe.SmtpData.to)
  to_.Mutable(index)->assign(std::move(value));
}
#endif
inline void SmtpData::set_to(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  to_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cyberprobe.SmtpData.to)
}
inline void SmtpData::set_to(int index, const char* value, size_t size) {
  to_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.SmtpData.to)
}
inline ::std::string* SmtpData::add_to() {
  // @@protoc_insertion_point(field_add_mutable:cyberprobe.SmtpData.to)
  return to_.Add();
}
inline void SmtpData::add_to(const ::std::string& value) {
  to_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:cyberprobe.SmtpData.to)
}
#if LANG_CXX11
inline void SmtpData::add_to(::std::string&& value) {
  to_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:cyberprobe.SmtpData.to)
}
#endif
inline void SmtpData::add_to(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  to_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cyberprobe.SmtpData.to)
}
inline void SmtpData::add_to(const char* value, size_t size) {
  to_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cyberprobe.SmtpData.to)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SmtpData::to() const {
  // @@protoc_insertion_point(field_list:cyberprobe.SmtpData.to)
  return to_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SmtpData::mutable_to() {
  // @@protoc_insertion_point(field_mutable_list:cyberprobe.SmtpData.to)
  return &to_;
}

// bytes body = 3;
inline void SmtpData::clear_body() {
  body_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SmtpData::body() const {
  // @@protoc_insertion_point(field_get:cyberprobe.SmtpData.body)
  return body_.GetNoArena();
}
inline void SmtpData::set_body(const ::std::string& value) {
  
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.SmtpData.body)
}
#if LANG_CXX11
inline void SmtpData::set_body(::std::string&& value) {
  
  body_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.SmtpData.body)
}
#endif
inline void SmtpData::set_body(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.SmtpData.body)
}
inline void SmtpData::set_body(const void* value, size_t size) {
  
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.SmtpData.body)
}
inline ::std::string* SmtpData::mutable_body() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.SmtpData.body)
  return body_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SmtpData::release_body() {
  // @@protoc_insertion_point(field_release:cyberprobe.SmtpData.body)
  
  return body_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SmtpData::set_allocated_body(::std::string* body) {
  if (body != NULL) {
    
  } else {
    
  }
  body_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), body);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.SmtpData.body)
}

// -------------------------------------------------------------------

// Gre

// string next_proto = 1;
inline void Gre::clear_next_proto() {
  next_proto_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Gre::next_proto() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Gre.next_proto)
  return next_proto_.GetNoArena();
}
inline void Gre::set_next_proto(const ::std::string& value) {
  
  next_proto_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.Gre.next_proto)
}
#if LANG_CXX11
inline void Gre::set_next_proto(::std::string&& value) {
  
  next_proto_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.Gre.next_proto)
}
#endif
inline void Gre::set_next_proto(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  next_proto_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.Gre.next_proto)
}
inline void Gre::set_next_proto(const char* value, size_t size) {
  
  next_proto_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.Gre.next_proto)
}
inline ::std::string* Gre::mutable_next_proto() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.Gre.next_proto)
  return next_proto_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Gre::release_next_proto() {
  // @@protoc_insertion_point(field_release:cyberprobe.Gre.next_proto)
  
  return next_proto_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Gre::set_allocated_next_proto(::std::string* next_proto) {
  if (next_proto != NULL) {
    
  } else {
    
  }
  next_proto_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), next_proto);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.Gre.next_proto)
}

// uint32 key = 2;
inline void Gre::clear_key() {
  key_ = 0u;
}
inline ::google::protobuf::uint32 Gre::key() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Gre.key)
  return key_;
}
inline void Gre::set_key(::google::protobuf::uint32 value) {
  
  key_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.Gre.key)
}

// uint32 sequence_number = 3;
inline void Gre::clear_sequence_number() {
  sequence_number_ = 0u;
}
inline ::google::protobuf::uint32 Gre::sequence_number() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Gre.sequence_number)
  return sequence_number_;
}
inline void Gre::set_sequence_number(::google::protobuf::uint32 value) {
  
  sequence_number_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.Gre.sequence_number)
}

// bytes payload = 4;
inline void Gre::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Gre::payload() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Gre.payload)
  return payload_.GetNoArena();
}
inline void Gre::set_payload(const ::std::string& value) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.Gre.payload)
}
#if LANG_CXX11
inline void Gre::set_payload(::std::string&& value) {
  
  payload_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.Gre.payload)
}
#endif
inline void Gre::set_payload(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.Gre.payload)
}
inline void Gre::set_payload(const void* value, size_t size) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.Gre.payload)
}
inline ::std::string* Gre::mutable_payload() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.Gre.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Gre::release_payload() {
  // @@protoc_insertion_point(field_release:cyberprobe.Gre.payload)
  
  return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Gre::set_allocated_payload(::std::string* payload) {
  if (payload != NULL) {
    
  } else {
    
  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.Gre.payload)
}

// -------------------------------------------------------------------

// GrePptp

// string next_proto = 1;
inline void GrePptp::clear_next_proto() {
  next_proto_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GrePptp::next_proto() const {
  // @@protoc_insertion_point(field_get:cyberprobe.GrePptp.next_proto)
  return next_proto_.GetNoArena();
}
inline void GrePptp::set_next_proto(const ::std::string& value) {
  
  next_proto_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.GrePptp.next_proto)
}
#if LANG_CXX11
inline void GrePptp::set_next_proto(::std::string&& value) {
  
  next_proto_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.GrePptp.next_proto)
}
#endif
inline void GrePptp::set_next_proto(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  next_proto_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.GrePptp.next_proto)
}
inline void GrePptp::set_next_proto(const char* value, size_t size) {
  
  next_proto_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.GrePptp.next_proto)
}
inline ::std::string* GrePptp::mutable_next_proto() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.GrePptp.next_proto)
  return next_proto_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GrePptp::release_next_proto() {
  // @@protoc_insertion_point(field_release:cyberprobe.GrePptp.next_proto)
  
  return next_proto_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GrePptp::set_allocated_next_proto(::std::string* next_proto) {
  if (next_proto != NULL) {
    
  } else {
    
  }
  next_proto_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), next_proto);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.GrePptp.next_proto)
}

// uint32 call_id = 2;
inline void GrePptp::clear_call_id() {
  call_id_ = 0u;
}
inline ::google::protobuf::uint32 GrePptp::call_id() const {
  // @@protoc_insertion_point(field_get:cyberprobe.GrePptp.call_id)
  return call_id_;
}
inline void GrePptp::set_call_id(::google::protobuf::uint32 value) {
  
  call_id_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.GrePptp.call_id)
}

// uint32 sequence_number = 3;
inline void GrePptp::clear_sequence_number() {
  sequence_number_ = 0u;
}
inline ::google::protobuf::uint32 GrePptp::sequence_number() const {
  // @@protoc_insertion_point(field_get:cyberprobe.GrePptp.sequence_number)
  return sequence_number_;
}
inline void GrePptp::set_sequence_number(::google::protobuf::uint32 value) {
  
  sequence_number_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.GrePptp.sequence_number)
}

// uint32 acknowledgement_number = 4;
inline void GrePptp::clear_acknowledgement_number() {
  acknowledgement_number_ = 0u;
}
inline ::google::protobuf::uint32 GrePptp::acknowledgement_number() const {
  // @@protoc_insertion_point(field_get:cyberprobe.GrePptp.acknowledgement_number)
  return acknowledgement_number_;
}
inline void GrePptp::set_acknowledgement_number(::google::protobuf::uint32 value) {
  
  acknowledgement_number_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.GrePptp.acknowledgement_number)
}

// bytes payload = 5;
inline void GrePptp::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GrePptp::payload() const {
  // @@protoc_insertion_point(field_get:cyberprobe.GrePptp.payload)
  return payload_.GetNoArena();
}
inline void GrePptp::set_payload(const ::std::string& value) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.GrePptp.payload)
}
#if LANG_CXX11
inline void GrePptp::set_payload(::std::string&& value) {
  
  payload_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.GrePptp.payload)
}
#endif
inline void GrePptp::set_payload(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.GrePptp.payload)
}
inline void GrePptp::set_payload(const void* value, size_t size) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.GrePptp.payload)
}
inline ::std::string* GrePptp::mutable_payload() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.GrePptp.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GrePptp::release_payload() {
  // @@protoc_insertion_point(field_release:cyberprobe.GrePptp.payload)
  
  return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GrePptp::set_allocated_payload(::std::string* payload) {
  if (payload != NULL) {
    
  } else {
    
  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.GrePptp.payload)
}

// uint32 payload_length = 6;
inline void GrePptp::clear_payload_length() {
  payload_length_ = 0u;
}
inline ::google::protobuf::uint32 GrePptp::payload_length() const {
  // @@protoc_insertion_point(field_get:cyberprobe.GrePptp.payload_length)
  return payload_length_;
}
inline void GrePptp::set_payload_length(::google::protobuf::uint32 value) {
  
  payload_length_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.GrePptp.payload_length)
}

// -------------------------------------------------------------------

// Esp

// uint32 spi = 1;
inline void Esp::clear_spi() {
  spi_ = 0u;
}
inline ::google::protobuf::uint32 Esp::spi() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Esp.spi)
  return spi_;
}
inline void Esp::set_spi(::google::protobuf::uint32 value) {
  
  spi_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.Esp.spi)
}

// uint32 sequence_number = 2;
inline void Esp::clear_sequence_number() {
  sequence_number_ = 0u;
}
inline ::google::protobuf::uint32 Esp::sequence_number() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Esp.sequence_number)
  return sequence_number_;
}
inline void Esp::set_sequence_number(::google::protobuf::uint32 value) {
  
  sequence_number_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.Esp.sequence_number)
}

// bytes payload = 3;
inline void Esp::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Esp::payload() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Esp.payload)
  return payload_.GetNoArena();
}
inline void Esp::set_payload(const ::std::string& value) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.Esp.payload)
}
#if LANG_CXX11
inline void Esp::set_payload(::std::string&& value) {
  
  payload_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.Esp.payload)
}
#endif
inline void Esp::set_payload(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.Esp.payload)
}
inline void Esp::set_payload(const void* value, size_t size) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.Esp.payload)
}
inline ::std::string* Esp::mutable_payload() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.Esp.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Esp::release_payload() {
  // @@protoc_insertion_point(field_release:cyberprobe.Esp.payload)
  
  return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Esp::set_allocated_payload(::std::string* payload) {
  if (payload != NULL) {
    
  } else {
    
  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.Esp.payload)
}

// uint32 payload_length = 4;
inline void Esp::clear_payload_length() {
  payload_length_ = 0u;
}
inline ::google::protobuf::uint32 Esp::payload_length() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Esp.payload_length)
  return payload_length_;
}
inline void Esp::set_payload_length(::google::protobuf::uint32 value) {
  
  payload_length_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.Esp.payload_length)
}

// -------------------------------------------------------------------

// UnrecognisedIpProtocol

// uint32 next_proto = 1;
inline void UnrecognisedIpProtocol::clear_next_proto() {
  next_proto_ = 0u;
}
inline ::google::protobuf::uint32 UnrecognisedIpProtocol::next_proto() const {
  // @@protoc_insertion_point(field_get:cyberprobe.UnrecognisedIpProtocol.next_proto)
  return next_proto_;
}
inline void UnrecognisedIpProtocol::set_next_proto(::google::protobuf::uint32 value) {
  
  next_proto_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.UnrecognisedIpProtocol.next_proto)
}

// uint32 sequence_number = 2;
inline void UnrecognisedIpProtocol::clear_sequence_number() {
  sequence_number_ = 0u;
}
inline ::google::protobuf::uint32 UnrecognisedIpProtocol::sequence_number() const {
  // @@protoc_insertion_point(field_get:cyberprobe.UnrecognisedIpProtocol.sequence_number)
  return sequence_number_;
}
inline void UnrecognisedIpProtocol::set_sequence_number(::google::protobuf::uint32 value) {
  
  sequence_number_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.UnrecognisedIpProtocol.sequence_number)
}

// bytes payload = 3;
inline void UnrecognisedIpProtocol::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UnrecognisedIpProtocol::payload() const {
  // @@protoc_insertion_point(field_get:cyberprobe.UnrecognisedIpProtocol.payload)
  return payload_.GetNoArena();
}
inline void UnrecognisedIpProtocol::set_payload(const ::std::string& value) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.UnrecognisedIpProtocol.payload)
}
#if LANG_CXX11
inline void UnrecognisedIpProtocol::set_payload(::std::string&& value) {
  
  payload_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.UnrecognisedIpProtocol.payload)
}
#endif
inline void UnrecognisedIpProtocol::set_payload(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.UnrecognisedIpProtocol.payload)
}
inline void UnrecognisedIpProtocol::set_payload(const void* value, size_t size) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.UnrecognisedIpProtocol.payload)
}
inline ::std::string* UnrecognisedIpProtocol::mutable_payload() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.UnrecognisedIpProtocol.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UnrecognisedIpProtocol::release_payload() {
  // @@protoc_insertion_point(field_release:cyberprobe.UnrecognisedIpProtocol.payload)
  
  return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UnrecognisedIpProtocol::set_allocated_payload(::std::string* payload) {
  if (payload != NULL) {
    
  } else {
    
  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.UnrecognisedIpProtocol.payload)
}

// uint32 payload_length = 4;
inline void UnrecognisedIpProtocol::clear_payload_length() {
  payload_length_ = 0u;
}
inline ::google::protobuf::uint32 UnrecognisedIpProtocol::payload_length() const {
  // @@protoc_insertion_point(field_get:cyberprobe.UnrecognisedIpProtocol.payload_length)
  return payload_length_;
}
inline void UnrecognisedIpProtocol::set_payload_length(::google::protobuf::uint32 value) {
  
  payload_length_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.UnrecognisedIpProtocol.payload_length)
}

// -------------------------------------------------------------------

// Wlan

// uint32 version = 1;
inline void Wlan::clear_version() {
  version_ = 0u;
}
inline ::google::protobuf::uint32 Wlan::version() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Wlan.version)
  return version_;
}
inline void Wlan::set_version(::google::protobuf::uint32 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.Wlan.version)
}

// uint32 type = 2;
inline void Wlan::clear_type() {
  type_ = 0u;
}
inline ::google::protobuf::uint32 Wlan::type() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Wlan.type)
  return type_;
}
inline void Wlan::set_type(::google::protobuf::uint32 value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.Wlan.type)
}

// uint32 subtype = 3;
inline void Wlan::clear_subtype() {
  subtype_ = 0u;
}
inline ::google::protobuf::uint32 Wlan::subtype() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Wlan.subtype)
  return subtype_;
}
inline void Wlan::set_subtype(::google::protobuf::uint32 value) {
  
  subtype_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.Wlan.subtype)
}

// uint32 flags = 4;
inline void Wlan::clear_flags() {
  flags_ = 0u;
}
inline ::google::protobuf::uint32 Wlan::flags() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Wlan.flags)
  return flags_;
}
inline void Wlan::set_flags(::google::protobuf::uint32 value) {
  
  flags_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.Wlan.flags)
}

// bool protected = 5;
inline void Wlan::clear_protected_() {
  protected__ = false;
}
inline bool Wlan::protected_() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Wlan.protected)
  return protected__;
}
inline void Wlan::set_protected_(bool value) {
  
  protected__ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.Wlan.protected)
}

// string filt_addr = 6;
inline void Wlan::clear_filt_addr() {
  filt_addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Wlan::filt_addr() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Wlan.filt_addr)
  return filt_addr_.GetNoArena();
}
inline void Wlan::set_filt_addr(const ::std::string& value) {
  
  filt_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.Wlan.filt_addr)
}
#if LANG_CXX11
inline void Wlan::set_filt_addr(::std::string&& value) {
  
  filt_addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.Wlan.filt_addr)
}
#endif
inline void Wlan::set_filt_addr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  filt_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.Wlan.filt_addr)
}
inline void Wlan::set_filt_addr(const char* value, size_t size) {
  
  filt_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.Wlan.filt_addr)
}
inline ::std::string* Wlan::mutable_filt_addr() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.Wlan.filt_addr)
  return filt_addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Wlan::release_filt_addr() {
  // @@protoc_insertion_point(field_release:cyberprobe.Wlan.filt_addr)
  
  return filt_addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Wlan::set_allocated_filt_addr(::std::string* filt_addr) {
  if (filt_addr != NULL) {
    
  } else {
    
  }
  filt_addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filt_addr);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.Wlan.filt_addr)
}

// uint32 frag_num = 7;
inline void Wlan::clear_frag_num() {
  frag_num_ = 0u;
}
inline ::google::protobuf::uint32 Wlan::frag_num() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Wlan.frag_num)
  return frag_num_;
}
inline void Wlan::set_frag_num(::google::protobuf::uint32 value) {
  
  frag_num_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.Wlan.frag_num)
}

// uint32 seq_num = 8;
inline void Wlan::clear_seq_num() {
  seq_num_ = 0u;
}
inline ::google::protobuf::uint32 Wlan::seq_num() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Wlan.seq_num)
  return seq_num_;
}
inline void Wlan::set_seq_num(::google::protobuf::uint32 value) {
  
  seq_num_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.Wlan.seq_num)
}

// uint32 duration = 9;
inline void Wlan::clear_duration() {
  duration_ = 0u;
}
inline ::google::protobuf::uint32 Wlan::duration() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Wlan.duration)
  return duration_;
}
inline void Wlan::set_duration(::google::protobuf::uint32 value) {
  
  duration_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.Wlan.duration)
}

// -------------------------------------------------------------------

// TlsUnknown_Tls

// uint32 version = 1;
inline void TlsUnknown_Tls::clear_version() {
  version_ = 0u;
}
inline ::google::protobuf::uint32 TlsUnknown_Tls::version() const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsUnknown.Tls.version)
  return version_;
}
inline void TlsUnknown_Tls::set_version(::google::protobuf::uint32 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.TlsUnknown.Tls.version)
}

// uint32 content_type = 2;
inline void TlsUnknown_Tls::clear_content_type() {
  content_type_ = 0u;
}
inline ::google::protobuf::uint32 TlsUnknown_Tls::content_type() const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsUnknown.Tls.content_type)
  return content_type_;
}
inline void TlsUnknown_Tls::set_content_type(::google::protobuf::uint32 value) {
  
  content_type_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.TlsUnknown.Tls.content_type)
}

// uint64 length = 3;
inline void TlsUnknown_Tls::clear_length() {
  length_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 TlsUnknown_Tls::length() const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsUnknown.Tls.length)
  return length_;
}
inline void TlsUnknown_Tls::set_length(::google::protobuf::uint64 value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.TlsUnknown.Tls.length)
}

// -------------------------------------------------------------------

// TlsUnknown

// .cyberprobe.TlsUnknown.Tls tls = 1;
inline bool TlsUnknown::has_tls() const {
  return this != internal_default_instance() && tls_ != NULL;
}
inline void TlsUnknown::clear_tls() {
  if (GetArenaNoVirtual() == NULL && tls_ != NULL) {
    delete tls_;
  }
  tls_ = NULL;
}
inline const ::cyberprobe::TlsUnknown_Tls& TlsUnknown::_internal_tls() const {
  return *tls_;
}
inline const ::cyberprobe::TlsUnknown_Tls& TlsUnknown::tls() const {
  const ::cyberprobe::TlsUnknown_Tls* p = tls_;
  // @@protoc_insertion_point(field_get:cyberprobe.TlsUnknown.tls)
  return p != NULL ? *p : *reinterpret_cast<const ::cyberprobe::TlsUnknown_Tls*>(
      &::cyberprobe::_TlsUnknown_Tls_default_instance_);
}
inline ::cyberprobe::TlsUnknown_Tls* TlsUnknown::release_tls() {
  // @@protoc_insertion_point(field_release:cyberprobe.TlsUnknown.tls)
  
  ::cyberprobe::TlsUnknown_Tls* temp = tls_;
  tls_ = NULL;
  return temp;
}
inline ::cyberprobe::TlsUnknown_Tls* TlsUnknown::mutable_tls() {
  
  if (tls_ == NULL) {
    auto* p = CreateMaybeMessage<::cyberprobe::TlsUnknown_Tls>(GetArenaNoVirtual());
    tls_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsUnknown.tls)
  return tls_;
}
inline void TlsUnknown::set_allocated_tls(::cyberprobe::TlsUnknown_Tls* tls) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tls_;
  }
  if (tls) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tls = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tls, submessage_arena);
    }
    
  } else {
    
  }
  tls_ = tls;
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.TlsUnknown.tls)
}

// -------------------------------------------------------------------

// TlsClientHello_Tls_Random

// uint64 timestamp = 1;
inline void TlsClientHello_Tls_Random::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 TlsClientHello_Tls_Random::timestamp() const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsClientHello.Tls.Random.timestamp)
  return timestamp_;
}
inline void TlsClientHello_Tls_Random::set_timestamp(::google::protobuf::uint64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.TlsClientHello.Tls.Random.timestamp)
}

// bytes data = 2;
inline void TlsClientHello_Tls_Random::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TlsClientHello_Tls_Random::data() const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsClientHello.Tls.Random.data)
  return data_.GetNoArena();
}
inline void TlsClientHello_Tls_Random::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.TlsClientHello.Tls.Random.data)
}
#if LANG_CXX11
inline void TlsClientHello_Tls_Random::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.TlsClientHello.Tls.Random.data)
}
#endif
inline void TlsClientHello_Tls_Random::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.TlsClientHello.Tls.Random.data)
}
inline void TlsClientHello_Tls_Random::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.TlsClientHello.Tls.Random.data)
}
inline ::std::string* TlsClientHello_Tls_Random::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsClientHello.Tls.Random.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TlsClientHello_Tls_Random::release_data() {
  // @@protoc_insertion_point(field_release:cyberprobe.TlsClientHello.Tls.Random.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TlsClientHello_Tls_Random::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.TlsClientHello.Tls.Random.data)
}

// -------------------------------------------------------------------

// TlsClientHello_Tls_Extension

// string name = 1;
inline void TlsClientHello_Tls_Extension::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TlsClientHello_Tls_Extension::name() const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsClientHello.Tls.Extension.name)
  return name_.GetNoArena();
}
inline void TlsClientHello_Tls_Extension::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.TlsClientHello.Tls.Extension.name)
}
#if LANG_CXX11
inline void TlsClientHello_Tls_Extension::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.TlsClientHello.Tls.Extension.name)
}
#endif
inline void TlsClientHello_Tls_Extension::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.TlsClientHello.Tls.Extension.name)
}
inline void TlsClientHello_Tls_Extension::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.TlsClientHello.Tls.Extension.name)
}
inline ::std::string* TlsClientHello_Tls_Extension::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsClientHello.Tls.Extension.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TlsClientHello_Tls_Extension::release_name() {
  // @@protoc_insertion_point(field_release:cyberprobe.TlsClientHello.Tls.Extension.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TlsClientHello_Tls_Extension::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.TlsClientHello.Tls.Extension.name)
}

// uint32 length = 2;
inline void TlsClientHello_Tls_Extension::clear_length() {
  length_ = 0u;
}
inline ::google::protobuf::uint32 TlsClientHello_Tls_Extension::length() const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsClientHello.Tls.Extension.length)
  return length_;
}
inline void TlsClientHello_Tls_Extension::set_length(::google::protobuf::uint32 value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.TlsClientHello.Tls.Extension.length)
}

// bytes data = 3;
inline void TlsClientHello_Tls_Extension::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TlsClientHello_Tls_Extension::data() const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsClientHello.Tls.Extension.data)
  return data_.GetNoArena();
}
inline void TlsClientHello_Tls_Extension::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.TlsClientHello.Tls.Extension.data)
}
#if LANG_CXX11
inline void TlsClientHello_Tls_Extension::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.TlsClientHello.Tls.Extension.data)
}
#endif
inline void TlsClientHello_Tls_Extension::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.TlsClientHello.Tls.Extension.data)
}
inline void TlsClientHello_Tls_Extension::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.TlsClientHello.Tls.Extension.data)
}
inline ::std::string* TlsClientHello_Tls_Extension::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsClientHello.Tls.Extension.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TlsClientHello_Tls_Extension::release_data() {
  // @@protoc_insertion_point(field_release:cyberprobe.TlsClientHello.Tls.Extension.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TlsClientHello_Tls_Extension::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.TlsClientHello.Tls.Extension.data)
}

// -------------------------------------------------------------------

// TlsClientHello_Tls

// uint32 version = 1;
inline void TlsClientHello_Tls::clear_version() {
  version_ = 0u;
}
inline ::google::protobuf::uint32 TlsClientHello_Tls::version() const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsClientHello.Tls.version)
  return version_;
}
inline void TlsClientHello_Tls::set_version(::google::protobuf::uint32 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.TlsClientHello.Tls.version)
}

// uint64 session_id = 2;
inline void TlsClientHello_Tls::clear_session_id() {
  session_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 TlsClientHello_Tls::session_id() const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsClientHello.Tls.session_id)
  return session_id_;
}
inline void TlsClientHello_Tls::set_session_id(::google::protobuf::uint64 value) {
  
  session_id_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.TlsClientHello.Tls.session_id)
}

// .cyberprobe.TlsClientHello.Tls.Random random = 3;
inline bool TlsClientHello_Tls::has_random() const {
  return this != internal_default_instance() && random_ != NULL;
}
inline void TlsClientHello_Tls::clear_random() {
  if (GetArenaNoVirtual() == NULL && random_ != NULL) {
    delete random_;
  }
  random_ = NULL;
}
inline const ::cyberprobe::TlsClientHello_Tls_Random& TlsClientHello_Tls::_internal_random() const {
  return *random_;
}
inline const ::cyberprobe::TlsClientHello_Tls_Random& TlsClientHello_Tls::random() const {
  const ::cyberprobe::TlsClientHello_Tls_Random* p = random_;
  // @@protoc_insertion_point(field_get:cyberprobe.TlsClientHello.Tls.random)
  return p != NULL ? *p : *reinterpret_cast<const ::cyberprobe::TlsClientHello_Tls_Random*>(
      &::cyberprobe::_TlsClientHello_Tls_Random_default_instance_);
}
inline ::cyberprobe::TlsClientHello_Tls_Random* TlsClientHello_Tls::release_random() {
  // @@protoc_insertion_point(field_release:cyberprobe.TlsClientHello.Tls.random)
  
  ::cyberprobe::TlsClientHello_Tls_Random* temp = random_;
  random_ = NULL;
  return temp;
}
inline ::cyberprobe::TlsClientHello_Tls_Random* TlsClientHello_Tls::mutable_random() {
  
  if (random_ == NULL) {
    auto* p = CreateMaybeMessage<::cyberprobe::TlsClientHello_Tls_Random>(GetArenaNoVirtual());
    random_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsClientHello.Tls.random)
  return random_;
}
inline void TlsClientHello_Tls::set_allocated_random(::cyberprobe::TlsClientHello_Tls_Random* random) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete random_;
  }
  if (random) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      random = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, random, submessage_arena);
    }
    
  } else {
    
  }
  random_ = random;
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.TlsClientHello.Tls.random)
}

// repeated string cipher_suites = 4;
inline int TlsClientHello_Tls::cipher_suites_size() const {
  return cipher_suites_.size();
}
inline void TlsClientHello_Tls::clear_cipher_suites() {
  cipher_suites_.Clear();
}
inline const ::std::string& TlsClientHello_Tls::cipher_suites(int index) const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsClientHello.Tls.cipher_suites)
  return cipher_suites_.Get(index);
}
inline ::std::string* TlsClientHello_Tls::mutable_cipher_suites(int index) {
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsClientHello.Tls.cipher_suites)
  return cipher_suites_.Mutable(index);
}
inline void TlsClientHello_Tls::set_cipher_suites(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:cyberprobe.TlsClientHello.Tls.cipher_suites)
  cipher_suites_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void TlsClientHello_Tls::set_cipher_suites(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:cyberprobe.TlsClientHello.Tls.cipher_suites)
  cipher_suites_.Mutable(index)->assign(std::move(value));
}
#endif
inline void TlsClientHello_Tls::set_cipher_suites(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  cipher_suites_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cyberprobe.TlsClientHello.Tls.cipher_suites)
}
inline void TlsClientHello_Tls::set_cipher_suites(int index, const char* value, size_t size) {
  cipher_suites_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.TlsClientHello.Tls.cipher_suites)
}
inline ::std::string* TlsClientHello_Tls::add_cipher_suites() {
  // @@protoc_insertion_point(field_add_mutable:cyberprobe.TlsClientHello.Tls.cipher_suites)
  return cipher_suites_.Add();
}
inline void TlsClientHello_Tls::add_cipher_suites(const ::std::string& value) {
  cipher_suites_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:cyberprobe.TlsClientHello.Tls.cipher_suites)
}
#if LANG_CXX11
inline void TlsClientHello_Tls::add_cipher_suites(::std::string&& value) {
  cipher_suites_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:cyberprobe.TlsClientHello.Tls.cipher_suites)
}
#endif
inline void TlsClientHello_Tls::add_cipher_suites(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  cipher_suites_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cyberprobe.TlsClientHello.Tls.cipher_suites)
}
inline void TlsClientHello_Tls::add_cipher_suites(const char* value, size_t size) {
  cipher_suites_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cyberprobe.TlsClientHello.Tls.cipher_suites)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TlsClientHello_Tls::cipher_suites() const {
  // @@protoc_insertion_point(field_list:cyberprobe.TlsClientHello.Tls.cipher_suites)
  return cipher_suites_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TlsClientHello_Tls::mutable_cipher_suites() {
  // @@protoc_insertion_point(field_mutable_list:cyberprobe.TlsClientHello.Tls.cipher_suites)
  return &cipher_suites_;
}

// repeated string compression_methods = 5;
inline int TlsClientHello_Tls::compression_methods_size() const {
  return compression_methods_.size();
}
inline void TlsClientHello_Tls::clear_compression_methods() {
  compression_methods_.Clear();
}
inline const ::std::string& TlsClientHello_Tls::compression_methods(int index) const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsClientHello.Tls.compression_methods)
  return compression_methods_.Get(index);
}
inline ::std::string* TlsClientHello_Tls::mutable_compression_methods(int index) {
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsClientHello.Tls.compression_methods)
  return compression_methods_.Mutable(index);
}
inline void TlsClientHello_Tls::set_compression_methods(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:cyberprobe.TlsClientHello.Tls.compression_methods)
  compression_methods_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void TlsClientHello_Tls::set_compression_methods(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:cyberprobe.TlsClientHello.Tls.compression_methods)
  compression_methods_.Mutable(index)->assign(std::move(value));
}
#endif
inline void TlsClientHello_Tls::set_compression_methods(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  compression_methods_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cyberprobe.TlsClientHello.Tls.compression_methods)
}
inline void TlsClientHello_Tls::set_compression_methods(int index, const char* value, size_t size) {
  compression_methods_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.TlsClientHello.Tls.compression_methods)
}
inline ::std::string* TlsClientHello_Tls::add_compression_methods() {
  // @@protoc_insertion_point(field_add_mutable:cyberprobe.TlsClientHello.Tls.compression_methods)
  return compression_methods_.Add();
}
inline void TlsClientHello_Tls::add_compression_methods(const ::std::string& value) {
  compression_methods_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:cyberprobe.TlsClientHello.Tls.compression_methods)
}
#if LANG_CXX11
inline void TlsClientHello_Tls::add_compression_methods(::std::string&& value) {
  compression_methods_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:cyberprobe.TlsClientHello.Tls.compression_methods)
}
#endif
inline void TlsClientHello_Tls::add_compression_methods(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  compression_methods_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cyberprobe.TlsClientHello.Tls.compression_methods)
}
inline void TlsClientHello_Tls::add_compression_methods(const char* value, size_t size) {
  compression_methods_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cyberprobe.TlsClientHello.Tls.compression_methods)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TlsClientHello_Tls::compression_methods() const {
  // @@protoc_insertion_point(field_list:cyberprobe.TlsClientHello.Tls.compression_methods)
  return compression_methods_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TlsClientHello_Tls::mutable_compression_methods() {
  // @@protoc_insertion_point(field_mutable_list:cyberprobe.TlsClientHello.Tls.compression_methods)
  return &compression_methods_;
}

// repeated .cyberprobe.TlsClientHello.Tls.Extension extensions = 6;
inline int TlsClientHello_Tls::extensions_size() const {
  return extensions_.size();
}
inline void TlsClientHello_Tls::clear_extensions() {
  extensions_.Clear();
}
inline ::cyberprobe::TlsClientHello_Tls_Extension* TlsClientHello_Tls::mutable_extensions(int index) {
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsClientHello.Tls.extensions)
  return extensions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::cyberprobe::TlsClientHello_Tls_Extension >*
TlsClientHello_Tls::mutable_extensions() {
  // @@protoc_insertion_point(field_mutable_list:cyberprobe.TlsClientHello.Tls.extensions)
  return &extensions_;
}
inline const ::cyberprobe::TlsClientHello_Tls_Extension& TlsClientHello_Tls::extensions(int index) const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsClientHello.Tls.extensions)
  return extensions_.Get(index);
}
inline ::cyberprobe::TlsClientHello_Tls_Extension* TlsClientHello_Tls::add_extensions() {
  // @@protoc_insertion_point(field_add:cyberprobe.TlsClientHello.Tls.extensions)
  return extensions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cyberprobe::TlsClientHello_Tls_Extension >&
TlsClientHello_Tls::extensions() const {
  // @@protoc_insertion_point(field_list:cyberprobe.TlsClientHello.Tls.extensions)
  return extensions_;
}

// -------------------------------------------------------------------

// TlsClientHello

// .cyberprobe.TlsClientHello.Tls tls = 1;
inline bool TlsClientHello::has_tls() const {
  return this != internal_default_instance() && tls_ != NULL;
}
inline void TlsClientHello::clear_tls() {
  if (GetArenaNoVirtual() == NULL && tls_ != NULL) {
    delete tls_;
  }
  tls_ = NULL;
}
inline const ::cyberprobe::TlsClientHello_Tls& TlsClientHello::_internal_tls() const {
  return *tls_;
}
inline const ::cyberprobe::TlsClientHello_Tls& TlsClientHello::tls() const {
  const ::cyberprobe::TlsClientHello_Tls* p = tls_;
  // @@protoc_insertion_point(field_get:cyberprobe.TlsClientHello.tls)
  return p != NULL ? *p : *reinterpret_cast<const ::cyberprobe::TlsClientHello_Tls*>(
      &::cyberprobe::_TlsClientHello_Tls_default_instance_);
}
inline ::cyberprobe::TlsClientHello_Tls* TlsClientHello::release_tls() {
  // @@protoc_insertion_point(field_release:cyberprobe.TlsClientHello.tls)
  
  ::cyberprobe::TlsClientHello_Tls* temp = tls_;
  tls_ = NULL;
  return temp;
}
inline ::cyberprobe::TlsClientHello_Tls* TlsClientHello::mutable_tls() {
  
  if (tls_ == NULL) {
    auto* p = CreateMaybeMessage<::cyberprobe::TlsClientHello_Tls>(GetArenaNoVirtual());
    tls_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsClientHello.tls)
  return tls_;
}
inline void TlsClientHello::set_allocated_tls(::cyberprobe::TlsClientHello_Tls* tls) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tls_;
  }
  if (tls) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tls = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tls, submessage_arena);
    }
    
  } else {
    
  }
  tls_ = tls;
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.TlsClientHello.tls)
}

// -------------------------------------------------------------------

// TlsServerHello_Tls_Random

// uint64 timestamp = 1;
inline void TlsServerHello_Tls_Random::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 TlsServerHello_Tls_Random::timestamp() const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsServerHello.Tls.Random.timestamp)
  return timestamp_;
}
inline void TlsServerHello_Tls_Random::set_timestamp(::google::protobuf::uint64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.TlsServerHello.Tls.Random.timestamp)
}

// bytes data = 2;
inline void TlsServerHello_Tls_Random::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TlsServerHello_Tls_Random::data() const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsServerHello.Tls.Random.data)
  return data_.GetNoArena();
}
inline void TlsServerHello_Tls_Random::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.TlsServerHello.Tls.Random.data)
}
#if LANG_CXX11
inline void TlsServerHello_Tls_Random::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.TlsServerHello.Tls.Random.data)
}
#endif
inline void TlsServerHello_Tls_Random::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.TlsServerHello.Tls.Random.data)
}
inline void TlsServerHello_Tls_Random::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.TlsServerHello.Tls.Random.data)
}
inline ::std::string* TlsServerHello_Tls_Random::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsServerHello.Tls.Random.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TlsServerHello_Tls_Random::release_data() {
  // @@protoc_insertion_point(field_release:cyberprobe.TlsServerHello.Tls.Random.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TlsServerHello_Tls_Random::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.TlsServerHello.Tls.Random.data)
}

// -------------------------------------------------------------------

// TlsServerHello_Tls_Extension

// string name = 1;
inline void TlsServerHello_Tls_Extension::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TlsServerHello_Tls_Extension::name() const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsServerHello.Tls.Extension.name)
  return name_.GetNoArena();
}
inline void TlsServerHello_Tls_Extension::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.TlsServerHello.Tls.Extension.name)
}
#if LANG_CXX11
inline void TlsServerHello_Tls_Extension::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.TlsServerHello.Tls.Extension.name)
}
#endif
inline void TlsServerHello_Tls_Extension::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.TlsServerHello.Tls.Extension.name)
}
inline void TlsServerHello_Tls_Extension::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.TlsServerHello.Tls.Extension.name)
}
inline ::std::string* TlsServerHello_Tls_Extension::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsServerHello.Tls.Extension.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TlsServerHello_Tls_Extension::release_name() {
  // @@protoc_insertion_point(field_release:cyberprobe.TlsServerHello.Tls.Extension.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TlsServerHello_Tls_Extension::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.TlsServerHello.Tls.Extension.name)
}

// uint32 length = 2;
inline void TlsServerHello_Tls_Extension::clear_length() {
  length_ = 0u;
}
inline ::google::protobuf::uint32 TlsServerHello_Tls_Extension::length() const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsServerHello.Tls.Extension.length)
  return length_;
}
inline void TlsServerHello_Tls_Extension::set_length(::google::protobuf::uint32 value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.TlsServerHello.Tls.Extension.length)
}

// bytes data = 3;
inline void TlsServerHello_Tls_Extension::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TlsServerHello_Tls_Extension::data() const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsServerHello.Tls.Extension.data)
  return data_.GetNoArena();
}
inline void TlsServerHello_Tls_Extension::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.TlsServerHello.Tls.Extension.data)
}
#if LANG_CXX11
inline void TlsServerHello_Tls_Extension::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.TlsServerHello.Tls.Extension.data)
}
#endif
inline void TlsServerHello_Tls_Extension::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.TlsServerHello.Tls.Extension.data)
}
inline void TlsServerHello_Tls_Extension::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.TlsServerHello.Tls.Extension.data)
}
inline ::std::string* TlsServerHello_Tls_Extension::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsServerHello.Tls.Extension.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TlsServerHello_Tls_Extension::release_data() {
  // @@protoc_insertion_point(field_release:cyberprobe.TlsServerHello.Tls.Extension.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TlsServerHello_Tls_Extension::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.TlsServerHello.Tls.Extension.data)
}

// -------------------------------------------------------------------

// TlsServerHello_Tls

// uint32 version = 1;
inline void TlsServerHello_Tls::clear_version() {
  version_ = 0u;
}
inline ::google::protobuf::uint32 TlsServerHello_Tls::version() const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsServerHello.Tls.version)
  return version_;
}
inline void TlsServerHello_Tls::set_version(::google::protobuf::uint32 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.TlsServerHello.Tls.version)
}

// uint64 session_id = 2;
inline void TlsServerHello_Tls::clear_session_id() {
  session_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 TlsServerHello_Tls::session_id() const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsServerHello.Tls.session_id)
  return session_id_;
}
inline void TlsServerHello_Tls::set_session_id(::google::protobuf::uint64 value) {
  
  session_id_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.TlsServerHello.Tls.session_id)
}

// .cyberprobe.TlsServerHello.Tls.Random random = 3;
inline bool TlsServerHello_Tls::has_random() const {
  return this != internal_default_instance() && random_ != NULL;
}
inline void TlsServerHello_Tls::clear_random() {
  if (GetArenaNoVirtual() == NULL && random_ != NULL) {
    delete random_;
  }
  random_ = NULL;
}
inline const ::cyberprobe::TlsServerHello_Tls_Random& TlsServerHello_Tls::_internal_random() const {
  return *random_;
}
inline const ::cyberprobe::TlsServerHello_Tls_Random& TlsServerHello_Tls::random() const {
  const ::cyberprobe::TlsServerHello_Tls_Random* p = random_;
  // @@protoc_insertion_point(field_get:cyberprobe.TlsServerHello.Tls.random)
  return p != NULL ? *p : *reinterpret_cast<const ::cyberprobe::TlsServerHello_Tls_Random*>(
      &::cyberprobe::_TlsServerHello_Tls_Random_default_instance_);
}
inline ::cyberprobe::TlsServerHello_Tls_Random* TlsServerHello_Tls::release_random() {
  // @@protoc_insertion_point(field_release:cyberprobe.TlsServerHello.Tls.random)
  
  ::cyberprobe::TlsServerHello_Tls_Random* temp = random_;
  random_ = NULL;
  return temp;
}
inline ::cyberprobe::TlsServerHello_Tls_Random* TlsServerHello_Tls::mutable_random() {
  
  if (random_ == NULL) {
    auto* p = CreateMaybeMessage<::cyberprobe::TlsServerHello_Tls_Random>(GetArenaNoVirtual());
    random_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsServerHello.Tls.random)
  return random_;
}
inline void TlsServerHello_Tls::set_allocated_random(::cyberprobe::TlsServerHello_Tls_Random* random) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete random_;
  }
  if (random) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      random = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, random, submessage_arena);
    }
    
  } else {
    
  }
  random_ = random;
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.TlsServerHello.Tls.random)
}

// string cipher_suite = 4;
inline void TlsServerHello_Tls::clear_cipher_suite() {
  cipher_suite_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TlsServerHello_Tls::cipher_suite() const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsServerHello.Tls.cipher_suite)
  return cipher_suite_.GetNoArena();
}
inline void TlsServerHello_Tls::set_cipher_suite(const ::std::string& value) {
  
  cipher_suite_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.TlsServerHello.Tls.cipher_suite)
}
#if LANG_CXX11
inline void TlsServerHello_Tls::set_cipher_suite(::std::string&& value) {
  
  cipher_suite_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.TlsServerHello.Tls.cipher_suite)
}
#endif
inline void TlsServerHello_Tls::set_cipher_suite(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cipher_suite_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.TlsServerHello.Tls.cipher_suite)
}
inline void TlsServerHello_Tls::set_cipher_suite(const char* value, size_t size) {
  
  cipher_suite_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.TlsServerHello.Tls.cipher_suite)
}
inline ::std::string* TlsServerHello_Tls::mutable_cipher_suite() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsServerHello.Tls.cipher_suite)
  return cipher_suite_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TlsServerHello_Tls::release_cipher_suite() {
  // @@protoc_insertion_point(field_release:cyberprobe.TlsServerHello.Tls.cipher_suite)
  
  return cipher_suite_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TlsServerHello_Tls::set_allocated_cipher_suite(::std::string* cipher_suite) {
  if (cipher_suite != NULL) {
    
  } else {
    
  }
  cipher_suite_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cipher_suite);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.TlsServerHello.Tls.cipher_suite)
}

// string compression_method = 5;
inline void TlsServerHello_Tls::clear_compression_method() {
  compression_method_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TlsServerHello_Tls::compression_method() const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsServerHello.Tls.compression_method)
  return compression_method_.GetNoArena();
}
inline void TlsServerHello_Tls::set_compression_method(const ::std::string& value) {
  
  compression_method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.TlsServerHello.Tls.compression_method)
}
#if LANG_CXX11
inline void TlsServerHello_Tls::set_compression_method(::std::string&& value) {
  
  compression_method_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.TlsServerHello.Tls.compression_method)
}
#endif
inline void TlsServerHello_Tls::set_compression_method(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  compression_method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.TlsServerHello.Tls.compression_method)
}
inline void TlsServerHello_Tls::set_compression_method(const char* value, size_t size) {
  
  compression_method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.TlsServerHello.Tls.compression_method)
}
inline ::std::string* TlsServerHello_Tls::mutable_compression_method() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsServerHello.Tls.compression_method)
  return compression_method_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TlsServerHello_Tls::release_compression_method() {
  // @@protoc_insertion_point(field_release:cyberprobe.TlsServerHello.Tls.compression_method)
  
  return compression_method_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TlsServerHello_Tls::set_allocated_compression_method(::std::string* compression_method) {
  if (compression_method != NULL) {
    
  } else {
    
  }
  compression_method_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), compression_method);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.TlsServerHello.Tls.compression_method)
}

// repeated .cyberprobe.TlsServerHello.Tls.Extension extensions = 6;
inline int TlsServerHello_Tls::extensions_size() const {
  return extensions_.size();
}
inline void TlsServerHello_Tls::clear_extensions() {
  extensions_.Clear();
}
inline ::cyberprobe::TlsServerHello_Tls_Extension* TlsServerHello_Tls::mutable_extensions(int index) {
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsServerHello.Tls.extensions)
  return extensions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::cyberprobe::TlsServerHello_Tls_Extension >*
TlsServerHello_Tls::mutable_extensions() {
  // @@protoc_insertion_point(field_mutable_list:cyberprobe.TlsServerHello.Tls.extensions)
  return &extensions_;
}
inline const ::cyberprobe::TlsServerHello_Tls_Extension& TlsServerHello_Tls::extensions(int index) const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsServerHello.Tls.extensions)
  return extensions_.Get(index);
}
inline ::cyberprobe::TlsServerHello_Tls_Extension* TlsServerHello_Tls::add_extensions() {
  // @@protoc_insertion_point(field_add:cyberprobe.TlsServerHello.Tls.extensions)
  return extensions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cyberprobe::TlsServerHello_Tls_Extension >&
TlsServerHello_Tls::extensions() const {
  // @@protoc_insertion_point(field_list:cyberprobe.TlsServerHello.Tls.extensions)
  return extensions_;
}

// -------------------------------------------------------------------

// TlsServerHello

// .cyberprobe.TlsServerHello.Tls tls = 1;
inline bool TlsServerHello::has_tls() const {
  return this != internal_default_instance() && tls_ != NULL;
}
inline void TlsServerHello::clear_tls() {
  if (GetArenaNoVirtual() == NULL && tls_ != NULL) {
    delete tls_;
  }
  tls_ = NULL;
}
inline const ::cyberprobe::TlsServerHello_Tls& TlsServerHello::_internal_tls() const {
  return *tls_;
}
inline const ::cyberprobe::TlsServerHello_Tls& TlsServerHello::tls() const {
  const ::cyberprobe::TlsServerHello_Tls* p = tls_;
  // @@protoc_insertion_point(field_get:cyberprobe.TlsServerHello.tls)
  return p != NULL ? *p : *reinterpret_cast<const ::cyberprobe::TlsServerHello_Tls*>(
      &::cyberprobe::_TlsServerHello_Tls_default_instance_);
}
inline ::cyberprobe::TlsServerHello_Tls* TlsServerHello::release_tls() {
  // @@protoc_insertion_point(field_release:cyberprobe.TlsServerHello.tls)
  
  ::cyberprobe::TlsServerHello_Tls* temp = tls_;
  tls_ = NULL;
  return temp;
}
inline ::cyberprobe::TlsServerHello_Tls* TlsServerHello::mutable_tls() {
  
  if (tls_ == NULL) {
    auto* p = CreateMaybeMessage<::cyberprobe::TlsServerHello_Tls>(GetArenaNoVirtual());
    tls_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsServerHello.tls)
  return tls_;
}
inline void TlsServerHello::set_allocated_tls(::cyberprobe::TlsServerHello_Tls* tls) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tls_;
  }
  if (tls) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tls = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tls, submessage_arena);
    }
    
  } else {
    
  }
  tls_ = tls;
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.TlsServerHello.tls)
}

// -------------------------------------------------------------------

// TlsCertificates_Tls

// repeated bytes certificates = 1;
inline int TlsCertificates_Tls::certificates_size() const {
  return certificates_.size();
}
inline void TlsCertificates_Tls::clear_certificates() {
  certificates_.Clear();
}
inline const ::std::string& TlsCertificates_Tls::certificates(int index) const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsCertificates.Tls.certificates)
  return certificates_.Get(index);
}
inline ::std::string* TlsCertificates_Tls::mutable_certificates(int index) {
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsCertificates.Tls.certificates)
  return certificates_.Mutable(index);
}
inline void TlsCertificates_Tls::set_certificates(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:cyberprobe.TlsCertificates.Tls.certificates)
  certificates_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void TlsCertificates_Tls::set_certificates(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:cyberprobe.TlsCertificates.Tls.certificates)
  certificates_.Mutable(index)->assign(std::move(value));
}
#endif
inline void TlsCertificates_Tls::set_certificates(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  certificates_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cyberprobe.TlsCertificates.Tls.certificates)
}
inline void TlsCertificates_Tls::set_certificates(int index, const void* value, size_t size) {
  certificates_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.TlsCertificates.Tls.certificates)
}
inline ::std::string* TlsCertificates_Tls::add_certificates() {
  // @@protoc_insertion_point(field_add_mutable:cyberprobe.TlsCertificates.Tls.certificates)
  return certificates_.Add();
}
inline void TlsCertificates_Tls::add_certificates(const ::std::string& value) {
  certificates_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:cyberprobe.TlsCertificates.Tls.certificates)
}
#if LANG_CXX11
inline void TlsCertificates_Tls::add_certificates(::std::string&& value) {
  certificates_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:cyberprobe.TlsCertificates.Tls.certificates)
}
#endif
inline void TlsCertificates_Tls::add_certificates(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  certificates_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cyberprobe.TlsCertificates.Tls.certificates)
}
inline void TlsCertificates_Tls::add_certificates(const void* value, size_t size) {
  certificates_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cyberprobe.TlsCertificates.Tls.certificates)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TlsCertificates_Tls::certificates() const {
  // @@protoc_insertion_point(field_list:cyberprobe.TlsCertificates.Tls.certificates)
  return certificates_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TlsCertificates_Tls::mutable_certificates() {
  // @@protoc_insertion_point(field_mutable_list:cyberprobe.TlsCertificates.Tls.certificates)
  return &certificates_;
}

// -------------------------------------------------------------------

// TlsCertificates

// .cyberprobe.TlsCertificates.Tls tls = 1;
inline bool TlsCertificates::has_tls() const {
  return this != internal_default_instance() && tls_ != NULL;
}
inline void TlsCertificates::clear_tls() {
  if (GetArenaNoVirtual() == NULL && tls_ != NULL) {
    delete tls_;
  }
  tls_ = NULL;
}
inline const ::cyberprobe::TlsCertificates_Tls& TlsCertificates::_internal_tls() const {
  return *tls_;
}
inline const ::cyberprobe::TlsCertificates_Tls& TlsCertificates::tls() const {
  const ::cyberprobe::TlsCertificates_Tls* p = tls_;
  // @@protoc_insertion_point(field_get:cyberprobe.TlsCertificates.tls)
  return p != NULL ? *p : *reinterpret_cast<const ::cyberprobe::TlsCertificates_Tls*>(
      &::cyberprobe::_TlsCertificates_Tls_default_instance_);
}
inline ::cyberprobe::TlsCertificates_Tls* TlsCertificates::release_tls() {
  // @@protoc_insertion_point(field_release:cyberprobe.TlsCertificates.tls)
  
  ::cyberprobe::TlsCertificates_Tls* temp = tls_;
  tls_ = NULL;
  return temp;
}
inline ::cyberprobe::TlsCertificates_Tls* TlsCertificates::mutable_tls() {
  
  if (tls_ == NULL) {
    auto* p = CreateMaybeMessage<::cyberprobe::TlsCertificates_Tls>(GetArenaNoVirtual());
    tls_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsCertificates.tls)
  return tls_;
}
inline void TlsCertificates::set_allocated_tls(::cyberprobe::TlsCertificates_Tls* tls) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tls_;
  }
  if (tls) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tls = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tls, submessage_arena);
    }
    
  } else {
    
  }
  tls_ = tls;
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.TlsCertificates.tls)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TlsServerKeyExchange_Tls

// string key_exchange_algorithm = 1;
inline void TlsServerKeyExchange_Tls::clear_key_exchange_algorithm() {
  key_exchange_algorithm_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TlsServerKeyExchange_Tls::key_exchange_algorithm() const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsServerKeyExchange.Tls.key_exchange_algorithm)
  return key_exchange_algorithm_.GetNoArena();
}
inline void TlsServerKeyExchange_Tls::set_key_exchange_algorithm(const ::std::string& value) {
  
  key_exchange_algorithm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.TlsServerKeyExchange.Tls.key_exchange_algorithm)
}
#if LANG_CXX11
inline void TlsServerKeyExchange_Tls::set_key_exchange_algorithm(::std::string&& value) {
  
  key_exchange_algorithm_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.TlsServerKeyExchange.Tls.key_exchange_algorithm)
}
#endif
inline void TlsServerKeyExchange_Tls::set_key_exchange_algorithm(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_exchange_algorithm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.TlsServerKeyExchange.Tls.key_exchange_algorithm)
}
inline void TlsServerKeyExchange_Tls::set_key_exchange_algorithm(const char* value, size_t size) {
  
  key_exchange_algorithm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.TlsServerKeyExchange.Tls.key_exchange_algorithm)
}
inline ::std::string* TlsServerKeyExchange_Tls::mutable_key_exchange_algorithm() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsServerKeyExchange.Tls.key_exchange_algorithm)
  return key_exchange_algorithm_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TlsServerKeyExchange_Tls::release_key_exchange_algorithm() {
  // @@protoc_insertion_point(field_release:cyberprobe.TlsServerKeyExchange.Tls.key_exchange_algorithm)
  
  return key_exchange_algorithm_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TlsServerKeyExchange_Tls::set_allocated_key_exchange_algorithm(::std::string* key_exchange_algorithm) {
  if (key_exchange_algorithm != NULL) {
    
  } else {
    
  }
  key_exchange_algorithm_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key_exchange_algorithm);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.TlsServerKeyExchange.Tls.key_exchange_algorithm)
}

// string curve_type_field = 2;
inline void TlsServerKeyExchange_Tls::clear_curve_type_field() {
  curve_type_field_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TlsServerKeyExchange_Tls::curve_type_field() const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsServerKeyExchange.Tls.curve_type_field)
  return curve_type_field_.GetNoArena();
}
inline void TlsServerKeyExchange_Tls::set_curve_type_field(const ::std::string& value) {
  
  curve_type_field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.TlsServerKeyExchange.Tls.curve_type_field)
}
#if LANG_CXX11
inline void TlsServerKeyExchange_Tls::set_curve_type_field(::std::string&& value) {
  
  curve_type_field_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.TlsServerKeyExchange.Tls.curve_type_field)
}
#endif
inline void TlsServerKeyExchange_Tls::set_curve_type_field(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  curve_type_field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.TlsServerKeyExchange.Tls.curve_type_field)
}
inline void TlsServerKeyExchange_Tls::set_curve_type_field(const char* value, size_t size) {
  
  curve_type_field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.TlsServerKeyExchange.Tls.curve_type_field)
}
inline ::std::string* TlsServerKeyExchange_Tls::mutable_curve_type_field() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsServerKeyExchange.Tls.curve_type_field)
  return curve_type_field_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TlsServerKeyExchange_Tls::release_curve_type_field() {
  // @@protoc_insertion_point(field_release:cyberprobe.TlsServerKeyExchange.Tls.curve_type_field)
  
  return curve_type_field_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TlsServerKeyExchange_Tls::set_allocated_curve_type_field(::std::string* curve_type_field) {
  if (curve_type_field != NULL) {
    
  } else {
    
  }
  curve_type_field_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), curve_type_field);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.TlsServerKeyExchange.Tls.curve_type_field)
}

// map<string, string> curve_metadata = 3;
inline int TlsServerKeyExchange_Tls::curve_metadata_size() const {
  return curve_metadata_.size();
}
inline void TlsServerKeyExchange_Tls::clear_curve_metadata() {
  curve_metadata_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
TlsServerKeyExchange_Tls::curve_metadata() const {
  // @@protoc_insertion_point(field_map:cyberprobe.TlsServerKeyExchange.Tls.curve_metadata)
  return curve_metadata_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
TlsServerKeyExchange_Tls::mutable_curve_metadata() {
  // @@protoc_insertion_point(field_mutable_map:cyberprobe.TlsServerKeyExchange.Tls.curve_metadata)
  return curve_metadata_.MutableMap();
}

// string public_key = 4;
inline void TlsServerKeyExchange_Tls::clear_public_key() {
  public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TlsServerKeyExchange_Tls::public_key() const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsServerKeyExchange.Tls.public_key)
  return public_key_.GetNoArena();
}
inline void TlsServerKeyExchange_Tls::set_public_key(const ::std::string& value) {
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.TlsServerKeyExchange.Tls.public_key)
}
#if LANG_CXX11
inline void TlsServerKeyExchange_Tls::set_public_key(::std::string&& value) {
  
  public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.TlsServerKeyExchange.Tls.public_key)
}
#endif
inline void TlsServerKeyExchange_Tls::set_public_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.TlsServerKeyExchange.Tls.public_key)
}
inline void TlsServerKeyExchange_Tls::set_public_key(const char* value, size_t size) {
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.TlsServerKeyExchange.Tls.public_key)
}
inline ::std::string* TlsServerKeyExchange_Tls::mutable_public_key() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsServerKeyExchange.Tls.public_key)
  return public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TlsServerKeyExchange_Tls::release_public_key() {
  // @@protoc_insertion_point(field_release:cyberprobe.TlsServerKeyExchange.Tls.public_key)
  
  return public_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TlsServerKeyExchange_Tls::set_allocated_public_key(::std::string* public_key) {
  if (public_key != NULL) {
    
  } else {
    
  }
  public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_key);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.TlsServerKeyExchange.Tls.public_key)
}

// string signature_hash_algorithm = 5;
inline void TlsServerKeyExchange_Tls::clear_signature_hash_algorithm() {
  signature_hash_algorithm_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TlsServerKeyExchange_Tls::signature_hash_algorithm() const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsServerKeyExchange.Tls.signature_hash_algorithm)
  return signature_hash_algorithm_.GetNoArena();
}
inline void TlsServerKeyExchange_Tls::set_signature_hash_algorithm(const ::std::string& value) {
  
  signature_hash_algorithm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.TlsServerKeyExchange.Tls.signature_hash_algorithm)
}
#if LANG_CXX11
inline void TlsServerKeyExchange_Tls::set_signature_hash_algorithm(::std::string&& value) {
  
  signature_hash_algorithm_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.TlsServerKeyExchange.Tls.signature_hash_algorithm)
}
#endif
inline void TlsServerKeyExchange_Tls::set_signature_hash_algorithm(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  signature_hash_algorithm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.TlsServerKeyExchange.Tls.signature_hash_algorithm)
}
inline void TlsServerKeyExchange_Tls::set_signature_hash_algorithm(const char* value, size_t size) {
  
  signature_hash_algorithm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.TlsServerKeyExchange.Tls.signature_hash_algorithm)
}
inline ::std::string* TlsServerKeyExchange_Tls::mutable_signature_hash_algorithm() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsServerKeyExchange.Tls.signature_hash_algorithm)
  return signature_hash_algorithm_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TlsServerKeyExchange_Tls::release_signature_hash_algorithm() {
  // @@protoc_insertion_point(field_release:cyberprobe.TlsServerKeyExchange.Tls.signature_hash_algorithm)
  
  return signature_hash_algorithm_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TlsServerKeyExchange_Tls::set_allocated_signature_hash_algorithm(::std::string* signature_hash_algorithm) {
  if (signature_hash_algorithm != NULL) {
    
  } else {
    
  }
  signature_hash_algorithm_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature_hash_algorithm);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.TlsServerKeyExchange.Tls.signature_hash_algorithm)
}

// string signature_algorithm = 6;
inline void TlsServerKeyExchange_Tls::clear_signature_algorithm() {
  signature_algorithm_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TlsServerKeyExchange_Tls::signature_algorithm() const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsServerKeyExchange.Tls.signature_algorithm)
  return signature_algorithm_.GetNoArena();
}
inline void TlsServerKeyExchange_Tls::set_signature_algorithm(const ::std::string& value) {
  
  signature_algorithm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.TlsServerKeyExchange.Tls.signature_algorithm)
}
#if LANG_CXX11
inline void TlsServerKeyExchange_Tls::set_signature_algorithm(::std::string&& value) {
  
  signature_algorithm_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.TlsServerKeyExchange.Tls.signature_algorithm)
}
#endif
inline void TlsServerKeyExchange_Tls::set_signature_algorithm(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  signature_algorithm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.TlsServerKeyExchange.Tls.signature_algorithm)
}
inline void TlsServerKeyExchange_Tls::set_signature_algorithm(const char* value, size_t size) {
  
  signature_algorithm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.TlsServerKeyExchange.Tls.signature_algorithm)
}
inline ::std::string* TlsServerKeyExchange_Tls::mutable_signature_algorithm() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsServerKeyExchange.Tls.signature_algorithm)
  return signature_algorithm_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TlsServerKeyExchange_Tls::release_signature_algorithm() {
  // @@protoc_insertion_point(field_release:cyberprobe.TlsServerKeyExchange.Tls.signature_algorithm)
  
  return signature_algorithm_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TlsServerKeyExchange_Tls::set_allocated_signature_algorithm(::std::string* signature_algorithm) {
  if (signature_algorithm != NULL) {
    
  } else {
    
  }
  signature_algorithm_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature_algorithm);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.TlsServerKeyExchange.Tls.signature_algorithm)
}

// string signature_hash = 7;
inline void TlsServerKeyExchange_Tls::clear_signature_hash() {
  signature_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TlsServerKeyExchange_Tls::signature_hash() const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsServerKeyExchange.Tls.signature_hash)
  return signature_hash_.GetNoArena();
}
inline void TlsServerKeyExchange_Tls::set_signature_hash(const ::std::string& value) {
  
  signature_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.TlsServerKeyExchange.Tls.signature_hash)
}
#if LANG_CXX11
inline void TlsServerKeyExchange_Tls::set_signature_hash(::std::string&& value) {
  
  signature_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.TlsServerKeyExchange.Tls.signature_hash)
}
#endif
inline void TlsServerKeyExchange_Tls::set_signature_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  signature_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.TlsServerKeyExchange.Tls.signature_hash)
}
inline void TlsServerKeyExchange_Tls::set_signature_hash(const char* value, size_t size) {
  
  signature_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.TlsServerKeyExchange.Tls.signature_hash)
}
inline ::std::string* TlsServerKeyExchange_Tls::mutable_signature_hash() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsServerKeyExchange.Tls.signature_hash)
  return signature_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TlsServerKeyExchange_Tls::release_signature_hash() {
  // @@protoc_insertion_point(field_release:cyberprobe.TlsServerKeyExchange.Tls.signature_hash)
  
  return signature_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TlsServerKeyExchange_Tls::set_allocated_signature_hash(::std::string* signature_hash) {
  if (signature_hash != NULL) {
    
  } else {
    
  }
  signature_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature_hash);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.TlsServerKeyExchange.Tls.signature_hash)
}

// -------------------------------------------------------------------

// TlsServerKeyExchange

// .cyberprobe.TlsServerKeyExchange.Tls tls = 1;
inline bool TlsServerKeyExchange::has_tls() const {
  return this != internal_default_instance() && tls_ != NULL;
}
inline void TlsServerKeyExchange::clear_tls() {
  if (GetArenaNoVirtual() == NULL && tls_ != NULL) {
    delete tls_;
  }
  tls_ = NULL;
}
inline const ::cyberprobe::TlsServerKeyExchange_Tls& TlsServerKeyExchange::_internal_tls() const {
  return *tls_;
}
inline const ::cyberprobe::TlsServerKeyExchange_Tls& TlsServerKeyExchange::tls() const {
  const ::cyberprobe::TlsServerKeyExchange_Tls* p = tls_;
  // @@protoc_insertion_point(field_get:cyberprobe.TlsServerKeyExchange.tls)
  return p != NULL ? *p : *reinterpret_cast<const ::cyberprobe::TlsServerKeyExchange_Tls*>(
      &::cyberprobe::_TlsServerKeyExchange_Tls_default_instance_);
}
inline ::cyberprobe::TlsServerKeyExchange_Tls* TlsServerKeyExchange::release_tls() {
  // @@protoc_insertion_point(field_release:cyberprobe.TlsServerKeyExchange.tls)
  
  ::cyberprobe::TlsServerKeyExchange_Tls* temp = tls_;
  tls_ = NULL;
  return temp;
}
inline ::cyberprobe::TlsServerKeyExchange_Tls* TlsServerKeyExchange::mutable_tls() {
  
  if (tls_ == NULL) {
    auto* p = CreateMaybeMessage<::cyberprobe::TlsServerKeyExchange_Tls>(GetArenaNoVirtual());
    tls_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsServerKeyExchange.tls)
  return tls_;
}
inline void TlsServerKeyExchange::set_allocated_tls(::cyberprobe::TlsServerKeyExchange_Tls* tls) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tls_;
  }
  if (tls) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tls = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tls, submessage_arena);
    }
    
  } else {
    
  }
  tls_ = tls;
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.TlsServerKeyExchange.tls)
}

// -------------------------------------------------------------------

// TlsServerHelloDone_Tls

// -------------------------------------------------------------------

// TlsServerHelloDone

// .cyberprobe.TlsServerHelloDone.Tls tls = 1;
inline bool TlsServerHelloDone::has_tls() const {
  return this != internal_default_instance() && tls_ != NULL;
}
inline void TlsServerHelloDone::clear_tls() {
  if (GetArenaNoVirtual() == NULL && tls_ != NULL) {
    delete tls_;
  }
  tls_ = NULL;
}
inline const ::cyberprobe::TlsServerHelloDone_Tls& TlsServerHelloDone::_internal_tls() const {
  return *tls_;
}
inline const ::cyberprobe::TlsServerHelloDone_Tls& TlsServerHelloDone::tls() const {
  const ::cyberprobe::TlsServerHelloDone_Tls* p = tls_;
  // @@protoc_insertion_point(field_get:cyberprobe.TlsServerHelloDone.tls)
  return p != NULL ? *p : *reinterpret_cast<const ::cyberprobe::TlsServerHelloDone_Tls*>(
      &::cyberprobe::_TlsServerHelloDone_Tls_default_instance_);
}
inline ::cyberprobe::TlsServerHelloDone_Tls* TlsServerHelloDone::release_tls() {
  // @@protoc_insertion_point(field_release:cyberprobe.TlsServerHelloDone.tls)
  
  ::cyberprobe::TlsServerHelloDone_Tls* temp = tls_;
  tls_ = NULL;
  return temp;
}
inline ::cyberprobe::TlsServerHelloDone_Tls* TlsServerHelloDone::mutable_tls() {
  
  if (tls_ == NULL) {
    auto* p = CreateMaybeMessage<::cyberprobe::TlsServerHelloDone_Tls>(GetArenaNoVirtual());
    tls_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsServerHelloDone.tls)
  return tls_;
}
inline void TlsServerHelloDone::set_allocated_tls(::cyberprobe::TlsServerHelloDone_Tls* tls) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tls_;
  }
  if (tls) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tls = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tls, submessage_arena);
    }
    
  } else {
    
  }
  tls_ = tls;
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.TlsServerHelloDone.tls)
}

// -------------------------------------------------------------------

// TlsHandshakeUnknown_Tls

// string type = 1;
inline void TlsHandshakeUnknown_Tls::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TlsHandshakeUnknown_Tls::type() const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsHandshakeUnknown.Tls.type)
  return type_.GetNoArena();
}
inline void TlsHandshakeUnknown_Tls::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.TlsHandshakeUnknown.Tls.type)
}
#if LANG_CXX11
inline void TlsHandshakeUnknown_Tls::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.TlsHandshakeUnknown.Tls.type)
}
#endif
inline void TlsHandshakeUnknown_Tls::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.TlsHandshakeUnknown.Tls.type)
}
inline void TlsHandshakeUnknown_Tls::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.TlsHandshakeUnknown.Tls.type)
}
inline ::std::string* TlsHandshakeUnknown_Tls::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsHandshakeUnknown.Tls.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TlsHandshakeUnknown_Tls::release_type() {
  // @@protoc_insertion_point(field_release:cyberprobe.TlsHandshakeUnknown.Tls.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TlsHandshakeUnknown_Tls::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.TlsHandshakeUnknown.Tls.type)
}

// uint32 length = 2;
inline void TlsHandshakeUnknown_Tls::clear_length() {
  length_ = 0u;
}
inline ::google::protobuf::uint32 TlsHandshakeUnknown_Tls::length() const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsHandshakeUnknown.Tls.length)
  return length_;
}
inline void TlsHandshakeUnknown_Tls::set_length(::google::protobuf::uint32 value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.TlsHandshakeUnknown.Tls.length)
}

// -------------------------------------------------------------------

// TlsHandshakeUnknown

// .cyberprobe.TlsHandshakeUnknown.Tls tls = 1;
inline bool TlsHandshakeUnknown::has_tls() const {
  return this != internal_default_instance() && tls_ != NULL;
}
inline void TlsHandshakeUnknown::clear_tls() {
  if (GetArenaNoVirtual() == NULL && tls_ != NULL) {
    delete tls_;
  }
  tls_ = NULL;
}
inline const ::cyberprobe::TlsHandshakeUnknown_Tls& TlsHandshakeUnknown::_internal_tls() const {
  return *tls_;
}
inline const ::cyberprobe::TlsHandshakeUnknown_Tls& TlsHandshakeUnknown::tls() const {
  const ::cyberprobe::TlsHandshakeUnknown_Tls* p = tls_;
  // @@protoc_insertion_point(field_get:cyberprobe.TlsHandshakeUnknown.tls)
  return p != NULL ? *p : *reinterpret_cast<const ::cyberprobe::TlsHandshakeUnknown_Tls*>(
      &::cyberprobe::_TlsHandshakeUnknown_Tls_default_instance_);
}
inline ::cyberprobe::TlsHandshakeUnknown_Tls* TlsHandshakeUnknown::release_tls() {
  // @@protoc_insertion_point(field_release:cyberprobe.TlsHandshakeUnknown.tls)
  
  ::cyberprobe::TlsHandshakeUnknown_Tls* temp = tls_;
  tls_ = NULL;
  return temp;
}
inline ::cyberprobe::TlsHandshakeUnknown_Tls* TlsHandshakeUnknown::mutable_tls() {
  
  if (tls_ == NULL) {
    auto* p = CreateMaybeMessage<::cyberprobe::TlsHandshakeUnknown_Tls>(GetArenaNoVirtual());
    tls_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsHandshakeUnknown.tls)
  return tls_;
}
inline void TlsHandshakeUnknown::set_allocated_tls(::cyberprobe::TlsHandshakeUnknown_Tls* tls) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tls_;
  }
  if (tls) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tls = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tls, submessage_arena);
    }
    
  } else {
    
  }
  tls_ = tls;
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.TlsHandshakeUnknown.tls)
}

// -------------------------------------------------------------------

// TlsCertificateRequest_Tls_SignatureAlgorithm

// string hash_algorithm = 1;
inline void TlsCertificateRequest_Tls_SignatureAlgorithm::clear_hash_algorithm() {
  hash_algorithm_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TlsCertificateRequest_Tls_SignatureAlgorithm::hash_algorithm() const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsCertificateRequest.Tls.SignatureAlgorithm.hash_algorithm)
  return hash_algorithm_.GetNoArena();
}
inline void TlsCertificateRequest_Tls_SignatureAlgorithm::set_hash_algorithm(const ::std::string& value) {
  
  hash_algorithm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.TlsCertificateRequest.Tls.SignatureAlgorithm.hash_algorithm)
}
#if LANG_CXX11
inline void TlsCertificateRequest_Tls_SignatureAlgorithm::set_hash_algorithm(::std::string&& value) {
  
  hash_algorithm_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.TlsCertificateRequest.Tls.SignatureAlgorithm.hash_algorithm)
}
#endif
inline void TlsCertificateRequest_Tls_SignatureAlgorithm::set_hash_algorithm(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_algorithm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.TlsCertificateRequest.Tls.SignatureAlgorithm.hash_algorithm)
}
inline void TlsCertificateRequest_Tls_SignatureAlgorithm::set_hash_algorithm(const char* value, size_t size) {
  
  hash_algorithm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.TlsCertificateRequest.Tls.SignatureAlgorithm.hash_algorithm)
}
inline ::std::string* TlsCertificateRequest_Tls_SignatureAlgorithm::mutable_hash_algorithm() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsCertificateRequest.Tls.SignatureAlgorithm.hash_algorithm)
  return hash_algorithm_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TlsCertificateRequest_Tls_SignatureAlgorithm::release_hash_algorithm() {
  // @@protoc_insertion_point(field_release:cyberprobe.TlsCertificateRequest.Tls.SignatureAlgorithm.hash_algorithm)
  
  return hash_algorithm_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TlsCertificateRequest_Tls_SignatureAlgorithm::set_allocated_hash_algorithm(::std::string* hash_algorithm) {
  if (hash_algorithm != NULL) {
    
  } else {
    
  }
  hash_algorithm_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash_algorithm);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.TlsCertificateRequest.Tls.SignatureAlgorithm.hash_algorithm)
}

// string signature_algorithm = 2;
inline void TlsCertificateRequest_Tls_SignatureAlgorithm::clear_signature_algorithm() {
  signature_algorithm_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TlsCertificateRequest_Tls_SignatureAlgorithm::signature_algorithm() const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsCertificateRequest.Tls.SignatureAlgorithm.signature_algorithm)
  return signature_algorithm_.GetNoArena();
}
inline void TlsCertificateRequest_Tls_SignatureAlgorithm::set_signature_algorithm(const ::std::string& value) {
  
  signature_algorithm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.TlsCertificateRequest.Tls.SignatureAlgorithm.signature_algorithm)
}
#if LANG_CXX11
inline void TlsCertificateRequest_Tls_SignatureAlgorithm::set_signature_algorithm(::std::string&& value) {
  
  signature_algorithm_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.TlsCertificateRequest.Tls.SignatureAlgorithm.signature_algorithm)
}
#endif
inline void TlsCertificateRequest_Tls_SignatureAlgorithm::set_signature_algorithm(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  signature_algorithm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.TlsCertificateRequest.Tls.SignatureAlgorithm.signature_algorithm)
}
inline void TlsCertificateRequest_Tls_SignatureAlgorithm::set_signature_algorithm(const char* value, size_t size) {
  
  signature_algorithm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.TlsCertificateRequest.Tls.SignatureAlgorithm.signature_algorithm)
}
inline ::std::string* TlsCertificateRequest_Tls_SignatureAlgorithm::mutable_signature_algorithm() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsCertificateRequest.Tls.SignatureAlgorithm.signature_algorithm)
  return signature_algorithm_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TlsCertificateRequest_Tls_SignatureAlgorithm::release_signature_algorithm() {
  // @@protoc_insertion_point(field_release:cyberprobe.TlsCertificateRequest.Tls.SignatureAlgorithm.signature_algorithm)
  
  return signature_algorithm_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TlsCertificateRequest_Tls_SignatureAlgorithm::set_allocated_signature_algorithm(::std::string* signature_algorithm) {
  if (signature_algorithm != NULL) {
    
  } else {
    
  }
  signature_algorithm_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature_algorithm);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.TlsCertificateRequest.Tls.SignatureAlgorithm.signature_algorithm)
}

// -------------------------------------------------------------------

// TlsCertificateRequest_Tls

// repeated string certificate_types = 1;
inline int TlsCertificateRequest_Tls::certificate_types_size() const {
  return certificate_types_.size();
}
inline void TlsCertificateRequest_Tls::clear_certificate_types() {
  certificate_types_.Clear();
}
inline const ::std::string& TlsCertificateRequest_Tls::certificate_types(int index) const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsCertificateRequest.Tls.certificate_types)
  return certificate_types_.Get(index);
}
inline ::std::string* TlsCertificateRequest_Tls::mutable_certificate_types(int index) {
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsCertificateRequest.Tls.certificate_types)
  return certificate_types_.Mutable(index);
}
inline void TlsCertificateRequest_Tls::set_certificate_types(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:cyberprobe.TlsCertificateRequest.Tls.certificate_types)
  certificate_types_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void TlsCertificateRequest_Tls::set_certificate_types(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:cyberprobe.TlsCertificateRequest.Tls.certificate_types)
  certificate_types_.Mutable(index)->assign(std::move(value));
}
#endif
inline void TlsCertificateRequest_Tls::set_certificate_types(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  certificate_types_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cyberprobe.TlsCertificateRequest.Tls.certificate_types)
}
inline void TlsCertificateRequest_Tls::set_certificate_types(int index, const char* value, size_t size) {
  certificate_types_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.TlsCertificateRequest.Tls.certificate_types)
}
inline ::std::string* TlsCertificateRequest_Tls::add_certificate_types() {
  // @@protoc_insertion_point(field_add_mutable:cyberprobe.TlsCertificateRequest.Tls.certificate_types)
  return certificate_types_.Add();
}
inline void TlsCertificateRequest_Tls::add_certificate_types(const ::std::string& value) {
  certificate_types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:cyberprobe.TlsCertificateRequest.Tls.certificate_types)
}
#if LANG_CXX11
inline void TlsCertificateRequest_Tls::add_certificate_types(::std::string&& value) {
  certificate_types_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:cyberprobe.TlsCertificateRequest.Tls.certificate_types)
}
#endif
inline void TlsCertificateRequest_Tls::add_certificate_types(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  certificate_types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cyberprobe.TlsCertificateRequest.Tls.certificate_types)
}
inline void TlsCertificateRequest_Tls::add_certificate_types(const char* value, size_t size) {
  certificate_types_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cyberprobe.TlsCertificateRequest.Tls.certificate_types)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TlsCertificateRequest_Tls::certificate_types() const {
  // @@protoc_insertion_point(field_list:cyberprobe.TlsCertificateRequest.Tls.certificate_types)
  return certificate_types_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TlsCertificateRequest_Tls::mutable_certificate_types() {
  // @@protoc_insertion_point(field_mutable_list:cyberprobe.TlsCertificateRequest.Tls.certificate_types)
  return &certificate_types_;
}

// repeated .cyberprobe.TlsCertificateRequest.Tls.SignatureAlgorithm signature_algorithms = 2;
inline int TlsCertificateRequest_Tls::signature_algorithms_size() const {
  return signature_algorithms_.size();
}
inline void TlsCertificateRequest_Tls::clear_signature_algorithms() {
  signature_algorithms_.Clear();
}
inline ::cyberprobe::TlsCertificateRequest_Tls_SignatureAlgorithm* TlsCertificateRequest_Tls::mutable_signature_algorithms(int index) {
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsCertificateRequest.Tls.signature_algorithms)
  return signature_algorithms_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::cyberprobe::TlsCertificateRequest_Tls_SignatureAlgorithm >*
TlsCertificateRequest_Tls::mutable_signature_algorithms() {
  // @@protoc_insertion_point(field_mutable_list:cyberprobe.TlsCertificateRequest.Tls.signature_algorithms)
  return &signature_algorithms_;
}
inline const ::cyberprobe::TlsCertificateRequest_Tls_SignatureAlgorithm& TlsCertificateRequest_Tls::signature_algorithms(int index) const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsCertificateRequest.Tls.signature_algorithms)
  return signature_algorithms_.Get(index);
}
inline ::cyberprobe::TlsCertificateRequest_Tls_SignatureAlgorithm* TlsCertificateRequest_Tls::add_signature_algorithms() {
  // @@protoc_insertion_point(field_add:cyberprobe.TlsCertificateRequest.Tls.signature_algorithms)
  return signature_algorithms_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cyberprobe::TlsCertificateRequest_Tls_SignatureAlgorithm >&
TlsCertificateRequest_Tls::signature_algorithms() const {
  // @@protoc_insertion_point(field_list:cyberprobe.TlsCertificateRequest.Tls.signature_algorithms)
  return signature_algorithms_;
}

// string distinguished_names = 3;
inline void TlsCertificateRequest_Tls::clear_distinguished_names() {
  distinguished_names_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TlsCertificateRequest_Tls::distinguished_names() const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsCertificateRequest.Tls.distinguished_names)
  return distinguished_names_.GetNoArena();
}
inline void TlsCertificateRequest_Tls::set_distinguished_names(const ::std::string& value) {
  
  distinguished_names_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.TlsCertificateRequest.Tls.distinguished_names)
}
#if LANG_CXX11
inline void TlsCertificateRequest_Tls::set_distinguished_names(::std::string&& value) {
  
  distinguished_names_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.TlsCertificateRequest.Tls.distinguished_names)
}
#endif
inline void TlsCertificateRequest_Tls::set_distinguished_names(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  distinguished_names_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.TlsCertificateRequest.Tls.distinguished_names)
}
inline void TlsCertificateRequest_Tls::set_distinguished_names(const char* value, size_t size) {
  
  distinguished_names_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.TlsCertificateRequest.Tls.distinguished_names)
}
inline ::std::string* TlsCertificateRequest_Tls::mutable_distinguished_names() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsCertificateRequest.Tls.distinguished_names)
  return distinguished_names_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TlsCertificateRequest_Tls::release_distinguished_names() {
  // @@protoc_insertion_point(field_release:cyberprobe.TlsCertificateRequest.Tls.distinguished_names)
  
  return distinguished_names_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TlsCertificateRequest_Tls::set_allocated_distinguished_names(::std::string* distinguished_names) {
  if (distinguished_names != NULL) {
    
  } else {
    
  }
  distinguished_names_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), distinguished_names);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.TlsCertificateRequest.Tls.distinguished_names)
}

// -------------------------------------------------------------------

// TlsCertificateRequest

// .cyberprobe.TlsCertificateRequest.Tls tls = 1;
inline bool TlsCertificateRequest::has_tls() const {
  return this != internal_default_instance() && tls_ != NULL;
}
inline void TlsCertificateRequest::clear_tls() {
  if (GetArenaNoVirtual() == NULL && tls_ != NULL) {
    delete tls_;
  }
  tls_ = NULL;
}
inline const ::cyberprobe::TlsCertificateRequest_Tls& TlsCertificateRequest::_internal_tls() const {
  return *tls_;
}
inline const ::cyberprobe::TlsCertificateRequest_Tls& TlsCertificateRequest::tls() const {
  const ::cyberprobe::TlsCertificateRequest_Tls* p = tls_;
  // @@protoc_insertion_point(field_get:cyberprobe.TlsCertificateRequest.tls)
  return p != NULL ? *p : *reinterpret_cast<const ::cyberprobe::TlsCertificateRequest_Tls*>(
      &::cyberprobe::_TlsCertificateRequest_Tls_default_instance_);
}
inline ::cyberprobe::TlsCertificateRequest_Tls* TlsCertificateRequest::release_tls() {
  // @@protoc_insertion_point(field_release:cyberprobe.TlsCertificateRequest.tls)
  
  ::cyberprobe::TlsCertificateRequest_Tls* temp = tls_;
  tls_ = NULL;
  return temp;
}
inline ::cyberprobe::TlsCertificateRequest_Tls* TlsCertificateRequest::mutable_tls() {
  
  if (tls_ == NULL) {
    auto* p = CreateMaybeMessage<::cyberprobe::TlsCertificateRequest_Tls>(GetArenaNoVirtual());
    tls_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsCertificateRequest.tls)
  return tls_;
}
inline void TlsCertificateRequest::set_allocated_tls(::cyberprobe::TlsCertificateRequest_Tls* tls) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tls_;
  }
  if (tls) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tls = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tls, submessage_arena);
    }
    
  } else {
    
  }
  tls_ = tls;
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.TlsCertificateRequest.tls)
}

// -------------------------------------------------------------------

// TlsClientKeyExchange_Tls

// string key = 1;
inline void TlsClientKeyExchange_Tls::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TlsClientKeyExchange_Tls::key() const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsClientKeyExchange.Tls.key)
  return key_.GetNoArena();
}
inline void TlsClientKeyExchange_Tls::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.TlsClientKeyExchange.Tls.key)
}
#if LANG_CXX11
inline void TlsClientKeyExchange_Tls::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.TlsClientKeyExchange.Tls.key)
}
#endif
inline void TlsClientKeyExchange_Tls::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.TlsClientKeyExchange.Tls.key)
}
inline void TlsClientKeyExchange_Tls::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.TlsClientKeyExchange.Tls.key)
}
inline ::std::string* TlsClientKeyExchange_Tls::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsClientKeyExchange.Tls.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TlsClientKeyExchange_Tls::release_key() {
  // @@protoc_insertion_point(field_release:cyberprobe.TlsClientKeyExchange.Tls.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TlsClientKeyExchange_Tls::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.TlsClientKeyExchange.Tls.key)
}

// -------------------------------------------------------------------

// TlsClientKeyExchange

// .cyberprobe.TlsClientKeyExchange.Tls tls = 1;
inline bool TlsClientKeyExchange::has_tls() const {
  return this != internal_default_instance() && tls_ != NULL;
}
inline void TlsClientKeyExchange::clear_tls() {
  if (GetArenaNoVirtual() == NULL && tls_ != NULL) {
    delete tls_;
  }
  tls_ = NULL;
}
inline const ::cyberprobe::TlsClientKeyExchange_Tls& TlsClientKeyExchange::_internal_tls() const {
  return *tls_;
}
inline const ::cyberprobe::TlsClientKeyExchange_Tls& TlsClientKeyExchange::tls() const {
  const ::cyberprobe::TlsClientKeyExchange_Tls* p = tls_;
  // @@protoc_insertion_point(field_get:cyberprobe.TlsClientKeyExchange.tls)
  return p != NULL ? *p : *reinterpret_cast<const ::cyberprobe::TlsClientKeyExchange_Tls*>(
      &::cyberprobe::_TlsClientKeyExchange_Tls_default_instance_);
}
inline ::cyberprobe::TlsClientKeyExchange_Tls* TlsClientKeyExchange::release_tls() {
  // @@protoc_insertion_point(field_release:cyberprobe.TlsClientKeyExchange.tls)
  
  ::cyberprobe::TlsClientKeyExchange_Tls* temp = tls_;
  tls_ = NULL;
  return temp;
}
inline ::cyberprobe::TlsClientKeyExchange_Tls* TlsClientKeyExchange::mutable_tls() {
  
  if (tls_ == NULL) {
    auto* p = CreateMaybeMessage<::cyberprobe::TlsClientKeyExchange_Tls>(GetArenaNoVirtual());
    tls_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsClientKeyExchange.tls)
  return tls_;
}
inline void TlsClientKeyExchange::set_allocated_tls(::cyberprobe::TlsClientKeyExchange_Tls* tls) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tls_;
  }
  if (tls) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tls = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tls, submessage_arena);
    }
    
  } else {
    
  }
  tls_ = tls;
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.TlsClientKeyExchange.tls)
}

// -------------------------------------------------------------------

// TlsCertificateVerify_Tls_SignatureAlgorithm

// string hash_algorithm = 1;
inline void TlsCertificateVerify_Tls_SignatureAlgorithm::clear_hash_algorithm() {
  hash_algorithm_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TlsCertificateVerify_Tls_SignatureAlgorithm::hash_algorithm() const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsCertificateVerify.Tls.SignatureAlgorithm.hash_algorithm)
  return hash_algorithm_.GetNoArena();
}
inline void TlsCertificateVerify_Tls_SignatureAlgorithm::set_hash_algorithm(const ::std::string& value) {
  
  hash_algorithm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.TlsCertificateVerify.Tls.SignatureAlgorithm.hash_algorithm)
}
#if LANG_CXX11
inline void TlsCertificateVerify_Tls_SignatureAlgorithm::set_hash_algorithm(::std::string&& value) {
  
  hash_algorithm_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.TlsCertificateVerify.Tls.SignatureAlgorithm.hash_algorithm)
}
#endif
inline void TlsCertificateVerify_Tls_SignatureAlgorithm::set_hash_algorithm(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_algorithm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.TlsCertificateVerify.Tls.SignatureAlgorithm.hash_algorithm)
}
inline void TlsCertificateVerify_Tls_SignatureAlgorithm::set_hash_algorithm(const char* value, size_t size) {
  
  hash_algorithm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.TlsCertificateVerify.Tls.SignatureAlgorithm.hash_algorithm)
}
inline ::std::string* TlsCertificateVerify_Tls_SignatureAlgorithm::mutable_hash_algorithm() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsCertificateVerify.Tls.SignatureAlgorithm.hash_algorithm)
  return hash_algorithm_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TlsCertificateVerify_Tls_SignatureAlgorithm::release_hash_algorithm() {
  // @@protoc_insertion_point(field_release:cyberprobe.TlsCertificateVerify.Tls.SignatureAlgorithm.hash_algorithm)
  
  return hash_algorithm_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TlsCertificateVerify_Tls_SignatureAlgorithm::set_allocated_hash_algorithm(::std::string* hash_algorithm) {
  if (hash_algorithm != NULL) {
    
  } else {
    
  }
  hash_algorithm_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash_algorithm);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.TlsCertificateVerify.Tls.SignatureAlgorithm.hash_algorithm)
}

// string signature_algorithm = 2;
inline void TlsCertificateVerify_Tls_SignatureAlgorithm::clear_signature_algorithm() {
  signature_algorithm_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TlsCertificateVerify_Tls_SignatureAlgorithm::signature_algorithm() const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsCertificateVerify.Tls.SignatureAlgorithm.signature_algorithm)
  return signature_algorithm_.GetNoArena();
}
inline void TlsCertificateVerify_Tls_SignatureAlgorithm::set_signature_algorithm(const ::std::string& value) {
  
  signature_algorithm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.TlsCertificateVerify.Tls.SignatureAlgorithm.signature_algorithm)
}
#if LANG_CXX11
inline void TlsCertificateVerify_Tls_SignatureAlgorithm::set_signature_algorithm(::std::string&& value) {
  
  signature_algorithm_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.TlsCertificateVerify.Tls.SignatureAlgorithm.signature_algorithm)
}
#endif
inline void TlsCertificateVerify_Tls_SignatureAlgorithm::set_signature_algorithm(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  signature_algorithm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.TlsCertificateVerify.Tls.SignatureAlgorithm.signature_algorithm)
}
inline void TlsCertificateVerify_Tls_SignatureAlgorithm::set_signature_algorithm(const char* value, size_t size) {
  
  signature_algorithm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.TlsCertificateVerify.Tls.SignatureAlgorithm.signature_algorithm)
}
inline ::std::string* TlsCertificateVerify_Tls_SignatureAlgorithm::mutable_signature_algorithm() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsCertificateVerify.Tls.SignatureAlgorithm.signature_algorithm)
  return signature_algorithm_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TlsCertificateVerify_Tls_SignatureAlgorithm::release_signature_algorithm() {
  // @@protoc_insertion_point(field_release:cyberprobe.TlsCertificateVerify.Tls.SignatureAlgorithm.signature_algorithm)
  
  return signature_algorithm_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TlsCertificateVerify_Tls_SignatureAlgorithm::set_allocated_signature_algorithm(::std::string* signature_algorithm) {
  if (signature_algorithm != NULL) {
    
  } else {
    
  }
  signature_algorithm_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature_algorithm);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.TlsCertificateVerify.Tls.SignatureAlgorithm.signature_algorithm)
}

// -------------------------------------------------------------------

// TlsCertificateVerify_Tls

// repeated .cyberprobe.TlsCertificateVerify.Tls.SignatureAlgorithm signature_algorithms = 2;
inline int TlsCertificateVerify_Tls::signature_algorithms_size() const {
  return signature_algorithms_.size();
}
inline void TlsCertificateVerify_Tls::clear_signature_algorithms() {
  signature_algorithms_.Clear();
}
inline ::cyberprobe::TlsCertificateVerify_Tls_SignatureAlgorithm* TlsCertificateVerify_Tls::mutable_signature_algorithms(int index) {
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsCertificateVerify.Tls.signature_algorithms)
  return signature_algorithms_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::cyberprobe::TlsCertificateVerify_Tls_SignatureAlgorithm >*
TlsCertificateVerify_Tls::mutable_signature_algorithms() {
  // @@protoc_insertion_point(field_mutable_list:cyberprobe.TlsCertificateVerify.Tls.signature_algorithms)
  return &signature_algorithms_;
}
inline const ::cyberprobe::TlsCertificateVerify_Tls_SignatureAlgorithm& TlsCertificateVerify_Tls::signature_algorithms(int index) const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsCertificateVerify.Tls.signature_algorithms)
  return signature_algorithms_.Get(index);
}
inline ::cyberprobe::TlsCertificateVerify_Tls_SignatureAlgorithm* TlsCertificateVerify_Tls::add_signature_algorithms() {
  // @@protoc_insertion_point(field_add:cyberprobe.TlsCertificateVerify.Tls.signature_algorithms)
  return signature_algorithms_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cyberprobe::TlsCertificateVerify_Tls_SignatureAlgorithm >&
TlsCertificateVerify_Tls::signature_algorithms() const {
  // @@protoc_insertion_point(field_list:cyberprobe.TlsCertificateVerify.Tls.signature_algorithms)
  return signature_algorithms_;
}

// string signature = 3;
inline void TlsCertificateVerify_Tls::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TlsCertificateVerify_Tls::signature() const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsCertificateVerify.Tls.signature)
  return signature_.GetNoArena();
}
inline void TlsCertificateVerify_Tls::set_signature(const ::std::string& value) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.TlsCertificateVerify.Tls.signature)
}
#if LANG_CXX11
inline void TlsCertificateVerify_Tls::set_signature(::std::string&& value) {
  
  signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.TlsCertificateVerify.Tls.signature)
}
#endif
inline void TlsCertificateVerify_Tls::set_signature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.TlsCertificateVerify.Tls.signature)
}
inline void TlsCertificateVerify_Tls::set_signature(const char* value, size_t size) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.TlsCertificateVerify.Tls.signature)
}
inline ::std::string* TlsCertificateVerify_Tls::mutable_signature() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsCertificateVerify.Tls.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TlsCertificateVerify_Tls::release_signature() {
  // @@protoc_insertion_point(field_release:cyberprobe.TlsCertificateVerify.Tls.signature)
  
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TlsCertificateVerify_Tls::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    
  } else {
    
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.TlsCertificateVerify.Tls.signature)
}

// -------------------------------------------------------------------

// TlsCertificateVerify

// .cyberprobe.TlsCertificateVerify.Tls tls = 1;
inline bool TlsCertificateVerify::has_tls() const {
  return this != internal_default_instance() && tls_ != NULL;
}
inline void TlsCertificateVerify::clear_tls() {
  if (GetArenaNoVirtual() == NULL && tls_ != NULL) {
    delete tls_;
  }
  tls_ = NULL;
}
inline const ::cyberprobe::TlsCertificateVerify_Tls& TlsCertificateVerify::_internal_tls() const {
  return *tls_;
}
inline const ::cyberprobe::TlsCertificateVerify_Tls& TlsCertificateVerify::tls() const {
  const ::cyberprobe::TlsCertificateVerify_Tls* p = tls_;
  // @@protoc_insertion_point(field_get:cyberprobe.TlsCertificateVerify.tls)
  return p != NULL ? *p : *reinterpret_cast<const ::cyberprobe::TlsCertificateVerify_Tls*>(
      &::cyberprobe::_TlsCertificateVerify_Tls_default_instance_);
}
inline ::cyberprobe::TlsCertificateVerify_Tls* TlsCertificateVerify::release_tls() {
  // @@protoc_insertion_point(field_release:cyberprobe.TlsCertificateVerify.tls)
  
  ::cyberprobe::TlsCertificateVerify_Tls* temp = tls_;
  tls_ = NULL;
  return temp;
}
inline ::cyberprobe::TlsCertificateVerify_Tls* TlsCertificateVerify::mutable_tls() {
  
  if (tls_ == NULL) {
    auto* p = CreateMaybeMessage<::cyberprobe::TlsCertificateVerify_Tls>(GetArenaNoVirtual());
    tls_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsCertificateVerify.tls)
  return tls_;
}
inline void TlsCertificateVerify::set_allocated_tls(::cyberprobe::TlsCertificateVerify_Tls* tls) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tls_;
  }
  if (tls) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tls = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tls, submessage_arena);
    }
    
  } else {
    
  }
  tls_ = tls;
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.TlsCertificateVerify.tls)
}

// -------------------------------------------------------------------

// TlsChangeCipherSpec_Tls

// string value = 1;
inline void TlsChangeCipherSpec_Tls::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TlsChangeCipherSpec_Tls::value() const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsChangeCipherSpec.Tls.value)
  return value_.GetNoArena();
}
inline void TlsChangeCipherSpec_Tls::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.TlsChangeCipherSpec.Tls.value)
}
#if LANG_CXX11
inline void TlsChangeCipherSpec_Tls::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.TlsChangeCipherSpec.Tls.value)
}
#endif
inline void TlsChangeCipherSpec_Tls::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.TlsChangeCipherSpec.Tls.value)
}
inline void TlsChangeCipherSpec_Tls::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.TlsChangeCipherSpec.Tls.value)
}
inline ::std::string* TlsChangeCipherSpec_Tls::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsChangeCipherSpec.Tls.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TlsChangeCipherSpec_Tls::release_value() {
  // @@protoc_insertion_point(field_release:cyberprobe.TlsChangeCipherSpec.Tls.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TlsChangeCipherSpec_Tls::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.TlsChangeCipherSpec.Tls.value)
}

// -------------------------------------------------------------------

// TlsChangeCipherSpec

// .cyberprobe.TlsChangeCipherSpec.Tls tls = 1;
inline bool TlsChangeCipherSpec::has_tls() const {
  return this != internal_default_instance() && tls_ != NULL;
}
inline void TlsChangeCipherSpec::clear_tls() {
  if (GetArenaNoVirtual() == NULL && tls_ != NULL) {
    delete tls_;
  }
  tls_ = NULL;
}
inline const ::cyberprobe::TlsChangeCipherSpec_Tls& TlsChangeCipherSpec::_internal_tls() const {
  return *tls_;
}
inline const ::cyberprobe::TlsChangeCipherSpec_Tls& TlsChangeCipherSpec::tls() const {
  const ::cyberprobe::TlsChangeCipherSpec_Tls* p = tls_;
  // @@protoc_insertion_point(field_get:cyberprobe.TlsChangeCipherSpec.tls)
  return p != NULL ? *p : *reinterpret_cast<const ::cyberprobe::TlsChangeCipherSpec_Tls*>(
      &::cyberprobe::_TlsChangeCipherSpec_Tls_default_instance_);
}
inline ::cyberprobe::TlsChangeCipherSpec_Tls* TlsChangeCipherSpec::release_tls() {
  // @@protoc_insertion_point(field_release:cyberprobe.TlsChangeCipherSpec.tls)
  
  ::cyberprobe::TlsChangeCipherSpec_Tls* temp = tls_;
  tls_ = NULL;
  return temp;
}
inline ::cyberprobe::TlsChangeCipherSpec_Tls* TlsChangeCipherSpec::mutable_tls() {
  
  if (tls_ == NULL) {
    auto* p = CreateMaybeMessage<::cyberprobe::TlsChangeCipherSpec_Tls>(GetArenaNoVirtual());
    tls_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsChangeCipherSpec.tls)
  return tls_;
}
inline void TlsChangeCipherSpec::set_allocated_tls(::cyberprobe::TlsChangeCipherSpec_Tls* tls) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tls_;
  }
  if (tls) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tls = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tls, submessage_arena);
    }
    
  } else {
    
  }
  tls_ = tls;
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.TlsChangeCipherSpec.tls)
}

// -------------------------------------------------------------------

// TlsHandshakeFinished_Tls

// string message = 1;
inline void TlsHandshakeFinished_Tls::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TlsHandshakeFinished_Tls::message() const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsHandshakeFinished.Tls.message)
  return message_.GetNoArena();
}
inline void TlsHandshakeFinished_Tls::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.TlsHandshakeFinished.Tls.message)
}
#if LANG_CXX11
inline void TlsHandshakeFinished_Tls::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.TlsHandshakeFinished.Tls.message)
}
#endif
inline void TlsHandshakeFinished_Tls::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.TlsHandshakeFinished.Tls.message)
}
inline void TlsHandshakeFinished_Tls::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.TlsHandshakeFinished.Tls.message)
}
inline ::std::string* TlsHandshakeFinished_Tls::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsHandshakeFinished.Tls.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TlsHandshakeFinished_Tls::release_message() {
  // @@protoc_insertion_point(field_release:cyberprobe.TlsHandshakeFinished.Tls.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TlsHandshakeFinished_Tls::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.TlsHandshakeFinished.Tls.message)
}

// -------------------------------------------------------------------

// TlsHandshakeFinished

// .cyberprobe.TlsHandshakeFinished.Tls tls = 1;
inline bool TlsHandshakeFinished::has_tls() const {
  return this != internal_default_instance() && tls_ != NULL;
}
inline void TlsHandshakeFinished::clear_tls() {
  if (GetArenaNoVirtual() == NULL && tls_ != NULL) {
    delete tls_;
  }
  tls_ = NULL;
}
inline const ::cyberprobe::TlsHandshakeFinished_Tls& TlsHandshakeFinished::_internal_tls() const {
  return *tls_;
}
inline const ::cyberprobe::TlsHandshakeFinished_Tls& TlsHandshakeFinished::tls() const {
  const ::cyberprobe::TlsHandshakeFinished_Tls* p = tls_;
  // @@protoc_insertion_point(field_get:cyberprobe.TlsHandshakeFinished.tls)
  return p != NULL ? *p : *reinterpret_cast<const ::cyberprobe::TlsHandshakeFinished_Tls*>(
      &::cyberprobe::_TlsHandshakeFinished_Tls_default_instance_);
}
inline ::cyberprobe::TlsHandshakeFinished_Tls* TlsHandshakeFinished::release_tls() {
  // @@protoc_insertion_point(field_release:cyberprobe.TlsHandshakeFinished.tls)
  
  ::cyberprobe::TlsHandshakeFinished_Tls* temp = tls_;
  tls_ = NULL;
  return temp;
}
inline ::cyberprobe::TlsHandshakeFinished_Tls* TlsHandshakeFinished::mutable_tls() {
  
  if (tls_ == NULL) {
    auto* p = CreateMaybeMessage<::cyberprobe::TlsHandshakeFinished_Tls>(GetArenaNoVirtual());
    tls_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsHandshakeFinished.tls)
  return tls_;
}
inline void TlsHandshakeFinished::set_allocated_tls(::cyberprobe::TlsHandshakeFinished_Tls* tls) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tls_;
  }
  if (tls) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tls = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tls, submessage_arena);
    }
    
  } else {
    
  }
  tls_ = tls;
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.TlsHandshakeFinished.tls)
}

// -------------------------------------------------------------------

// TlsHandshakeComplete_Tls

// -------------------------------------------------------------------

// TlsHandshakeComplete

// .cyberprobe.TlsHandshakeComplete.Tls tls = 1;
inline bool TlsHandshakeComplete::has_tls() const {
  return this != internal_default_instance() && tls_ != NULL;
}
inline void TlsHandshakeComplete::clear_tls() {
  if (GetArenaNoVirtual() == NULL && tls_ != NULL) {
    delete tls_;
  }
  tls_ = NULL;
}
inline const ::cyberprobe::TlsHandshakeComplete_Tls& TlsHandshakeComplete::_internal_tls() const {
  return *tls_;
}
inline const ::cyberprobe::TlsHandshakeComplete_Tls& TlsHandshakeComplete::tls() const {
  const ::cyberprobe::TlsHandshakeComplete_Tls* p = tls_;
  // @@protoc_insertion_point(field_get:cyberprobe.TlsHandshakeComplete.tls)
  return p != NULL ? *p : *reinterpret_cast<const ::cyberprobe::TlsHandshakeComplete_Tls*>(
      &::cyberprobe::_TlsHandshakeComplete_Tls_default_instance_);
}
inline ::cyberprobe::TlsHandshakeComplete_Tls* TlsHandshakeComplete::release_tls() {
  // @@protoc_insertion_point(field_release:cyberprobe.TlsHandshakeComplete.tls)
  
  ::cyberprobe::TlsHandshakeComplete_Tls* temp = tls_;
  tls_ = NULL;
  return temp;
}
inline ::cyberprobe::TlsHandshakeComplete_Tls* TlsHandshakeComplete::mutable_tls() {
  
  if (tls_ == NULL) {
    auto* p = CreateMaybeMessage<::cyberprobe::TlsHandshakeComplete_Tls>(GetArenaNoVirtual());
    tls_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsHandshakeComplete.tls)
  return tls_;
}
inline void TlsHandshakeComplete::set_allocated_tls(::cyberprobe::TlsHandshakeComplete_Tls* tls) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tls_;
  }
  if (tls) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tls = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tls, submessage_arena);
    }
    
  } else {
    
  }
  tls_ = tls;
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.TlsHandshakeComplete.tls)
}

// -------------------------------------------------------------------

// TlsApplicationData_Tls

// uint32 version = 1;
inline void TlsApplicationData_Tls::clear_version() {
  version_ = 0u;
}
inline ::google::protobuf::uint32 TlsApplicationData_Tls::version() const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsApplicationData.Tls.version)
  return version_;
}
inline void TlsApplicationData_Tls::set_version(::google::protobuf::uint32 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.TlsApplicationData.Tls.version)
}

// uint64 length = 2;
inline void TlsApplicationData_Tls::clear_length() {
  length_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 TlsApplicationData_Tls::length() const {
  // @@protoc_insertion_point(field_get:cyberprobe.TlsApplicationData.Tls.length)
  return length_;
}
inline void TlsApplicationData_Tls::set_length(::google::protobuf::uint64 value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.TlsApplicationData.Tls.length)
}

// -------------------------------------------------------------------

// TlsApplicationData

// .cyberprobe.TlsApplicationData.Tls tls = 1;
inline bool TlsApplicationData::has_tls() const {
  return this != internal_default_instance() && tls_ != NULL;
}
inline void TlsApplicationData::clear_tls() {
  if (GetArenaNoVirtual() == NULL && tls_ != NULL) {
    delete tls_;
  }
  tls_ = NULL;
}
inline const ::cyberprobe::TlsApplicationData_Tls& TlsApplicationData::_internal_tls() const {
  return *tls_;
}
inline const ::cyberprobe::TlsApplicationData_Tls& TlsApplicationData::tls() const {
  const ::cyberprobe::TlsApplicationData_Tls* p = tls_;
  // @@protoc_insertion_point(field_get:cyberprobe.TlsApplicationData.tls)
  return p != NULL ? *p : *reinterpret_cast<const ::cyberprobe::TlsApplicationData_Tls*>(
      &::cyberprobe::_TlsApplicationData_Tls_default_instance_);
}
inline ::cyberprobe::TlsApplicationData_Tls* TlsApplicationData::release_tls() {
  // @@protoc_insertion_point(field_release:cyberprobe.TlsApplicationData.tls)
  
  ::cyberprobe::TlsApplicationData_Tls* temp = tls_;
  tls_ = NULL;
  return temp;
}
inline ::cyberprobe::TlsApplicationData_Tls* TlsApplicationData::mutable_tls() {
  
  if (tls_ == NULL) {
    auto* p = CreateMaybeMessage<::cyberprobe::TlsApplicationData_Tls>(GetArenaNoVirtual());
    tls_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.TlsApplicationData.tls)
  return tls_;
}
inline void TlsApplicationData::set_allocated_tls(::cyberprobe::TlsApplicationData_Tls* tls) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tls_;
  }
  if (tls) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tls = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tls, submessage_arena);
    }
    
  } else {
    
  }
  tls_ = tls;
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.TlsApplicationData.tls)
}

// -------------------------------------------------------------------

// Locations_Location

// string city = 1;
inline void Locations_Location::clear_city() {
  city_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Locations_Location::city() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Locations.Location.city)
  return city_.GetNoArena();
}
inline void Locations_Location::set_city(const ::std::string& value) {
  
  city_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.Locations.Location.city)
}
#if LANG_CXX11
inline void Locations_Location::set_city(::std::string&& value) {
  
  city_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.Locations.Location.city)
}
#endif
inline void Locations_Location::set_city(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  city_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.Locations.Location.city)
}
inline void Locations_Location::set_city(const char* value, size_t size) {
  
  city_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.Locations.Location.city)
}
inline ::std::string* Locations_Location::mutable_city() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.Locations.Location.city)
  return city_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Locations_Location::release_city() {
  // @@protoc_insertion_point(field_release:cyberprobe.Locations.Location.city)
  
  return city_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Locations_Location::set_allocated_city(::std::string* city) {
  if (city != NULL) {
    
  } else {
    
  }
  city_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), city);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.Locations.Location.city)
}

// string iso = 2;
inline void Locations_Location::clear_iso() {
  iso_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Locations_Location::iso() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Locations.Location.iso)
  return iso_.GetNoArena();
}
inline void Locations_Location::set_iso(const ::std::string& value) {
  
  iso_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.Locations.Location.iso)
}
#if LANG_CXX11
inline void Locations_Location::set_iso(::std::string&& value) {
  
  iso_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.Locations.Location.iso)
}
#endif
inline void Locations_Location::set_iso(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  iso_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.Locations.Location.iso)
}
inline void Locations_Location::set_iso(const char* value, size_t size) {
  
  iso_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.Locations.Location.iso)
}
inline ::std::string* Locations_Location::mutable_iso() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.Locations.Location.iso)
  return iso_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Locations_Location::release_iso() {
  // @@protoc_insertion_point(field_release:cyberprobe.Locations.Location.iso)
  
  return iso_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Locations_Location::set_allocated_iso(::std::string* iso) {
  if (iso != NULL) {
    
  } else {
    
  }
  iso_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), iso);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.Locations.Location.iso)
}

// string country = 3;
inline void Locations_Location::clear_country() {
  country_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Locations_Location::country() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Locations.Location.country)
  return country_.GetNoArena();
}
inline void Locations_Location::set_country(const ::std::string& value) {
  
  country_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.Locations.Location.country)
}
#if LANG_CXX11
inline void Locations_Location::set_country(::std::string&& value) {
  
  country_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.Locations.Location.country)
}
#endif
inline void Locations_Location::set_country(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  country_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.Locations.Location.country)
}
inline void Locations_Location::set_country(const char* value, size_t size) {
  
  country_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.Locations.Location.country)
}
inline ::std::string* Locations_Location::mutable_country() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.Locations.Location.country)
  return country_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Locations_Location::release_country() {
  // @@protoc_insertion_point(field_release:cyberprobe.Locations.Location.country)
  
  return country_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Locations_Location::set_allocated_country(::std::string* country) {
  if (country != NULL) {
    
  } else {
    
  }
  country_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), country);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.Locations.Location.country)
}

// float latitude = 4;
inline void Locations_Location::clear_latitude() {
  latitude_ = 0;
}
inline float Locations_Location::latitude() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Locations.Location.latitude)
  return latitude_;
}
inline void Locations_Location::set_latitude(float value) {
  
  latitude_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.Locations.Location.latitude)
}

// float longitude = 5;
inline void Locations_Location::clear_longitude() {
  longitude_ = 0;
}
inline float Locations_Location::longitude() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Locations.Location.longitude)
  return longitude_;
}
inline void Locations_Location::set_longitude(float value) {
  
  longitude_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.Locations.Location.longitude)
}

// -------------------------------------------------------------------

// Locations

// .cyberprobe.Locations.Location src = 1;
inline bool Locations::has_src() const {
  return this != internal_default_instance() && src_ != NULL;
}
inline void Locations::clear_src() {
  if (GetArenaNoVirtual() == NULL && src_ != NULL) {
    delete src_;
  }
  src_ = NULL;
}
inline const ::cyberprobe::Locations_Location& Locations::_internal_src() const {
  return *src_;
}
inline const ::cyberprobe::Locations_Location& Locations::src() const {
  const ::cyberprobe::Locations_Location* p = src_;
  // @@protoc_insertion_point(field_get:cyberprobe.Locations.src)
  return p != NULL ? *p : *reinterpret_cast<const ::cyberprobe::Locations_Location*>(
      &::cyberprobe::_Locations_Location_default_instance_);
}
inline ::cyberprobe::Locations_Location* Locations::release_src() {
  // @@protoc_insertion_point(field_release:cyberprobe.Locations.src)
  
  ::cyberprobe::Locations_Location* temp = src_;
  src_ = NULL;
  return temp;
}
inline ::cyberprobe::Locations_Location* Locations::mutable_src() {
  
  if (src_ == NULL) {
    auto* p = CreateMaybeMessage<::cyberprobe::Locations_Location>(GetArenaNoVirtual());
    src_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Locations.src)
  return src_;
}
inline void Locations::set_allocated_src(::cyberprobe::Locations_Location* src) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete src_;
  }
  if (src) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      src = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, src, submessage_arena);
    }
    
  } else {
    
  }
  src_ = src;
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.Locations.src)
}

// .cyberprobe.Locations.Location dest = 2;
inline bool Locations::has_dest() const {
  return this != internal_default_instance() && dest_ != NULL;
}
inline void Locations::clear_dest() {
  if (GetArenaNoVirtual() == NULL && dest_ != NULL) {
    delete dest_;
  }
  dest_ = NULL;
}
inline const ::cyberprobe::Locations_Location& Locations::_internal_dest() const {
  return *dest_;
}
inline const ::cyberprobe::Locations_Location& Locations::dest() const {
  const ::cyberprobe::Locations_Location* p = dest_;
  // @@protoc_insertion_point(field_get:cyberprobe.Locations.dest)
  return p != NULL ? *p : *reinterpret_cast<const ::cyberprobe::Locations_Location*>(
      &::cyberprobe::_Locations_Location_default_instance_);
}
inline ::cyberprobe::Locations_Location* Locations::release_dest() {
  // @@protoc_insertion_point(field_release:cyberprobe.Locations.dest)
  
  ::cyberprobe::Locations_Location* temp = dest_;
  dest_ = NULL;
  return temp;
}
inline ::cyberprobe::Locations_Location* Locations::mutable_dest() {
  
  if (dest_ == NULL) {
    auto* p = CreateMaybeMessage<::cyberprobe::Locations_Location>(GetArenaNoVirtual());
    dest_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Locations.dest)
  return dest_;
}
inline void Locations::set_allocated_dest(::cyberprobe::Locations_Location* dest) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete dest_;
  }
  if (dest) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      dest = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dest, submessage_arena);
    }
    
  } else {
    
  }
  dest_ = dest;
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.Locations.dest)
}

// -------------------------------------------------------------------

// Indicator

// string id = 1;
inline void Indicator::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Indicator::id() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Indicator.id)
  return id_.GetNoArena();
}
inline void Indicator::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.Indicator.id)
}
#if LANG_CXX11
inline void Indicator::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.Indicator.id)
}
#endif
inline void Indicator::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.Indicator.id)
}
inline void Indicator::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.Indicator.id)
}
inline ::std::string* Indicator::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.Indicator.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Indicator::release_id() {
  // @@protoc_insertion_point(field_release:cyberprobe.Indicator.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Indicator::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.Indicator.id)
}

// string type = 2;
inline void Indicator::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Indicator::type() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Indicator.type)
  return type_.GetNoArena();
}
inline void Indicator::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.Indicator.type)
}
#if LANG_CXX11
inline void Indicator::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.Indicator.type)
}
#endif
inline void Indicator::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.Indicator.type)
}
inline void Indicator::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.Indicator.type)
}
inline ::std::string* Indicator::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.Indicator.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Indicator::release_type() {
  // @@protoc_insertion_point(field_release:cyberprobe.Indicator.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Indicator::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.Indicator.type)
}

// string value = 3;
inline void Indicator::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Indicator::value() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Indicator.value)
  return value_.GetNoArena();
}
inline void Indicator::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.Indicator.value)
}
#if LANG_CXX11
inline void Indicator::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.Indicator.value)
}
#endif
inline void Indicator::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.Indicator.value)
}
inline void Indicator::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.Indicator.value)
}
inline ::std::string* Indicator::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.Indicator.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Indicator::release_value() {
  // @@protoc_insertion_point(field_release:cyberprobe.Indicator.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Indicator::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.Indicator.value)
}

// string description = 4;
inline void Indicator::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Indicator::description() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Indicator.description)
  return description_.GetNoArena();
}
inline void Indicator::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.Indicator.description)
}
#if LANG_CXX11
inline void Indicator::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.Indicator.description)
}
#endif
inline void Indicator::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.Indicator.description)
}
inline void Indicator::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.Indicator.description)
}
inline ::std::string* Indicator::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.Indicator.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Indicator::release_description() {
  // @@protoc_insertion_point(field_release:cyberprobe.Indicator.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Indicator::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.Indicator.description)
}

// -------------------------------------------------------------------

// Event

// string id = 1;
inline void Event::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Event::id() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.id)
  return id_.GetNoArena();
}
inline void Event::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.Event.id)
}
#if LANG_CXX11
inline void Event::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.Event.id)
}
#endif
inline void Event::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.Event.id)
}
inline void Event::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.Event.id)
}
inline ::std::string* Event::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Event::release_id() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Event::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.Event.id)
}

// string device = 2;
inline void Event::clear_device() {
  device_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Event::device() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.device)
  return device_.GetNoArena();
}
inline void Event::set_device(const ::std::string& value) {
  
  device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.Event.device)
}
#if LANG_CXX11
inline void Event::set_device(::std::string&& value) {
  
  device_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.Event.device)
}
#endif
inline void Event::set_device(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.Event.device)
}
inline void Event::set_device(const char* value, size_t size) {
  
  device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.Event.device)
}
inline ::std::string* Event::mutable_device() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.device)
  return device_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Event::release_device() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.device)
  
  return device_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Event::set_allocated_device(::std::string* device) {
  if (device != NULL) {
    
  } else {
    
  }
  device_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.Event.device)
}

// string network = 3;
inline void Event::clear_network() {
  network_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Event::network() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.network)
  return network_.GetNoArena();
}
inline void Event::set_network(const ::std::string& value) {
  
  network_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.Event.network)
}
#if LANG_CXX11
inline void Event::set_network(::std::string&& value) {
  
  network_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.Event.network)
}
#endif
inline void Event::set_network(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  network_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.Event.network)
}
inline void Event::set_network(const char* value, size_t size) {
  
  network_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.Event.network)
}
inline ::std::string* Event::mutable_network() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.network)
  return network_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Event::release_network() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.network)
  
  return network_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Event::set_allocated_network(::std::string* network) {
  if (network != NULL) {
    
  } else {
    
  }
  network_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), network);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.Event.network)
}

// string origin = 4;
inline void Event::clear_origin() {
  origin_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Event::origin() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.origin)
  return origin_.GetNoArena();
}
inline void Event::set_origin(const ::std::string& value) {
  
  origin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.Event.origin)
}
#if LANG_CXX11
inline void Event::set_origin(::std::string&& value) {
  
  origin_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.Event.origin)
}
#endif
inline void Event::set_origin(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  origin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.Event.origin)
}
inline void Event::set_origin(const char* value, size_t size) {
  
  origin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.Event.origin)
}
inline ::std::string* Event::mutable_origin() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.origin)
  return origin_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Event::release_origin() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.origin)
  
  return origin_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Event::set_allocated_origin(::std::string* origin) {
  if (origin != NULL) {
    
  } else {
    
  }
  origin_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), origin);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.Event.origin)
}

// .cyberprobe.Action action = 5;
inline void Event::clear_action() {
  action_ = 0;
}
inline ::cyberprobe::Action Event::action() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.action)
  return static_cast< ::cyberprobe::Action >(action_);
}
inline void Event::set_action(::cyberprobe::Action value) {
  
  action_ = value;
  // @@protoc_insertion_point(field_set:cyberprobe.Event.action)
}

// string url = 6;
inline void Event::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Event::url() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.url)
  return url_.GetNoArena();
}
inline void Event::set_url(const ::std::string& value) {
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cyberprobe.Event.url)
}
#if LANG_CXX11
inline void Event::set_url(::std::string&& value) {
  
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cyberprobe.Event.url)
}
#endif
inline void Event::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cyberprobe.Event.url)
}
inline void Event::set_url(const char* value, size_t size) {
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.Event.url)
}
inline ::std::string* Event::mutable_url() {
  
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Event::release_url() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.url)
  
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Event::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    
  } else {
    
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.Event.url)
}

// repeated string src = 7;
inline int Event::src_size() const {
  return src_.size();
}
inline void Event::clear_src() {
  src_.Clear();
}
inline const ::std::string& Event::src(int index) const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.src)
  return src_.Get(index);
}
inline ::std::string* Event::mutable_src(int index) {
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.src)
  return src_.Mutable(index);
}
inline void Event::set_src(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:cyberprobe.Event.src)
  src_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Event::set_src(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:cyberprobe.Event.src)
  src_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Event::set_src(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  src_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cyberprobe.Event.src)
}
inline void Event::set_src(int index, const char* value, size_t size) {
  src_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.Event.src)
}
inline ::std::string* Event::add_src() {
  // @@protoc_insertion_point(field_add_mutable:cyberprobe.Event.src)
  return src_.Add();
}
inline void Event::add_src(const ::std::string& value) {
  src_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:cyberprobe.Event.src)
}
#if LANG_CXX11
inline void Event::add_src(::std::string&& value) {
  src_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:cyberprobe.Event.src)
}
#endif
inline void Event::add_src(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  src_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cyberprobe.Event.src)
}
inline void Event::add_src(const char* value, size_t size) {
  src_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cyberprobe.Event.src)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Event::src() const {
  // @@protoc_insertion_point(field_list:cyberprobe.Event.src)
  return src_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Event::mutable_src() {
  // @@protoc_insertion_point(field_mutable_list:cyberprobe.Event.src)
  return &src_;
}

// repeated string dest = 8;
inline int Event::dest_size() const {
  return dest_.size();
}
inline void Event::clear_dest() {
  dest_.Clear();
}
inline const ::std::string& Event::dest(int index) const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.dest)
  return dest_.Get(index);
}
inline ::std::string* Event::mutable_dest(int index) {
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.dest)
  return dest_.Mutable(index);
}
inline void Event::set_dest(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:cyberprobe.Event.dest)
  dest_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Event::set_dest(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:cyberprobe.Event.dest)
  dest_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Event::set_dest(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  dest_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cyberprobe.Event.dest)
}
inline void Event::set_dest(int index, const char* value, size_t size) {
  dest_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cyberprobe.Event.dest)
}
inline ::std::string* Event::add_dest() {
  // @@protoc_insertion_point(field_add_mutable:cyberprobe.Event.dest)
  return dest_.Add();
}
inline void Event::add_dest(const ::std::string& value) {
  dest_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:cyberprobe.Event.dest)
}
#if LANG_CXX11
inline void Event::add_dest(::std::string&& value) {
  dest_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:cyberprobe.Event.dest)
}
#endif
inline void Event::add_dest(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  dest_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cyberprobe.Event.dest)
}
inline void Event::add_dest(const char* value, size_t size) {
  dest_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cyberprobe.Event.dest)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Event::dest() const {
  // @@protoc_insertion_point(field_list:cyberprobe.Event.dest)
  return dest_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Event::mutable_dest() {
  // @@protoc_insertion_point(field_mutable_list:cyberprobe.Event.dest)
  return &dest_;
}

// .google.protobuf.Timestamp time = 9;
inline bool Event::has_time() const {
  return this != internal_default_instance() && time_ != NULL;
}
inline const ::google::protobuf::Timestamp& Event::_internal_time() const {
  return *time_;
}
inline const ::google::protobuf::Timestamp& Event::time() const {
  const ::google::protobuf::Timestamp* p = time_;
  // @@protoc_insertion_point(field_get:cyberprobe.Event.time)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* Event::release_time() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.time)
  
  ::google::protobuf::Timestamp* temp = time_;
  time_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* Event::mutable_time() {
  
  if (time_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.time)
  return time_;
}
inline void Event::set_allocated_time(::google::protobuf::Timestamp* time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(time_);
  }
  if (time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(time)->GetArena();
    if (message_arena != submessage_arena) {
      time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    
  } else {
    
  }
  time_ = time;
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.Event.time)
}

// .cyberprobe.DnsMessage dns_message = 10;
inline bool Event::has_dns_message() const {
  return Detail_case() == kDnsMessage;
}
inline void Event::set_has_dns_message() {
  _oneof_case_[0] = kDnsMessage;
}
inline void Event::clear_dns_message() {
  if (has_dns_message()) {
    delete Detail_.dns_message_;
    clear_has_Detail();
  }
}
inline const ::cyberprobe::DnsMessage& Event::_internal_dns_message() const {
  return *Detail_.dns_message_;
}
inline ::cyberprobe::DnsMessage* Event::release_dns_message() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.dns_message)
  if (has_dns_message()) {
    clear_has_Detail();
      ::cyberprobe::DnsMessage* temp = Detail_.dns_message_;
    Detail_.dns_message_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cyberprobe::DnsMessage& Event::dns_message() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.dns_message)
  return has_dns_message()
      ? *Detail_.dns_message_
      : *reinterpret_cast< ::cyberprobe::DnsMessage*>(&::cyberprobe::_DnsMessage_default_instance_);
}
inline ::cyberprobe::DnsMessage* Event::mutable_dns_message() {
  if (!has_dns_message()) {
    clear_Detail();
    set_has_dns_message();
    Detail_.dns_message_ = CreateMaybeMessage< ::cyberprobe::DnsMessage >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.dns_message)
  return Detail_.dns_message_;
}

// .cyberprobe.UnrecognisedDatagram unrecognised_datagram = 11;
inline bool Event::has_unrecognised_datagram() const {
  return Detail_case() == kUnrecognisedDatagram;
}
inline void Event::set_has_unrecognised_datagram() {
  _oneof_case_[0] = kUnrecognisedDatagram;
}
inline void Event::clear_unrecognised_datagram() {
  if (has_unrecognised_datagram()) {
    delete Detail_.unrecognised_datagram_;
    clear_has_Detail();
  }
}
inline const ::cyberprobe::UnrecognisedDatagram& Event::_internal_unrecognised_datagram() const {
  return *Detail_.unrecognised_datagram_;
}
inline ::cyberprobe::UnrecognisedDatagram* Event::release_unrecognised_datagram() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.unrecognised_datagram)
  if (has_unrecognised_datagram()) {
    clear_has_Detail();
      ::cyberprobe::UnrecognisedDatagram* temp = Detail_.unrecognised_datagram_;
    Detail_.unrecognised_datagram_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cyberprobe::UnrecognisedDatagram& Event::unrecognised_datagram() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.unrecognised_datagram)
  return has_unrecognised_datagram()
      ? *Detail_.unrecognised_datagram_
      : *reinterpret_cast< ::cyberprobe::UnrecognisedDatagram*>(&::cyberprobe::_UnrecognisedDatagram_default_instance_);
}
inline ::cyberprobe::UnrecognisedDatagram* Event::mutable_unrecognised_datagram() {
  if (!has_unrecognised_datagram()) {
    clear_Detail();
    set_has_unrecognised_datagram();
    Detail_.unrecognised_datagram_ = CreateMaybeMessage< ::cyberprobe::UnrecognisedDatagram >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.unrecognised_datagram)
  return Detail_.unrecognised_datagram_;
}

// .cyberprobe.UnrecognisedStream unrecognised_stream = 12;
inline bool Event::has_unrecognised_stream() const {
  return Detail_case() == kUnrecognisedStream;
}
inline void Event::set_has_unrecognised_stream() {
  _oneof_case_[0] = kUnrecognisedStream;
}
inline void Event::clear_unrecognised_stream() {
  if (has_unrecognised_stream()) {
    delete Detail_.unrecognised_stream_;
    clear_has_Detail();
  }
}
inline const ::cyberprobe::UnrecognisedStream& Event::_internal_unrecognised_stream() const {
  return *Detail_.unrecognised_stream_;
}
inline ::cyberprobe::UnrecognisedStream* Event::release_unrecognised_stream() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.unrecognised_stream)
  if (has_unrecognised_stream()) {
    clear_has_Detail();
      ::cyberprobe::UnrecognisedStream* temp = Detail_.unrecognised_stream_;
    Detail_.unrecognised_stream_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cyberprobe::UnrecognisedStream& Event::unrecognised_stream() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.unrecognised_stream)
  return has_unrecognised_stream()
      ? *Detail_.unrecognised_stream_
      : *reinterpret_cast< ::cyberprobe::UnrecognisedStream*>(&::cyberprobe::_UnrecognisedStream_default_instance_);
}
inline ::cyberprobe::UnrecognisedStream* Event::mutable_unrecognised_stream() {
  if (!has_unrecognised_stream()) {
    clear_Detail();
    set_has_unrecognised_stream();
    Detail_.unrecognised_stream_ = CreateMaybeMessage< ::cyberprobe::UnrecognisedStream >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.unrecognised_stream)
  return Detail_.unrecognised_stream_;
}

// .cyberprobe.Icmp icmp = 13;
inline bool Event::has_icmp() const {
  return Detail_case() == kIcmp;
}
inline void Event::set_has_icmp() {
  _oneof_case_[0] = kIcmp;
}
inline void Event::clear_icmp() {
  if (has_icmp()) {
    delete Detail_.icmp_;
    clear_has_Detail();
  }
}
inline const ::cyberprobe::Icmp& Event::_internal_icmp() const {
  return *Detail_.icmp_;
}
inline ::cyberprobe::Icmp* Event::release_icmp() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.icmp)
  if (has_icmp()) {
    clear_has_Detail();
      ::cyberprobe::Icmp* temp = Detail_.icmp_;
    Detail_.icmp_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cyberprobe::Icmp& Event::icmp() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.icmp)
  return has_icmp()
      ? *Detail_.icmp_
      : *reinterpret_cast< ::cyberprobe::Icmp*>(&::cyberprobe::_Icmp_default_instance_);
}
inline ::cyberprobe::Icmp* Event::mutable_icmp() {
  if (!has_icmp()) {
    clear_Detail();
    set_has_icmp();
    Detail_.icmp_ = CreateMaybeMessage< ::cyberprobe::Icmp >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.icmp)
  return Detail_.icmp_;
}

// .cyberprobe.HttpRequest http_request = 14;
inline bool Event::has_http_request() const {
  return Detail_case() == kHttpRequest;
}
inline void Event::set_has_http_request() {
  _oneof_case_[0] = kHttpRequest;
}
inline void Event::clear_http_request() {
  if (has_http_request()) {
    delete Detail_.http_request_;
    clear_has_Detail();
  }
}
inline const ::cyberprobe::HttpRequest& Event::_internal_http_request() const {
  return *Detail_.http_request_;
}
inline ::cyberprobe::HttpRequest* Event::release_http_request() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.http_request)
  if (has_http_request()) {
    clear_has_Detail();
      ::cyberprobe::HttpRequest* temp = Detail_.http_request_;
    Detail_.http_request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cyberprobe::HttpRequest& Event::http_request() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.http_request)
  return has_http_request()
      ? *Detail_.http_request_
      : *reinterpret_cast< ::cyberprobe::HttpRequest*>(&::cyberprobe::_HttpRequest_default_instance_);
}
inline ::cyberprobe::HttpRequest* Event::mutable_http_request() {
  if (!has_http_request()) {
    clear_Detail();
    set_has_http_request();
    Detail_.http_request_ = CreateMaybeMessage< ::cyberprobe::HttpRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.http_request)
  return Detail_.http_request_;
}

// .cyberprobe.HttpResponse http_response = 15;
inline bool Event::has_http_response() const {
  return Detail_case() == kHttpResponse;
}
inline void Event::set_has_http_response() {
  _oneof_case_[0] = kHttpResponse;
}
inline void Event::clear_http_response() {
  if (has_http_response()) {
    delete Detail_.http_response_;
    clear_has_Detail();
  }
}
inline const ::cyberprobe::HttpResponse& Event::_internal_http_response() const {
  return *Detail_.http_response_;
}
inline ::cyberprobe::HttpResponse* Event::release_http_response() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.http_response)
  if (has_http_response()) {
    clear_has_Detail();
      ::cyberprobe::HttpResponse* temp = Detail_.http_response_;
    Detail_.http_response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cyberprobe::HttpResponse& Event::http_response() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.http_response)
  return has_http_response()
      ? *Detail_.http_response_
      : *reinterpret_cast< ::cyberprobe::HttpResponse*>(&::cyberprobe::_HttpResponse_default_instance_);
}
inline ::cyberprobe::HttpResponse* Event::mutable_http_response() {
  if (!has_http_response()) {
    clear_Detail();
    set_has_http_response();
    Detail_.http_response_ = CreateMaybeMessage< ::cyberprobe::HttpResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.http_response)
  return Detail_.http_response_;
}

// .cyberprobe.SipRequest sip_request = 16;
inline bool Event::has_sip_request() const {
  return Detail_case() == kSipRequest;
}
inline void Event::set_has_sip_request() {
  _oneof_case_[0] = kSipRequest;
}
inline void Event::clear_sip_request() {
  if (has_sip_request()) {
    delete Detail_.sip_request_;
    clear_has_Detail();
  }
}
inline const ::cyberprobe::SipRequest& Event::_internal_sip_request() const {
  return *Detail_.sip_request_;
}
inline ::cyberprobe::SipRequest* Event::release_sip_request() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.sip_request)
  if (has_sip_request()) {
    clear_has_Detail();
      ::cyberprobe::SipRequest* temp = Detail_.sip_request_;
    Detail_.sip_request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cyberprobe::SipRequest& Event::sip_request() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.sip_request)
  return has_sip_request()
      ? *Detail_.sip_request_
      : *reinterpret_cast< ::cyberprobe::SipRequest*>(&::cyberprobe::_SipRequest_default_instance_);
}
inline ::cyberprobe::SipRequest* Event::mutable_sip_request() {
  if (!has_sip_request()) {
    clear_Detail();
    set_has_sip_request();
    Detail_.sip_request_ = CreateMaybeMessage< ::cyberprobe::SipRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.sip_request)
  return Detail_.sip_request_;
}

// .cyberprobe.SipResponse sip_response = 17;
inline bool Event::has_sip_response() const {
  return Detail_case() == kSipResponse;
}
inline void Event::set_has_sip_response() {
  _oneof_case_[0] = kSipResponse;
}
inline void Event::clear_sip_response() {
  if (has_sip_response()) {
    delete Detail_.sip_response_;
    clear_has_Detail();
  }
}
inline const ::cyberprobe::SipResponse& Event::_internal_sip_response() const {
  return *Detail_.sip_response_;
}
inline ::cyberprobe::SipResponse* Event::release_sip_response() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.sip_response)
  if (has_sip_response()) {
    clear_has_Detail();
      ::cyberprobe::SipResponse* temp = Detail_.sip_response_;
    Detail_.sip_response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cyberprobe::SipResponse& Event::sip_response() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.sip_response)
  return has_sip_response()
      ? *Detail_.sip_response_
      : *reinterpret_cast< ::cyberprobe::SipResponse*>(&::cyberprobe::_SipResponse_default_instance_);
}
inline ::cyberprobe::SipResponse* Event::mutable_sip_response() {
  if (!has_sip_response()) {
    clear_Detail();
    set_has_sip_response();
    Detail_.sip_response_ = CreateMaybeMessage< ::cyberprobe::SipResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.sip_response)
  return Detail_.sip_response_;
}

// .cyberprobe.SipSsl sip_ssl = 18;
inline bool Event::has_sip_ssl() const {
  return Detail_case() == kSipSsl;
}
inline void Event::set_has_sip_ssl() {
  _oneof_case_[0] = kSipSsl;
}
inline void Event::clear_sip_ssl() {
  if (has_sip_ssl()) {
    delete Detail_.sip_ssl_;
    clear_has_Detail();
  }
}
inline const ::cyberprobe::SipSsl& Event::_internal_sip_ssl() const {
  return *Detail_.sip_ssl_;
}
inline ::cyberprobe::SipSsl* Event::release_sip_ssl() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.sip_ssl)
  if (has_sip_ssl()) {
    clear_has_Detail();
      ::cyberprobe::SipSsl* temp = Detail_.sip_ssl_;
    Detail_.sip_ssl_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cyberprobe::SipSsl& Event::sip_ssl() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.sip_ssl)
  return has_sip_ssl()
      ? *Detail_.sip_ssl_
      : *reinterpret_cast< ::cyberprobe::SipSsl*>(&::cyberprobe::_SipSsl_default_instance_);
}
inline ::cyberprobe::SipSsl* Event::mutable_sip_ssl() {
  if (!has_sip_ssl()) {
    clear_Detail();
    set_has_sip_ssl();
    Detail_.sip_ssl_ = CreateMaybeMessage< ::cyberprobe::SipSsl >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.sip_ssl)
  return Detail_.sip_ssl_;
}

// .cyberprobe.Imap imap = 19;
inline bool Event::has_imap() const {
  return Detail_case() == kImap;
}
inline void Event::set_has_imap() {
  _oneof_case_[0] = kImap;
}
inline void Event::clear_imap() {
  if (has_imap()) {
    delete Detail_.imap_;
    clear_has_Detail();
  }
}
inline const ::cyberprobe::Imap& Event::_internal_imap() const {
  return *Detail_.imap_;
}
inline ::cyberprobe::Imap* Event::release_imap() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.imap)
  if (has_imap()) {
    clear_has_Detail();
      ::cyberprobe::Imap* temp = Detail_.imap_;
    Detail_.imap_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cyberprobe::Imap& Event::imap() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.imap)
  return has_imap()
      ? *Detail_.imap_
      : *reinterpret_cast< ::cyberprobe::Imap*>(&::cyberprobe::_Imap_default_instance_);
}
inline ::cyberprobe::Imap* Event::mutable_imap() {
  if (!has_imap()) {
    clear_Detail();
    set_has_imap();
    Detail_.imap_ = CreateMaybeMessage< ::cyberprobe::Imap >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.imap)
  return Detail_.imap_;
}

// .cyberprobe.Pop3 pop3 = 20;
inline bool Event::has_pop3() const {
  return Detail_case() == kPop3;
}
inline void Event::set_has_pop3() {
  _oneof_case_[0] = kPop3;
}
inline void Event::clear_pop3() {
  if (has_pop3()) {
    delete Detail_.pop3_;
    clear_has_Detail();
  }
}
inline const ::cyberprobe::Pop3& Event::_internal_pop3() const {
  return *Detail_.pop3_;
}
inline ::cyberprobe::Pop3* Event::release_pop3() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.pop3)
  if (has_pop3()) {
    clear_has_Detail();
      ::cyberprobe::Pop3* temp = Detail_.pop3_;
    Detail_.pop3_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cyberprobe::Pop3& Event::pop3() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.pop3)
  return has_pop3()
      ? *Detail_.pop3_
      : *reinterpret_cast< ::cyberprobe::Pop3*>(&::cyberprobe::_Pop3_default_instance_);
}
inline ::cyberprobe::Pop3* Event::mutable_pop3() {
  if (!has_pop3()) {
    clear_Detail();
    set_has_pop3();
    Detail_.pop3_ = CreateMaybeMessage< ::cyberprobe::Pop3 >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.pop3)
  return Detail_.pop3_;
}

// .cyberprobe.Pop3Ssl pop3_ssl = 21;
inline bool Event::has_pop3_ssl() const {
  return Detail_case() == kPop3Ssl;
}
inline void Event::set_has_pop3_ssl() {
  _oneof_case_[0] = kPop3Ssl;
}
inline void Event::clear_pop3_ssl() {
  if (has_pop3_ssl()) {
    delete Detail_.pop3_ssl_;
    clear_has_Detail();
  }
}
inline const ::cyberprobe::Pop3Ssl& Event::_internal_pop3_ssl() const {
  return *Detail_.pop3_ssl_;
}
inline ::cyberprobe::Pop3Ssl* Event::release_pop3_ssl() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.pop3_ssl)
  if (has_pop3_ssl()) {
    clear_has_Detail();
      ::cyberprobe::Pop3Ssl* temp = Detail_.pop3_ssl_;
    Detail_.pop3_ssl_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cyberprobe::Pop3Ssl& Event::pop3_ssl() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.pop3_ssl)
  return has_pop3_ssl()
      ? *Detail_.pop3_ssl_
      : *reinterpret_cast< ::cyberprobe::Pop3Ssl*>(&::cyberprobe::_Pop3Ssl_default_instance_);
}
inline ::cyberprobe::Pop3Ssl* Event::mutable_pop3_ssl() {
  if (!has_pop3_ssl()) {
    clear_Detail();
    set_has_pop3_ssl();
    Detail_.pop3_ssl_ = CreateMaybeMessage< ::cyberprobe::Pop3Ssl >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.pop3_ssl)
  return Detail_.pop3_ssl_;
}

// .cyberprobe.Ntp ntp_timestamp = 22;
inline bool Event::has_ntp_timestamp() const {
  return Detail_case() == kNtpTimestamp;
}
inline void Event::set_has_ntp_timestamp() {
  _oneof_case_[0] = kNtpTimestamp;
}
inline void Event::clear_ntp_timestamp() {
  if (has_ntp_timestamp()) {
    delete Detail_.ntp_timestamp_;
    clear_has_Detail();
  }
}
inline const ::cyberprobe::Ntp& Event::_internal_ntp_timestamp() const {
  return *Detail_.ntp_timestamp_;
}
inline ::cyberprobe::Ntp* Event::release_ntp_timestamp() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.ntp_timestamp)
  if (has_ntp_timestamp()) {
    clear_has_Detail();
      ::cyberprobe::Ntp* temp = Detail_.ntp_timestamp_;
    Detail_.ntp_timestamp_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cyberprobe::Ntp& Event::ntp_timestamp() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.ntp_timestamp)
  return has_ntp_timestamp()
      ? *Detail_.ntp_timestamp_
      : *reinterpret_cast< ::cyberprobe::Ntp*>(&::cyberprobe::_Ntp_default_instance_);
}
inline ::cyberprobe::Ntp* Event::mutable_ntp_timestamp() {
  if (!has_ntp_timestamp()) {
    clear_Detail();
    set_has_ntp_timestamp();
    Detail_.ntp_timestamp_ = CreateMaybeMessage< ::cyberprobe::Ntp >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.ntp_timestamp)
  return Detail_.ntp_timestamp_;
}

// .cyberprobe.Ntp ntp_control = 23;
inline bool Event::has_ntp_control() const {
  return Detail_case() == kNtpControl;
}
inline void Event::set_has_ntp_control() {
  _oneof_case_[0] = kNtpControl;
}
inline void Event::clear_ntp_control() {
  if (has_ntp_control()) {
    delete Detail_.ntp_control_;
    clear_has_Detail();
  }
}
inline const ::cyberprobe::Ntp& Event::_internal_ntp_control() const {
  return *Detail_.ntp_control_;
}
inline ::cyberprobe::Ntp* Event::release_ntp_control() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.ntp_control)
  if (has_ntp_control()) {
    clear_has_Detail();
      ::cyberprobe::Ntp* temp = Detail_.ntp_control_;
    Detail_.ntp_control_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cyberprobe::Ntp& Event::ntp_control() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.ntp_control)
  return has_ntp_control()
      ? *Detail_.ntp_control_
      : *reinterpret_cast< ::cyberprobe::Ntp*>(&::cyberprobe::_Ntp_default_instance_);
}
inline ::cyberprobe::Ntp* Event::mutable_ntp_control() {
  if (!has_ntp_control()) {
    clear_Detail();
    set_has_ntp_control();
    Detail_.ntp_control_ = CreateMaybeMessage< ::cyberprobe::Ntp >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.ntp_control)
  return Detail_.ntp_control_;
}

// .cyberprobe.Ntp ntp_private = 24;
inline bool Event::has_ntp_private() const {
  return Detail_case() == kNtpPrivate;
}
inline void Event::set_has_ntp_private() {
  _oneof_case_[0] = kNtpPrivate;
}
inline void Event::clear_ntp_private() {
  if (has_ntp_private()) {
    delete Detail_.ntp_private_;
    clear_has_Detail();
  }
}
inline const ::cyberprobe::Ntp& Event::_internal_ntp_private() const {
  return *Detail_.ntp_private_;
}
inline ::cyberprobe::Ntp* Event::release_ntp_private() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.ntp_private)
  if (has_ntp_private()) {
    clear_has_Detail();
      ::cyberprobe::Ntp* temp = Detail_.ntp_private_;
    Detail_.ntp_private_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cyberprobe::Ntp& Event::ntp_private() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.ntp_private)
  return has_ntp_private()
      ? *Detail_.ntp_private_
      : *reinterpret_cast< ::cyberprobe::Ntp*>(&::cyberprobe::_Ntp_default_instance_);
}
inline ::cyberprobe::Ntp* Event::mutable_ntp_private() {
  if (!has_ntp_private()) {
    clear_Detail();
    set_has_ntp_private();
    Detail_.ntp_private_ = CreateMaybeMessage< ::cyberprobe::Ntp >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.ntp_private)
  return Detail_.ntp_private_;
}

// .cyberprobe.FtpCommand ftp_command = 25;
inline bool Event::has_ftp_command() const {
  return Detail_case() == kFtpCommand;
}
inline void Event::set_has_ftp_command() {
  _oneof_case_[0] = kFtpCommand;
}
inline void Event::clear_ftp_command() {
  if (has_ftp_command()) {
    delete Detail_.ftp_command_;
    clear_has_Detail();
  }
}
inline const ::cyberprobe::FtpCommand& Event::_internal_ftp_command() const {
  return *Detail_.ftp_command_;
}
inline ::cyberprobe::FtpCommand* Event::release_ftp_command() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.ftp_command)
  if (has_ftp_command()) {
    clear_has_Detail();
      ::cyberprobe::FtpCommand* temp = Detail_.ftp_command_;
    Detail_.ftp_command_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cyberprobe::FtpCommand& Event::ftp_command() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.ftp_command)
  return has_ftp_command()
      ? *Detail_.ftp_command_
      : *reinterpret_cast< ::cyberprobe::FtpCommand*>(&::cyberprobe::_FtpCommand_default_instance_);
}
inline ::cyberprobe::FtpCommand* Event::mutable_ftp_command() {
  if (!has_ftp_command()) {
    clear_Detail();
    set_has_ftp_command();
    Detail_.ftp_command_ = CreateMaybeMessage< ::cyberprobe::FtpCommand >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.ftp_command)
  return Detail_.ftp_command_;
}

// .cyberprobe.FtpResponse ftp_response = 26;
inline bool Event::has_ftp_response() const {
  return Detail_case() == kFtpResponse;
}
inline void Event::set_has_ftp_response() {
  _oneof_case_[0] = kFtpResponse;
}
inline void Event::clear_ftp_response() {
  if (has_ftp_response()) {
    delete Detail_.ftp_response_;
    clear_has_Detail();
  }
}
inline const ::cyberprobe::FtpResponse& Event::_internal_ftp_response() const {
  return *Detail_.ftp_response_;
}
inline ::cyberprobe::FtpResponse* Event::release_ftp_response() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.ftp_response)
  if (has_ftp_response()) {
    clear_has_Detail();
      ::cyberprobe::FtpResponse* temp = Detail_.ftp_response_;
    Detail_.ftp_response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cyberprobe::FtpResponse& Event::ftp_response() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.ftp_response)
  return has_ftp_response()
      ? *Detail_.ftp_response_
      : *reinterpret_cast< ::cyberprobe::FtpResponse*>(&::cyberprobe::_FtpResponse_default_instance_);
}
inline ::cyberprobe::FtpResponse* Event::mutable_ftp_response() {
  if (!has_ftp_response()) {
    clear_Detail();
    set_has_ftp_response();
    Detail_.ftp_response_ = CreateMaybeMessage< ::cyberprobe::FtpResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.ftp_response)
  return Detail_.ftp_response_;
}

// .cyberprobe.SmtpCommand smtp_command = 27;
inline bool Event::has_smtp_command() const {
  return Detail_case() == kSmtpCommand;
}
inline void Event::set_has_smtp_command() {
  _oneof_case_[0] = kSmtpCommand;
}
inline void Event::clear_smtp_command() {
  if (has_smtp_command()) {
    delete Detail_.smtp_command_;
    clear_has_Detail();
  }
}
inline const ::cyberprobe::SmtpCommand& Event::_internal_smtp_command() const {
  return *Detail_.smtp_command_;
}
inline ::cyberprobe::SmtpCommand* Event::release_smtp_command() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.smtp_command)
  if (has_smtp_command()) {
    clear_has_Detail();
      ::cyberprobe::SmtpCommand* temp = Detail_.smtp_command_;
    Detail_.smtp_command_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cyberprobe::SmtpCommand& Event::smtp_command() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.smtp_command)
  return has_smtp_command()
      ? *Detail_.smtp_command_
      : *reinterpret_cast< ::cyberprobe::SmtpCommand*>(&::cyberprobe::_SmtpCommand_default_instance_);
}
inline ::cyberprobe::SmtpCommand* Event::mutable_smtp_command() {
  if (!has_smtp_command()) {
    clear_Detail();
    set_has_smtp_command();
    Detail_.smtp_command_ = CreateMaybeMessage< ::cyberprobe::SmtpCommand >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.smtp_command)
  return Detail_.smtp_command_;
}

// .cyberprobe.SmtpResponse smtp_response = 28;
inline bool Event::has_smtp_response() const {
  return Detail_case() == kSmtpResponse;
}
inline void Event::set_has_smtp_response() {
  _oneof_case_[0] = kSmtpResponse;
}
inline void Event::clear_smtp_response() {
  if (has_smtp_response()) {
    delete Detail_.smtp_response_;
    clear_has_Detail();
  }
}
inline const ::cyberprobe::SmtpResponse& Event::_internal_smtp_response() const {
  return *Detail_.smtp_response_;
}
inline ::cyberprobe::SmtpResponse* Event::release_smtp_response() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.smtp_response)
  if (has_smtp_response()) {
    clear_has_Detail();
      ::cyberprobe::SmtpResponse* temp = Detail_.smtp_response_;
    Detail_.smtp_response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cyberprobe::SmtpResponse& Event::smtp_response() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.smtp_response)
  return has_smtp_response()
      ? *Detail_.smtp_response_
      : *reinterpret_cast< ::cyberprobe::SmtpResponse*>(&::cyberprobe::_SmtpResponse_default_instance_);
}
inline ::cyberprobe::SmtpResponse* Event::mutable_smtp_response() {
  if (!has_smtp_response()) {
    clear_Detail();
    set_has_smtp_response();
    Detail_.smtp_response_ = CreateMaybeMessage< ::cyberprobe::SmtpResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.smtp_response)
  return Detail_.smtp_response_;
}

// .cyberprobe.SmtpData smtp_data = 29;
inline bool Event::has_smtp_data() const {
  return Detail_case() == kSmtpData;
}
inline void Event::set_has_smtp_data() {
  _oneof_case_[0] = kSmtpData;
}
inline void Event::clear_smtp_data() {
  if (has_smtp_data()) {
    delete Detail_.smtp_data_;
    clear_has_Detail();
  }
}
inline const ::cyberprobe::SmtpData& Event::_internal_smtp_data() const {
  return *Detail_.smtp_data_;
}
inline ::cyberprobe::SmtpData* Event::release_smtp_data() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.smtp_data)
  if (has_smtp_data()) {
    clear_has_Detail();
      ::cyberprobe::SmtpData* temp = Detail_.smtp_data_;
    Detail_.smtp_data_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cyberprobe::SmtpData& Event::smtp_data() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.smtp_data)
  return has_smtp_data()
      ? *Detail_.smtp_data_
      : *reinterpret_cast< ::cyberprobe::SmtpData*>(&::cyberprobe::_SmtpData_default_instance_);
}
inline ::cyberprobe::SmtpData* Event::mutable_smtp_data() {
  if (!has_smtp_data()) {
    clear_Detail();
    set_has_smtp_data();
    Detail_.smtp_data_ = CreateMaybeMessage< ::cyberprobe::SmtpData >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.smtp_data)
  return Detail_.smtp_data_;
}

// .cyberprobe.Gre gre = 30;
inline bool Event::has_gre() const {
  return Detail_case() == kGre;
}
inline void Event::set_has_gre() {
  _oneof_case_[0] = kGre;
}
inline void Event::clear_gre() {
  if (has_gre()) {
    delete Detail_.gre_;
    clear_has_Detail();
  }
}
inline const ::cyberprobe::Gre& Event::_internal_gre() const {
  return *Detail_.gre_;
}
inline ::cyberprobe::Gre* Event::release_gre() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.gre)
  if (has_gre()) {
    clear_has_Detail();
      ::cyberprobe::Gre* temp = Detail_.gre_;
    Detail_.gre_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cyberprobe::Gre& Event::gre() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.gre)
  return has_gre()
      ? *Detail_.gre_
      : *reinterpret_cast< ::cyberprobe::Gre*>(&::cyberprobe::_Gre_default_instance_);
}
inline ::cyberprobe::Gre* Event::mutable_gre() {
  if (!has_gre()) {
    clear_Detail();
    set_has_gre();
    Detail_.gre_ = CreateMaybeMessage< ::cyberprobe::Gre >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.gre)
  return Detail_.gre_;
}

// .cyberprobe.GrePptp gre_pptp = 31;
inline bool Event::has_gre_pptp() const {
  return Detail_case() == kGrePptp;
}
inline void Event::set_has_gre_pptp() {
  _oneof_case_[0] = kGrePptp;
}
inline void Event::clear_gre_pptp() {
  if (has_gre_pptp()) {
    delete Detail_.gre_pptp_;
    clear_has_Detail();
  }
}
inline const ::cyberprobe::GrePptp& Event::_internal_gre_pptp() const {
  return *Detail_.gre_pptp_;
}
inline ::cyberprobe::GrePptp* Event::release_gre_pptp() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.gre_pptp)
  if (has_gre_pptp()) {
    clear_has_Detail();
      ::cyberprobe::GrePptp* temp = Detail_.gre_pptp_;
    Detail_.gre_pptp_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cyberprobe::GrePptp& Event::gre_pptp() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.gre_pptp)
  return has_gre_pptp()
      ? *Detail_.gre_pptp_
      : *reinterpret_cast< ::cyberprobe::GrePptp*>(&::cyberprobe::_GrePptp_default_instance_);
}
inline ::cyberprobe::GrePptp* Event::mutable_gre_pptp() {
  if (!has_gre_pptp()) {
    clear_Detail();
    set_has_gre_pptp();
    Detail_.gre_pptp_ = CreateMaybeMessage< ::cyberprobe::GrePptp >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.gre_pptp)
  return Detail_.gre_pptp_;
}

// .cyberprobe.Esp esp = 32;
inline bool Event::has_esp() const {
  return Detail_case() == kEsp;
}
inline void Event::set_has_esp() {
  _oneof_case_[0] = kEsp;
}
inline void Event::clear_esp() {
  if (has_esp()) {
    delete Detail_.esp_;
    clear_has_Detail();
  }
}
inline const ::cyberprobe::Esp& Event::_internal_esp() const {
  return *Detail_.esp_;
}
inline ::cyberprobe::Esp* Event::release_esp() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.esp)
  if (has_esp()) {
    clear_has_Detail();
      ::cyberprobe::Esp* temp = Detail_.esp_;
    Detail_.esp_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cyberprobe::Esp& Event::esp() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.esp)
  return has_esp()
      ? *Detail_.esp_
      : *reinterpret_cast< ::cyberprobe::Esp*>(&::cyberprobe::_Esp_default_instance_);
}
inline ::cyberprobe::Esp* Event::mutable_esp() {
  if (!has_esp()) {
    clear_Detail();
    set_has_esp();
    Detail_.esp_ = CreateMaybeMessage< ::cyberprobe::Esp >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.esp)
  return Detail_.esp_;
}

// .cyberprobe.UnrecognisedIpProtocol unrecognised_ip_protocol = 33;
inline bool Event::has_unrecognised_ip_protocol() const {
  return Detail_case() == kUnrecognisedIpProtocol;
}
inline void Event::set_has_unrecognised_ip_protocol() {
  _oneof_case_[0] = kUnrecognisedIpProtocol;
}
inline void Event::clear_unrecognised_ip_protocol() {
  if (has_unrecognised_ip_protocol()) {
    delete Detail_.unrecognised_ip_protocol_;
    clear_has_Detail();
  }
}
inline const ::cyberprobe::UnrecognisedIpProtocol& Event::_internal_unrecognised_ip_protocol() const {
  return *Detail_.unrecognised_ip_protocol_;
}
inline ::cyberprobe::UnrecognisedIpProtocol* Event::release_unrecognised_ip_protocol() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.unrecognised_ip_protocol)
  if (has_unrecognised_ip_protocol()) {
    clear_has_Detail();
      ::cyberprobe::UnrecognisedIpProtocol* temp = Detail_.unrecognised_ip_protocol_;
    Detail_.unrecognised_ip_protocol_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cyberprobe::UnrecognisedIpProtocol& Event::unrecognised_ip_protocol() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.unrecognised_ip_protocol)
  return has_unrecognised_ip_protocol()
      ? *Detail_.unrecognised_ip_protocol_
      : *reinterpret_cast< ::cyberprobe::UnrecognisedIpProtocol*>(&::cyberprobe::_UnrecognisedIpProtocol_default_instance_);
}
inline ::cyberprobe::UnrecognisedIpProtocol* Event::mutable_unrecognised_ip_protocol() {
  if (!has_unrecognised_ip_protocol()) {
    clear_Detail();
    set_has_unrecognised_ip_protocol();
    Detail_.unrecognised_ip_protocol_ = CreateMaybeMessage< ::cyberprobe::UnrecognisedIpProtocol >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.unrecognised_ip_protocol)
  return Detail_.unrecognised_ip_protocol_;
}

// .cyberprobe.Wlan wlan = 34;
inline bool Event::has_wlan() const {
  return Detail_case() == kWlan;
}
inline void Event::set_has_wlan() {
  _oneof_case_[0] = kWlan;
}
inline void Event::clear_wlan() {
  if (has_wlan()) {
    delete Detail_.wlan_;
    clear_has_Detail();
  }
}
inline const ::cyberprobe::Wlan& Event::_internal_wlan() const {
  return *Detail_.wlan_;
}
inline ::cyberprobe::Wlan* Event::release_wlan() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.wlan)
  if (has_wlan()) {
    clear_has_Detail();
      ::cyberprobe::Wlan* temp = Detail_.wlan_;
    Detail_.wlan_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cyberprobe::Wlan& Event::wlan() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.wlan)
  return has_wlan()
      ? *Detail_.wlan_
      : *reinterpret_cast< ::cyberprobe::Wlan*>(&::cyberprobe::_Wlan_default_instance_);
}
inline ::cyberprobe::Wlan* Event::mutable_wlan() {
  if (!has_wlan()) {
    clear_Detail();
    set_has_wlan();
    Detail_.wlan_ = CreateMaybeMessage< ::cyberprobe::Wlan >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.wlan)
  return Detail_.wlan_;
}

// .cyberprobe.TlsUnknown tls_unknown = 35;
inline bool Event::has_tls_unknown() const {
  return Detail_case() == kTlsUnknown;
}
inline void Event::set_has_tls_unknown() {
  _oneof_case_[0] = kTlsUnknown;
}
inline void Event::clear_tls_unknown() {
  if (has_tls_unknown()) {
    delete Detail_.tls_unknown_;
    clear_has_Detail();
  }
}
inline const ::cyberprobe::TlsUnknown& Event::_internal_tls_unknown() const {
  return *Detail_.tls_unknown_;
}
inline ::cyberprobe::TlsUnknown* Event::release_tls_unknown() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.tls_unknown)
  if (has_tls_unknown()) {
    clear_has_Detail();
      ::cyberprobe::TlsUnknown* temp = Detail_.tls_unknown_;
    Detail_.tls_unknown_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cyberprobe::TlsUnknown& Event::tls_unknown() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.tls_unknown)
  return has_tls_unknown()
      ? *Detail_.tls_unknown_
      : *reinterpret_cast< ::cyberprobe::TlsUnknown*>(&::cyberprobe::_TlsUnknown_default_instance_);
}
inline ::cyberprobe::TlsUnknown* Event::mutable_tls_unknown() {
  if (!has_tls_unknown()) {
    clear_Detail();
    set_has_tls_unknown();
    Detail_.tls_unknown_ = CreateMaybeMessage< ::cyberprobe::TlsUnknown >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.tls_unknown)
  return Detail_.tls_unknown_;
}

// .cyberprobe.TlsClientHello tls_client_hello = 36;
inline bool Event::has_tls_client_hello() const {
  return Detail_case() == kTlsClientHello;
}
inline void Event::set_has_tls_client_hello() {
  _oneof_case_[0] = kTlsClientHello;
}
inline void Event::clear_tls_client_hello() {
  if (has_tls_client_hello()) {
    delete Detail_.tls_client_hello_;
    clear_has_Detail();
  }
}
inline const ::cyberprobe::TlsClientHello& Event::_internal_tls_client_hello() const {
  return *Detail_.tls_client_hello_;
}
inline ::cyberprobe::TlsClientHello* Event::release_tls_client_hello() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.tls_client_hello)
  if (has_tls_client_hello()) {
    clear_has_Detail();
      ::cyberprobe::TlsClientHello* temp = Detail_.tls_client_hello_;
    Detail_.tls_client_hello_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cyberprobe::TlsClientHello& Event::tls_client_hello() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.tls_client_hello)
  return has_tls_client_hello()
      ? *Detail_.tls_client_hello_
      : *reinterpret_cast< ::cyberprobe::TlsClientHello*>(&::cyberprobe::_TlsClientHello_default_instance_);
}
inline ::cyberprobe::TlsClientHello* Event::mutable_tls_client_hello() {
  if (!has_tls_client_hello()) {
    clear_Detail();
    set_has_tls_client_hello();
    Detail_.tls_client_hello_ = CreateMaybeMessage< ::cyberprobe::TlsClientHello >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.tls_client_hello)
  return Detail_.tls_client_hello_;
}

// .cyberprobe.TlsServerHello tls_server_hello = 37;
inline bool Event::has_tls_server_hello() const {
  return Detail_case() == kTlsServerHello;
}
inline void Event::set_has_tls_server_hello() {
  _oneof_case_[0] = kTlsServerHello;
}
inline void Event::clear_tls_server_hello() {
  if (has_tls_server_hello()) {
    delete Detail_.tls_server_hello_;
    clear_has_Detail();
  }
}
inline const ::cyberprobe::TlsServerHello& Event::_internal_tls_server_hello() const {
  return *Detail_.tls_server_hello_;
}
inline ::cyberprobe::TlsServerHello* Event::release_tls_server_hello() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.tls_server_hello)
  if (has_tls_server_hello()) {
    clear_has_Detail();
      ::cyberprobe::TlsServerHello* temp = Detail_.tls_server_hello_;
    Detail_.tls_server_hello_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cyberprobe::TlsServerHello& Event::tls_server_hello() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.tls_server_hello)
  return has_tls_server_hello()
      ? *Detail_.tls_server_hello_
      : *reinterpret_cast< ::cyberprobe::TlsServerHello*>(&::cyberprobe::_TlsServerHello_default_instance_);
}
inline ::cyberprobe::TlsServerHello* Event::mutable_tls_server_hello() {
  if (!has_tls_server_hello()) {
    clear_Detail();
    set_has_tls_server_hello();
    Detail_.tls_server_hello_ = CreateMaybeMessage< ::cyberprobe::TlsServerHello >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.tls_server_hello)
  return Detail_.tls_server_hello_;
}

// .cyberprobe.TlsCertificates tls_certificates = 38;
inline bool Event::has_tls_certificates() const {
  return Detail_case() == kTlsCertificates;
}
inline void Event::set_has_tls_certificates() {
  _oneof_case_[0] = kTlsCertificates;
}
inline void Event::clear_tls_certificates() {
  if (has_tls_certificates()) {
    delete Detail_.tls_certificates_;
    clear_has_Detail();
  }
}
inline const ::cyberprobe::TlsCertificates& Event::_internal_tls_certificates() const {
  return *Detail_.tls_certificates_;
}
inline ::cyberprobe::TlsCertificates* Event::release_tls_certificates() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.tls_certificates)
  if (has_tls_certificates()) {
    clear_has_Detail();
      ::cyberprobe::TlsCertificates* temp = Detail_.tls_certificates_;
    Detail_.tls_certificates_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cyberprobe::TlsCertificates& Event::tls_certificates() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.tls_certificates)
  return has_tls_certificates()
      ? *Detail_.tls_certificates_
      : *reinterpret_cast< ::cyberprobe::TlsCertificates*>(&::cyberprobe::_TlsCertificates_default_instance_);
}
inline ::cyberprobe::TlsCertificates* Event::mutable_tls_certificates() {
  if (!has_tls_certificates()) {
    clear_Detail();
    set_has_tls_certificates();
    Detail_.tls_certificates_ = CreateMaybeMessage< ::cyberprobe::TlsCertificates >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.tls_certificates)
  return Detail_.tls_certificates_;
}

// .cyberprobe.TlsServerKeyExchange tls_server_key_exchange = 39;
inline bool Event::has_tls_server_key_exchange() const {
  return Detail_case() == kTlsServerKeyExchange;
}
inline void Event::set_has_tls_server_key_exchange() {
  _oneof_case_[0] = kTlsServerKeyExchange;
}
inline void Event::clear_tls_server_key_exchange() {
  if (has_tls_server_key_exchange()) {
    delete Detail_.tls_server_key_exchange_;
    clear_has_Detail();
  }
}
inline const ::cyberprobe::TlsServerKeyExchange& Event::_internal_tls_server_key_exchange() const {
  return *Detail_.tls_server_key_exchange_;
}
inline ::cyberprobe::TlsServerKeyExchange* Event::release_tls_server_key_exchange() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.tls_server_key_exchange)
  if (has_tls_server_key_exchange()) {
    clear_has_Detail();
      ::cyberprobe::TlsServerKeyExchange* temp = Detail_.tls_server_key_exchange_;
    Detail_.tls_server_key_exchange_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cyberprobe::TlsServerKeyExchange& Event::tls_server_key_exchange() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.tls_server_key_exchange)
  return has_tls_server_key_exchange()
      ? *Detail_.tls_server_key_exchange_
      : *reinterpret_cast< ::cyberprobe::TlsServerKeyExchange*>(&::cyberprobe::_TlsServerKeyExchange_default_instance_);
}
inline ::cyberprobe::TlsServerKeyExchange* Event::mutable_tls_server_key_exchange() {
  if (!has_tls_server_key_exchange()) {
    clear_Detail();
    set_has_tls_server_key_exchange();
    Detail_.tls_server_key_exchange_ = CreateMaybeMessage< ::cyberprobe::TlsServerKeyExchange >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.tls_server_key_exchange)
  return Detail_.tls_server_key_exchange_;
}

// .cyberprobe.TlsServerHelloDone tls_server_hello_done = 40;
inline bool Event::has_tls_server_hello_done() const {
  return Detail_case() == kTlsServerHelloDone;
}
inline void Event::set_has_tls_server_hello_done() {
  _oneof_case_[0] = kTlsServerHelloDone;
}
inline void Event::clear_tls_server_hello_done() {
  if (has_tls_server_hello_done()) {
    delete Detail_.tls_server_hello_done_;
    clear_has_Detail();
  }
}
inline const ::cyberprobe::TlsServerHelloDone& Event::_internal_tls_server_hello_done() const {
  return *Detail_.tls_server_hello_done_;
}
inline ::cyberprobe::TlsServerHelloDone* Event::release_tls_server_hello_done() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.tls_server_hello_done)
  if (has_tls_server_hello_done()) {
    clear_has_Detail();
      ::cyberprobe::TlsServerHelloDone* temp = Detail_.tls_server_hello_done_;
    Detail_.tls_server_hello_done_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cyberprobe::TlsServerHelloDone& Event::tls_server_hello_done() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.tls_server_hello_done)
  return has_tls_server_hello_done()
      ? *Detail_.tls_server_hello_done_
      : *reinterpret_cast< ::cyberprobe::TlsServerHelloDone*>(&::cyberprobe::_TlsServerHelloDone_default_instance_);
}
inline ::cyberprobe::TlsServerHelloDone* Event::mutable_tls_server_hello_done() {
  if (!has_tls_server_hello_done()) {
    clear_Detail();
    set_has_tls_server_hello_done();
    Detail_.tls_server_hello_done_ = CreateMaybeMessage< ::cyberprobe::TlsServerHelloDone >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.tls_server_hello_done)
  return Detail_.tls_server_hello_done_;
}

// .cyberprobe.TlsHandshakeUnknown tls_handshake_unknown = 41;
inline bool Event::has_tls_handshake_unknown() const {
  return Detail_case() == kTlsHandshakeUnknown;
}
inline void Event::set_has_tls_handshake_unknown() {
  _oneof_case_[0] = kTlsHandshakeUnknown;
}
inline void Event::clear_tls_handshake_unknown() {
  if (has_tls_handshake_unknown()) {
    delete Detail_.tls_handshake_unknown_;
    clear_has_Detail();
  }
}
inline const ::cyberprobe::TlsHandshakeUnknown& Event::_internal_tls_handshake_unknown() const {
  return *Detail_.tls_handshake_unknown_;
}
inline ::cyberprobe::TlsHandshakeUnknown* Event::release_tls_handshake_unknown() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.tls_handshake_unknown)
  if (has_tls_handshake_unknown()) {
    clear_has_Detail();
      ::cyberprobe::TlsHandshakeUnknown* temp = Detail_.tls_handshake_unknown_;
    Detail_.tls_handshake_unknown_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cyberprobe::TlsHandshakeUnknown& Event::tls_handshake_unknown() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.tls_handshake_unknown)
  return has_tls_handshake_unknown()
      ? *Detail_.tls_handshake_unknown_
      : *reinterpret_cast< ::cyberprobe::TlsHandshakeUnknown*>(&::cyberprobe::_TlsHandshakeUnknown_default_instance_);
}
inline ::cyberprobe::TlsHandshakeUnknown* Event::mutable_tls_handshake_unknown() {
  if (!has_tls_handshake_unknown()) {
    clear_Detail();
    set_has_tls_handshake_unknown();
    Detail_.tls_handshake_unknown_ = CreateMaybeMessage< ::cyberprobe::TlsHandshakeUnknown >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.tls_handshake_unknown)
  return Detail_.tls_handshake_unknown_;
}

// .cyberprobe.TlsCertificateRequest tls_certificate_request = 42;
inline bool Event::has_tls_certificate_request() const {
  return Detail_case() == kTlsCertificateRequest;
}
inline void Event::set_has_tls_certificate_request() {
  _oneof_case_[0] = kTlsCertificateRequest;
}
inline void Event::clear_tls_certificate_request() {
  if (has_tls_certificate_request()) {
    delete Detail_.tls_certificate_request_;
    clear_has_Detail();
  }
}
inline const ::cyberprobe::TlsCertificateRequest& Event::_internal_tls_certificate_request() const {
  return *Detail_.tls_certificate_request_;
}
inline ::cyberprobe::TlsCertificateRequest* Event::release_tls_certificate_request() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.tls_certificate_request)
  if (has_tls_certificate_request()) {
    clear_has_Detail();
      ::cyberprobe::TlsCertificateRequest* temp = Detail_.tls_certificate_request_;
    Detail_.tls_certificate_request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cyberprobe::TlsCertificateRequest& Event::tls_certificate_request() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.tls_certificate_request)
  return has_tls_certificate_request()
      ? *Detail_.tls_certificate_request_
      : *reinterpret_cast< ::cyberprobe::TlsCertificateRequest*>(&::cyberprobe::_TlsCertificateRequest_default_instance_);
}
inline ::cyberprobe::TlsCertificateRequest* Event::mutable_tls_certificate_request() {
  if (!has_tls_certificate_request()) {
    clear_Detail();
    set_has_tls_certificate_request();
    Detail_.tls_certificate_request_ = CreateMaybeMessage< ::cyberprobe::TlsCertificateRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.tls_certificate_request)
  return Detail_.tls_certificate_request_;
}

// .cyberprobe.TlsClientKeyExchange tls_client_key_exchange = 43;
inline bool Event::has_tls_client_key_exchange() const {
  return Detail_case() == kTlsClientKeyExchange;
}
inline void Event::set_has_tls_client_key_exchange() {
  _oneof_case_[0] = kTlsClientKeyExchange;
}
inline void Event::clear_tls_client_key_exchange() {
  if (has_tls_client_key_exchange()) {
    delete Detail_.tls_client_key_exchange_;
    clear_has_Detail();
  }
}
inline const ::cyberprobe::TlsClientKeyExchange& Event::_internal_tls_client_key_exchange() const {
  return *Detail_.tls_client_key_exchange_;
}
inline ::cyberprobe::TlsClientKeyExchange* Event::release_tls_client_key_exchange() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.tls_client_key_exchange)
  if (has_tls_client_key_exchange()) {
    clear_has_Detail();
      ::cyberprobe::TlsClientKeyExchange* temp = Detail_.tls_client_key_exchange_;
    Detail_.tls_client_key_exchange_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cyberprobe::TlsClientKeyExchange& Event::tls_client_key_exchange() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.tls_client_key_exchange)
  return has_tls_client_key_exchange()
      ? *Detail_.tls_client_key_exchange_
      : *reinterpret_cast< ::cyberprobe::TlsClientKeyExchange*>(&::cyberprobe::_TlsClientKeyExchange_default_instance_);
}
inline ::cyberprobe::TlsClientKeyExchange* Event::mutable_tls_client_key_exchange() {
  if (!has_tls_client_key_exchange()) {
    clear_Detail();
    set_has_tls_client_key_exchange();
    Detail_.tls_client_key_exchange_ = CreateMaybeMessage< ::cyberprobe::TlsClientKeyExchange >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.tls_client_key_exchange)
  return Detail_.tls_client_key_exchange_;
}

// .cyberprobe.TlsCertificateVerify tls_certificate_verify = 44;
inline bool Event::has_tls_certificate_verify() const {
  return Detail_case() == kTlsCertificateVerify;
}
inline void Event::set_has_tls_certificate_verify() {
  _oneof_case_[0] = kTlsCertificateVerify;
}
inline void Event::clear_tls_certificate_verify() {
  if (has_tls_certificate_verify()) {
    delete Detail_.tls_certificate_verify_;
    clear_has_Detail();
  }
}
inline const ::cyberprobe::TlsCertificateVerify& Event::_internal_tls_certificate_verify() const {
  return *Detail_.tls_certificate_verify_;
}
inline ::cyberprobe::TlsCertificateVerify* Event::release_tls_certificate_verify() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.tls_certificate_verify)
  if (has_tls_certificate_verify()) {
    clear_has_Detail();
      ::cyberprobe::TlsCertificateVerify* temp = Detail_.tls_certificate_verify_;
    Detail_.tls_certificate_verify_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cyberprobe::TlsCertificateVerify& Event::tls_certificate_verify() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.tls_certificate_verify)
  return has_tls_certificate_verify()
      ? *Detail_.tls_certificate_verify_
      : *reinterpret_cast< ::cyberprobe::TlsCertificateVerify*>(&::cyberprobe::_TlsCertificateVerify_default_instance_);
}
inline ::cyberprobe::TlsCertificateVerify* Event::mutable_tls_certificate_verify() {
  if (!has_tls_certificate_verify()) {
    clear_Detail();
    set_has_tls_certificate_verify();
    Detail_.tls_certificate_verify_ = CreateMaybeMessage< ::cyberprobe::TlsCertificateVerify >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.tls_certificate_verify)
  return Detail_.tls_certificate_verify_;
}

// .cyberprobe.TlsChangeCipherSpec tls_change_cipher_spec = 45;
inline bool Event::has_tls_change_cipher_spec() const {
  return Detail_case() == kTlsChangeCipherSpec;
}
inline void Event::set_has_tls_change_cipher_spec() {
  _oneof_case_[0] = kTlsChangeCipherSpec;
}
inline void Event::clear_tls_change_cipher_spec() {
  if (has_tls_change_cipher_spec()) {
    delete Detail_.tls_change_cipher_spec_;
    clear_has_Detail();
  }
}
inline const ::cyberprobe::TlsChangeCipherSpec& Event::_internal_tls_change_cipher_spec() const {
  return *Detail_.tls_change_cipher_spec_;
}
inline ::cyberprobe::TlsChangeCipherSpec* Event::release_tls_change_cipher_spec() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.tls_change_cipher_spec)
  if (has_tls_change_cipher_spec()) {
    clear_has_Detail();
      ::cyberprobe::TlsChangeCipherSpec* temp = Detail_.tls_change_cipher_spec_;
    Detail_.tls_change_cipher_spec_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cyberprobe::TlsChangeCipherSpec& Event::tls_change_cipher_spec() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.tls_change_cipher_spec)
  return has_tls_change_cipher_spec()
      ? *Detail_.tls_change_cipher_spec_
      : *reinterpret_cast< ::cyberprobe::TlsChangeCipherSpec*>(&::cyberprobe::_TlsChangeCipherSpec_default_instance_);
}
inline ::cyberprobe::TlsChangeCipherSpec* Event::mutable_tls_change_cipher_spec() {
  if (!has_tls_change_cipher_spec()) {
    clear_Detail();
    set_has_tls_change_cipher_spec();
    Detail_.tls_change_cipher_spec_ = CreateMaybeMessage< ::cyberprobe::TlsChangeCipherSpec >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.tls_change_cipher_spec)
  return Detail_.tls_change_cipher_spec_;
}

// .cyberprobe.TlsHandshakeFinished tls_handshake_finished = 46;
inline bool Event::has_tls_handshake_finished() const {
  return Detail_case() == kTlsHandshakeFinished;
}
inline void Event::set_has_tls_handshake_finished() {
  _oneof_case_[0] = kTlsHandshakeFinished;
}
inline void Event::clear_tls_handshake_finished() {
  if (has_tls_handshake_finished()) {
    delete Detail_.tls_handshake_finished_;
    clear_has_Detail();
  }
}
inline const ::cyberprobe::TlsHandshakeFinished& Event::_internal_tls_handshake_finished() const {
  return *Detail_.tls_handshake_finished_;
}
inline ::cyberprobe::TlsHandshakeFinished* Event::release_tls_handshake_finished() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.tls_handshake_finished)
  if (has_tls_handshake_finished()) {
    clear_has_Detail();
      ::cyberprobe::TlsHandshakeFinished* temp = Detail_.tls_handshake_finished_;
    Detail_.tls_handshake_finished_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cyberprobe::TlsHandshakeFinished& Event::tls_handshake_finished() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.tls_handshake_finished)
  return has_tls_handshake_finished()
      ? *Detail_.tls_handshake_finished_
      : *reinterpret_cast< ::cyberprobe::TlsHandshakeFinished*>(&::cyberprobe::_TlsHandshakeFinished_default_instance_);
}
inline ::cyberprobe::TlsHandshakeFinished* Event::mutable_tls_handshake_finished() {
  if (!has_tls_handshake_finished()) {
    clear_Detail();
    set_has_tls_handshake_finished();
    Detail_.tls_handshake_finished_ = CreateMaybeMessage< ::cyberprobe::TlsHandshakeFinished >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.tls_handshake_finished)
  return Detail_.tls_handshake_finished_;
}

// .cyberprobe.TlsHandshakeComplete tls_handshake_complete = 47;
inline bool Event::has_tls_handshake_complete() const {
  return Detail_case() == kTlsHandshakeComplete;
}
inline void Event::set_has_tls_handshake_complete() {
  _oneof_case_[0] = kTlsHandshakeComplete;
}
inline void Event::clear_tls_handshake_complete() {
  if (has_tls_handshake_complete()) {
    delete Detail_.tls_handshake_complete_;
    clear_has_Detail();
  }
}
inline const ::cyberprobe::TlsHandshakeComplete& Event::_internal_tls_handshake_complete() const {
  return *Detail_.tls_handshake_complete_;
}
inline ::cyberprobe::TlsHandshakeComplete* Event::release_tls_handshake_complete() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.tls_handshake_complete)
  if (has_tls_handshake_complete()) {
    clear_has_Detail();
      ::cyberprobe::TlsHandshakeComplete* temp = Detail_.tls_handshake_complete_;
    Detail_.tls_handshake_complete_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cyberprobe::TlsHandshakeComplete& Event::tls_handshake_complete() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.tls_handshake_complete)
  return has_tls_handshake_complete()
      ? *Detail_.tls_handshake_complete_
      : *reinterpret_cast< ::cyberprobe::TlsHandshakeComplete*>(&::cyberprobe::_TlsHandshakeComplete_default_instance_);
}
inline ::cyberprobe::TlsHandshakeComplete* Event::mutable_tls_handshake_complete() {
  if (!has_tls_handshake_complete()) {
    clear_Detail();
    set_has_tls_handshake_complete();
    Detail_.tls_handshake_complete_ = CreateMaybeMessage< ::cyberprobe::TlsHandshakeComplete >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.tls_handshake_complete)
  return Detail_.tls_handshake_complete_;
}

// .cyberprobe.TlsApplicationData tls_application_data = 48;
inline bool Event::has_tls_application_data() const {
  return Detail_case() == kTlsApplicationData;
}
inline void Event::set_has_tls_application_data() {
  _oneof_case_[0] = kTlsApplicationData;
}
inline void Event::clear_tls_application_data() {
  if (has_tls_application_data()) {
    delete Detail_.tls_application_data_;
    clear_has_Detail();
  }
}
inline const ::cyberprobe::TlsApplicationData& Event::_internal_tls_application_data() const {
  return *Detail_.tls_application_data_;
}
inline ::cyberprobe::TlsApplicationData* Event::release_tls_application_data() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.tls_application_data)
  if (has_tls_application_data()) {
    clear_has_Detail();
      ::cyberprobe::TlsApplicationData* temp = Detail_.tls_application_data_;
    Detail_.tls_application_data_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::cyberprobe::TlsApplicationData& Event::tls_application_data() const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.tls_application_data)
  return has_tls_application_data()
      ? *Detail_.tls_application_data_
      : *reinterpret_cast< ::cyberprobe::TlsApplicationData*>(&::cyberprobe::_TlsApplicationData_default_instance_);
}
inline ::cyberprobe::TlsApplicationData* Event::mutable_tls_application_data() {
  if (!has_tls_application_data()) {
    clear_Detail();
    set_has_tls_application_data();
    Detail_.tls_application_data_ = CreateMaybeMessage< ::cyberprobe::TlsApplicationData >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.tls_application_data)
  return Detail_.tls_application_data_;
}

// .cyberprobe.Locations location = 49;
inline bool Event::has_location() const {
  return this != internal_default_instance() && location_ != NULL;
}
inline void Event::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) {
    delete location_;
  }
  location_ = NULL;
}
inline const ::cyberprobe::Locations& Event::_internal_location() const {
  return *location_;
}
inline const ::cyberprobe::Locations& Event::location() const {
  const ::cyberprobe::Locations* p = location_;
  // @@protoc_insertion_point(field_get:cyberprobe.Event.location)
  return p != NULL ? *p : *reinterpret_cast<const ::cyberprobe::Locations*>(
      &::cyberprobe::_Locations_default_instance_);
}
inline ::cyberprobe::Locations* Event::release_location() {
  // @@protoc_insertion_point(field_release:cyberprobe.Event.location)
  
  ::cyberprobe::Locations* temp = location_;
  location_ = NULL;
  return temp;
}
inline ::cyberprobe::Locations* Event::mutable_location() {
  
  if (location_ == NULL) {
    auto* p = CreateMaybeMessage<::cyberprobe::Locations>(GetArenaNoVirtual());
    location_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.location)
  return location_;
}
inline void Event::set_allocated_location(::cyberprobe::Locations* location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete location_;
  }
  if (location) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:cyberprobe.Event.location)
}

// repeated .cyberprobe.Indicator indicators = 50;
inline int Event::indicators_size() const {
  return indicators_.size();
}
inline void Event::clear_indicators() {
  indicators_.Clear();
}
inline ::cyberprobe::Indicator* Event::mutable_indicators(int index) {
  // @@protoc_insertion_point(field_mutable:cyberprobe.Event.indicators)
  return indicators_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::cyberprobe::Indicator >*
Event::mutable_indicators() {
  // @@protoc_insertion_point(field_mutable_list:cyberprobe.Event.indicators)
  return &indicators_;
}
inline const ::cyberprobe::Indicator& Event::indicators(int index) const {
  // @@protoc_insertion_point(field_get:cyberprobe.Event.indicators)
  return indicators_.Get(index);
}
inline ::cyberprobe::Indicator* Event::add_indicators() {
  // @@protoc_insertion_point(field_add:cyberprobe.Event.indicators)
  return indicators_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cyberprobe::Indicator >&
Event::indicators() const {
  // @@protoc_insertion_point(field_list:cyberprobe.Event.indicators)
  return indicators_;
}

inline bool Event::has_Detail() const {
  return Detail_case() != DETAIL_NOT_SET;
}
inline void Event::clear_has_Detail() {
  _oneof_case_[0] = DETAIL_NOT_SET;
}
inline Event::DetailCase Event::Detail_case() const {
  return Event::DetailCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Empty

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace cyberprobe

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::cyberprobe::Action> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cyberprobe::Action>() {
  return ::cyberprobe::Action_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_cyberprobe_2eproto
