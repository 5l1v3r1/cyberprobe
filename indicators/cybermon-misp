#!/usr/bin/env python3

import json
import sys
import os
import time
from threading import Thread
import queue
import cyberprobe.qcomms as qcomms
from cyberprobe.fsm import Fsm, FsmState, FsmCollection
import cyberprobe.indicators as ind
import cyberprobe.detector as detector
import cyberprobe.misp as misp

if len(sys.argv) < 2:
    binding = "geo"
else:
    binding = sys.argv[1]
    
if len(sys.argv) < 3:
    output = "ioc"
else:
    output = "ioc"

misp_url = os.getenv("MISP_HOST", "http://localhost")
misp_token = os.getenv("MISP_TOKEN", "TOKEN")

det = detector.Detector()
q = queue.Queue()

class FetchIndicators(Thread):
    def __init__(self, url, token, q):
        Thread.__init__(self)
        self.q = q
        self.m = misp.MispParser({
            "url": url,
            "token": token
        })

    def run(self):

        try:
            mtime = 0
            while True:

                inds = [v for v in self.m.to_indicators()]
                iocs = ind.Indicators(indicators=inds)
                fsc = FsmCollection.load_from(iocs)

                print("Indicators loaded.")

                self.q.put((iocs, fsc))

                # FIXME: Better strategy needed instead of scanning the
                # entire thing.
                time.sleep(30)
                
        except Exception as e:
            # Put exception on q and bail
            print("Exception:", e)
            self.q.put(e)
            return

fi = FetchIndicators(misp_url, misp_token, q)
fi.start()

def handle(msg, output):

    if not q.empty():
        elt = q.get()
        if isinstance(elt, Exception):
            raise elt
        else:
            # Assume it's an indicator set
            det.load_fsc(elt[0], elt[1])

    event = json.loads(msg)
    det.detect(event)
    output(json.dumps(event))

try:
    while q.empty():
        time.sleep(0.1)
    print("Subscribing.")
    qcomms.subscribe(binding, handle, output)
except Exception as e:
    sys.stderr.write("Exception: %s\n" % str(e))
    sys.exit(1)

